{"version":3,"sources":["providers/http/http-provider.js"],"names":["define","async","paths","files","registry","NoSyncFile","BaseProvider","ErrorCodes","FileError","ActionType","Stats","FileType","utils","xhr","fetch","DirInode","FileIndex","FileInode","copyingSlice","xhrIsAvailable","asyncDownloadFile","syncDownloadFile","getFileSizeAsync","getFileSizeSync","fetchIsAvailable","fetchFileAsync","fetchFileSizeAsync","isFileInode","isDirInode","syncNotAvailableError","ENOTSUP","HttpProvider","constructor","index","prefixUrl","preferXHR","super","length","charAt","this","_index","fromListing","_requestFileAsyncInternal","_requestFileSizeAsyncInternal","_requestFileSyncInternal","_requestFileSizeSyncInternal","Create","opts","cb","undefined","e","data","baseUrl","isAvailable","empty","fileIterator","file","fileData","getName","Name","diskSpace","path","isReadOnly","supportsLinks","supportsProps","supportsSynch","preloadFile","buffer","inode","getInode","EISDIR","ENOENT","stats","getData","size","stat","isLstat","let","_requestFileSizeAsync","clone","getStats","EINVAL","statSync","_requestFileSizeSync","open","flags","mode","isWriteable","EPERM","self","pathExistsAction","THROW_EXCEPTION","TRUNCATE_FILE","EEXIST","NOP","_requestFileAsync","err","openSync","_requestFileSync","readdir","readdirSync","getListing","ENOTDIR","readFile","fname","encoding","flag","oldCb","fd","arg","close","err2","fdBuff","getBuffer","tryToString","buff","toString","readFileSync","closeSync","_getHTTPPath","filePath","slice","p","type","Options","optional","description","add","providers"],"mappings":"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","file":"../../../providers/http/http-provider.js","sourcesContent":["define([\r\n    \"skylark-langx-async\",\r\n    \"skylark-langx-paths\",\r\n    \"../../files\",\r\n    \"../registry\",\r\n    '../../no-sync-file',\r\n    \"../base-provider\",\r\n    '../../error-codes',\r\n    '../../file-error',\r\n    '../../action-type',\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../../utils',\r\n    './xhr',\r\n    './fetch',\r\n    '../../inodes/dir-inode',\r\n    '../../inodes/file-index',\r\n    '../../inodes/file-inode',\r\n\r\n], function (async,paths,files,registry,NoSyncFile, BaseProvider, ErrorCodes, FileError,ActionType, Stats,FileType,  utils,xhr, fetch, DirInode,FileIndex,FileInode) {\r\n\r\n\r\n    'use strict';\r\n\r\n    const { copyingSlice }  = utils;\r\n\r\n    const { xhrIsAvailable, asyncDownloadFile, syncDownloadFile, getFileSizeAsync, getFileSizeSync }  = xhr;\r\n    const { fetchIsAvailable, fetchFileAsync, fetchFileSizeAsync }  = fetch;\r\n\r\n    const isFileInode = FileInode.isFileInode,\r\n          isDirInode = DirInode.isDirInode;\r\n    /**\r\n     * Try to convert the given buffer into a string, and pass it to the callback.\r\n     * Optimization that removes the needed try/catch into a helper function, as\r\n     * this is an uncommon case.\r\n     * @hidden\r\n     */\r\n    function tryToString(buff, encoding, cb) {\r\n        try {\r\n            cb(null, buff.toString(encoding));\r\n        }\r\n        catch (e) {\r\n            cb(e);\r\n        }\r\n    }\r\n    function syncNotAvailableError() {\r\n        throw new FileError(ErrorCodes.ENOTSUP, `Synchronous HTTP download methods are not available in this environment.`);\r\n    }\r\n    /**\r\n     * A simple filesystem backed by HTTP downloads. You must create a directory listing using the\r\n     * `make_http_index` tool provided by BrowserFS.\r\n     *\r\n     * If you install BrowserFS globally with `npm i -g browserfs`, you can generate a listing by\r\n     * running `make_http_index` in your terminal in the directory you would like to index:\r\n     *\r\n     * ```\r\n     * make_http_index > index.json\r\n     * ```\r\n     *\r\n     * Listings objects look like the following:\r\n     *\r\n     * ```json\r\n     * {\r\n     *   \"home\": {\r\n     *     \"jvilk\": {\r\n     *       \"someFile.txt\": null,\r\n     *       \"someDir\": {\r\n     *         // Empty directory\r\n     *       }\r\n     *     }\r\n     *   }\r\n     * }\r\n     * ```\r\n     *\r\n     * *This example has the folder `/home/jvilk` with subfile `someFile.txt` and subfolder `someDir`.*\r\n     */\r\n    class HttpProvider extends BaseProvider {\r\n        constructor(index, prefixUrl = '', preferXHR = false) {\r\n            super();\r\n            // prefix_url must end in a directory separator.\r\n            if (prefixUrl.length > 0 && prefixUrl.charAt(prefixUrl.length - 1) !== '/') {\r\n                prefixUrl = prefixUrl + '/';\r\n            }\r\n            this.prefixUrl = prefixUrl;\r\n            this._index = FileIndex.fromListing(index);\r\n            if (fetchIsAvailable && (!preferXHR || !xhrIsAvailable)) {\r\n                this._requestFileAsyncInternal = fetchFileAsync;\r\n                this._requestFileSizeAsyncInternal = fetchFileSizeAsync;\r\n            }\r\n            else {\r\n                this._requestFileAsyncInternal = asyncDownloadFile;\r\n                this._requestFileSizeAsyncInternal = getFileSizeAsync;\r\n            }\r\n            if (xhrIsAvailable) {\r\n                this._requestFileSyncInternal = syncDownloadFile;\r\n                this._requestFileSizeSyncInternal = getFileSizeSync;\r\n            }\r\n            else {\r\n                this._requestFileSyncInternal = syncNotAvailableError;\r\n                this._requestFileSizeSyncInternal = syncNotAvailableError;\r\n            }\r\n        }\r\n        /**\r\n         * Construct an HttpProvider file system backend with the given options.\r\n         */\r\n        static Create(opts, cb) {\r\n            if (opts.index === undefined) {\r\n                opts.index = `index.json`;\r\n            }\r\n            if (typeof (opts.index) === \"string\") {\r\n                asyncDownloadFile(opts.index, \"json\", (e, data) => {\r\n                    if (e) {\r\n                        cb(e);\r\n                    }\r\n                    else {\r\n                        cb(null, new HttpProvider(data, opts.baseUrl));\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                cb(null, new HttpProvider(opts.index, opts.baseUrl));\r\n            }\r\n        }\r\n        static isAvailable() {\r\n            return xhrIsAvailable || fetchIsAvailable;\r\n        }\r\n        empty() {\r\n            this._index.fileIterator(function (file) {\r\n                file.fileData = null;\r\n            });\r\n        }\r\n        getName() {\r\n            return HttpProvider.Name;\r\n        }\r\n        diskSpace(path, cb) {\r\n            // Read-only file system. We could calculate the total space, but that's not\r\n            // important right now.\r\n            cb(0, 0);\r\n        }\r\n        isReadOnly() {\r\n            return true;\r\n        }\r\n        supportsLinks() {\r\n            return false;\r\n        }\r\n        supportsProps() {\r\n            return false;\r\n        }\r\n        supportsSynch() {\r\n            // Synchronous operations are only available via the XHR interface for now.\r\n            return xhrIsAvailable;\r\n        }\r\n        /**\r\n         * Special HTTPFS function: Preload the given file into the index.\r\n         * @param [String] path\r\n         * @param [BrowserFS.Buffer] buffer\r\n         */\r\n        preloadFile(path, buffer) {\r\n            const inode = this._index.getInode(path);\r\n            if (isFileInode(inode)) {\r\n                if (inode === null) {\r\n                    throw FileError.ENOENT(path);\r\n                }\r\n                const stats = inode.getData();\r\n                stats.size = buffer.length;\r\n                stats.fileData = buffer;\r\n            }\r\n            else {\r\n                throw FileError.EISDIR(path);\r\n            }\r\n        }\r\n        stat(path, isLstat, cb) {\r\n            const inode = this._index.getInode(path);\r\n            if (inode === null) {\r\n                return cb(FileError.ENOENT(path));\r\n            }\r\n            let stats;\r\n            if (isFileInode(inode)) {\r\n                stats = inode.getData();\r\n                // At this point, a non-opened file will still have default stats from the listing.\r\n                if (stats.size < 0) {\r\n                    this._requestFileSizeAsync(path, function (e, size) {\r\n                        if (e) {\r\n                            return cb(e);\r\n                        }\r\n                        stats.size = size;\r\n                        cb(null, Stats.clone(stats));\r\n                    });\r\n                }\r\n                else {\r\n                    cb(null, Stats.clone(stats));\r\n                }\r\n            }\r\n            else if (isDirInode(inode)) {\r\n                stats = inode.getStats();\r\n                cb(null, stats);\r\n            }\r\n            else {\r\n                cb(FileError.FileError(ErrorCodes.EINVAL, path));\r\n            }\r\n        }\r\n        statSync(path, isLstat) {\r\n            const inode = this._index.getInode(path);\r\n            if (inode === null) {\r\n                throw FileError.ENOENT(path);\r\n            }\r\n            let stats;\r\n            if (isFileInode(inode)) {\r\n                stats = inode.getData();\r\n                // At this point, a non-opened file will still have default stats from the listing.\r\n                if (stats.size < 0) {\r\n                    stats.size = this._requestFileSizeSync(path);\r\n                }\r\n            }\r\n            else if (isDirInode(inode)) {\r\n                stats = inode.getStats();\r\n            }\r\n            else {\r\n                throw FileError.FileError(ErrorCodes.EINVAL, path);\r\n            }\r\n            return stats;\r\n        }\r\n        open(path, flags, mode, cb) {\r\n            // INVARIANT: You can't write to files on this file system.\r\n            if (flags.isWriteable()) {\r\n                return cb(new FileError(ErrorCodes.EPERM, path));\r\n            }\r\n            const self = this;\r\n            // Check if the path exists, and is a file.\r\n            const inode = this._index.getInode(path);\r\n            if (inode === null) {\r\n                return cb(FileError.ENOENT(path));\r\n            }\r\n            if (isFileInode(inode)) {\r\n                const stats = inode.getData();\r\n                switch (flags.pathExistsAction()) {\r\n                    case ActionType.THROW_EXCEPTION:\r\n                    case ActionType.TRUNCATE_FILE:\r\n                        return cb(FileError.EEXIST(path));\r\n                    case ActionType.NOP:\r\n                        // Use existing file contents.\r\n                        // XXX: Uh, this maintains the previously-used flag.\r\n                        if (stats.fileData) {\r\n                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), stats.fileData));\r\n                        }\r\n                        // @todo be lazier about actually requesting the file\r\n                        this._requestFileAsync(path, 'buffer', function (err, buffer) {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            // we don't initially have file sizes\r\n                            stats.size = buffer.length;\r\n                            stats.fileData = buffer;\r\n                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), buffer));\r\n                        });\r\n                        break;\r\n                    default:\r\n                        return cb(new FileError(ErrorCodes.EINVAL, 'Invalid FileMode object.'));\r\n                }\r\n            }\r\n            else {\r\n                return cb(FileError.EISDIR(path));\r\n            }\r\n        }\r\n        openSync(path, flags, mode) {\r\n            // INVARIANT: You can't write to files on this file system.\r\n            if (flags.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, path);\r\n            }\r\n            // Check if the path exists, and is a file.\r\n            const inode = this._index.getInode(path);\r\n            if (inode === null) {\r\n                throw FileError.ENOENT(path);\r\n            }\r\n            if (isFileInode(inode)) {\r\n                const stats = inode.getData();\r\n                switch (flags.pathExistsAction()) {\r\n                    case ActionType.THROW_EXCEPTION:\r\n                    case ActionType.TRUNCATE_FILE:\r\n                        throw FileError.EEXIST(path);\r\n                    case ActionType.NOP:\r\n                        // Use existing file contents.\r\n                        // XXX: Uh, this maintains the previously-used flag.\r\n                        if (stats.fileData) {\r\n                            return new NoSyncFile(this, path, flags, Stats.clone(stats), stats.fileData);\r\n                        }\r\n                        // @todo be lazier about actually requesting the file\r\n                        const buffer = this._requestFileSync(path, 'buffer');\r\n                        // we don't initially have file sizes\r\n                        stats.size = buffer.length;\r\n                        stats.fileData = buffer;\r\n                        return new NoSyncFile(this, path, flags, Stats.clone(stats), buffer);\r\n                    default:\r\n                        throw new FileError(ErrorCodes.EINVAL, 'Invalid FileMode object.');\r\n                }\r\n            }\r\n            else {\r\n                throw FileError.EISDIR(path);\r\n            }\r\n        }\r\n        readdir(path, cb) {\r\n            try {\r\n                cb(null, this.readdirSync(path));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        readdirSync(path) {\r\n            // Check if it exists.\r\n            const inode = this._index.getInode(path);\r\n            if (inode === null) {\r\n                throw FileError.ENOENT(path);\r\n            }\r\n            else if (isDirInode(inode)) {\r\n                return inode.getListing();\r\n            }\r\n            else {\r\n                throw FileError.ENOTDIR(path);\r\n            }\r\n        }\r\n        /**\r\n         * We have the entire file as a buffer; optimize readFile.\r\n         */\r\n        readFile(fname, encoding, flag, cb) {\r\n            // Wrap cb in file closing code.\r\n            const oldCb = cb;\r\n            // Get file.\r\n            this.open(fname, flag, 0x1a4, function (err, fd) {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                cb = function (err, arg) {\r\n                    fd.close(function (err2) {\r\n                        if (!err) {\r\n                            err = err2;\r\n                        }\r\n                        return oldCb(err, arg);\r\n                    });\r\n                };\r\n                const fdCast = fd;\r\n                const fdBuff = fdCast.getBuffer();\r\n                if (encoding === null) {\r\n                    cb(err, copyingSlice(fdBuff));\r\n                }\r\n                else {\r\n                    tryToString(fdBuff, encoding, cb);\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Specially-optimized readfile.\r\n         */\r\n        readFileSync(fname, encoding, flag) {\r\n            // Get file.\r\n            const fd = this.openSync(fname, flag, 0x1a4);\r\n            try {\r\n                const fdCast = fd;\r\n                const fdBuff = fdCast.getBuffer();\r\n                if (encoding === null) {\r\n                    return copyingSlice(fdBuff);\r\n                }\r\n                return fdBuff.toString(encoding);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        _getHTTPPath(filePath) {\r\n            if (filePath.charAt(0) === '/') {\r\n                filePath = filePath.slice(1);\r\n            }\r\n            return this.prefixUrl + filePath;\r\n        }\r\n        _requestFileAsync(p, type, cb) {\r\n            this._requestFileAsyncInternal(this._getHTTPPath(p), type, cb);\r\n        }\r\n        _requestFileSync(p, type) {\r\n            return this._requestFileSyncInternal(this._getHTTPPath(p), type);\r\n        }\r\n        /**\r\n         * Only requests the HEAD content, for the file size.\r\n         */\r\n        _requestFileSizeAsync(path, cb) {\r\n            this._requestFileSizeAsyncInternal(this._getHTTPPath(path), cb);\r\n        }\r\n        _requestFileSizeSync(path) {\r\n            return this._requestFileSizeSyncInternal(this._getHTTPPath(path));\r\n        }\r\n    }\r\n    HttpProvider.Name = \"http\";\r\n    HttpProvider.Options = {\r\n        index: {\r\n            type: [\"string\", \"object\"],\r\n            optional: true,\r\n            description: \"URL to a file index as a JSON file or the file index object itself, generated with the make_http_index script. Defaults to `index.json`.\"\r\n        },\r\n        baseUrl: {\r\n            type: \"string\",\r\n            optional: true,\r\n            description: \"Used as the URL prefix for fetched files. Default: Fetch files relative to the index.\"\r\n        },\r\n        preferXHR: {\r\n            type: \"boolean\",\r\n            optional: true,\r\n            description: \"Whether to prefer XmlHttpRequest or fetch for async operations if both are available. Default: false\"\r\n        }\r\n    };\r\n\r\n    registry.add(\"http\",HttpProvider);\r\n\r\n    return files.providers.HttpProvider = HttpProvider;\r\n});"]}