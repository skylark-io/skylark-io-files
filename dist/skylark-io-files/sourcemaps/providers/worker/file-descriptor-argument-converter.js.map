{"version":3,"sources":["providers/worker/file-descriptor-argument-converter.js"],"names":["define","Buffer","Stats","FileType","FileError","ErrorCodes","FileFlag","ActionType","utils","misc","SpecialArgType","constructor","this","_fileDescriptors","_nextId","toRemoteArg","fd","p","flag","cb","id","let","data","stat","err","stats","bufferToTransferrableObject","toBuffer","isReadable","read","alloc","size","bytesRead","buff","type","FD","path","getFlagString","ArrayBuffer","applyFdAPIRequest","request","fdArg","args","_applyFdChanges","method","e","remoteFd","transferrableObjectToBuffer","remoteStats","fromBuffer","getFileFlag","isWriteable","write","length","isAppendable","getPos","applyStatChanges","mode","chmod","truncate"],"mappings":";;;;;;;AAAAA,OAAO,CACH,8BACA,cACA,kBACA,mBACA,oBACA,kBACA,oBACA,cACA,SACA,sBACD,SAAUC,EAAQC,EAAMC,EAASC,EAAWC,EAAYC,EAASC,EAAWC,EAAMC,EAAKC,GAGtF,GAAM,GAA2DF,EA0HjE,aArHIG,cACIC,KAAKC,iBAAmB,GACxBD,KAAKE,QAAU,CACnB,CACAC,YAAYC,EAAIC,EAAGC,EAAMC,GACrB,MAAMC,EAAKR,KAAKE,OAAO,GACvBO,IAAIC,EACAC,GACJX,KAAKC,iBAAiBO,GAAMJ,GAEzBO,KAAK,CAACC,EAAKC,KACND,EACAL,EAAGK,CAAG,GAGND,EAAOd,EAAKiB,4BAA4BD,EAAME,SAAS,CAAC,EAEpDT,EAAKU,WAAW,EAChBZ,EAAGa,KAAK5B,EAAO6B,MAAML,EAAMM,IAAI,EAAG,EAAGN,EAAMM,KAAM,EAAG,CAACP,EAAKQ,EAAWC,KAC7DT,EACAL,EAAGK,CAAG,GAGNF,EAAOb,EAAKiB,4BAA4BO,CAAI,EAC5Cd,EAAG,KAAM,CACLe,KAAMxB,EAAeyB,GACrBf,GAAIA,EACJE,KAAMA,EACNC,KAAMA,EACNa,KAAMnB,EACNC,KAAMA,EAAKmB,cAAc,CAC7B,CAAC,EAET,CAAC,EAKDlB,EAAG,KAAM,CACLe,KAAMxB,EAAeyB,GACrBf,GAAIA,EACJE,KAAM,IAAIgB,YAAY,CAAC,EACvBf,KAAMA,EACNa,KAAMnB,EACNC,KAAMA,EAAKmB,cAAc,CAC7B,CAAC,EAGb,CAAC,CACL,CACAE,kBAAkBC,EAASrB,GACvB,MAAMsB,EAAQD,EAAQE,KAAK,GAC3B9B,KAAK+B,gBAAgBF,EAAO,CAACjB,EAAKR,KAC1BQ,EACAL,EAAGK,CAAG,EAINR,EAAGwB,EAAQI,QAAQ,IACQ,UAAnBJ,EAAQI,QACR,OAAOhC,KAAKC,iBAAiB4B,EAAMrB,IAEvCD,EAAG0B,CAAC,CACR,CAAC,CAET,CAAC,CACL,CACAF,gBAAgBG,EAAU3B,GACtB,MAAMH,EAAKJ,KAAKC,iBAAiBiC,EAAS1B,IAAKE,EAAOyB,4BAA4BD,EAASxB,IAAI,EAAG0B,EAAc9C,EAAM+C,WAAWF,4BAA4BD,EAASvB,IAAI,CAAC,EAErKL,EAAOZ,EAAS4C,YAAYJ,EAAS5B,IAAI,EAC3CA,EAAKiC,YAAY,EAGjBnC,EAAGoC,MAAM9B,EAAM,EAAGA,EAAK+B,OAAQnC,EAAKoC,aAAa,EAAItC,EAAGuC,OAAO,EAAI,EAAG,IAClE,SAASC,IAELxC,EAAGO,KAAK,CAACsB,EAAGpB,KACJoB,EACA1B,EAAG0B,CAAC,EAGApB,EAAMgC,OAAST,EAAYS,KAC3BzC,EAAG0C,MAAMV,EAAYS,KAAM,IACvBtC,EAAG0B,EAAG7B,CAAE,CACZ,CAAC,EAGDG,EAAG0B,EAAG7B,CAAE,CAGpB,CAAC,CACL,CACI6B,EACA1B,EAAG0B,CAAC,EAMC3B,EAAKoC,aAAa,EAMnBE,EAAiB,EALjBxC,EAAG2C,SAASrC,EAAK+B,OAAQ,KACrBG,EAAiB,CACrB,CAAC,CAMb,CAAC,EAGDrC,EAAG,KAAMH,CAAE,CAEnB,CACJ,CAGJ,CAAC","file":"../../../providers/worker/file-descriptor-argument-converter.js","sourcesContent":["define([\r\n    \"skylark-langx-binary/buffer\",\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    \"../../file-flag\",\r\n    \"../../action-type\",\r\n    \"../../utils\",\r\n    \"./misc\",\r\n    \"./special-arg-type\"\r\n], function (Buffer, Stats,FileType,FileError, ErrorCodes, FileFlag,ActionType,utils,misc,SpecialArgType) {\r\n\r\n\r\n    const { buffer2ArrayBuffer, arrayBuffer2Buffer, emptyBuffer }  = utils;\r\n    /**\r\n     * @hidden\r\n     */\r\n    class FileDescriptorArgumentConverter {\r\n        constructor() {\r\n            this._fileDescriptors = {};\r\n            this._nextId = 0;\r\n        }\r\n        toRemoteArg(fd, p, flag, cb) {\r\n            const id = this._nextId++;\r\n            let data;\r\n            let stat;\r\n            this._fileDescriptors[id] = fd;\r\n            // Extract needed information asynchronously.\r\n            fd.stat((err, stats) => {\r\n                if (err) {\r\n                    cb(err);\r\n                }\r\n                else {\r\n                    stat = misc.bufferToTransferrableObject(stats.toBuffer());\r\n                    // If it's a readable flag, we need to grab contents.\r\n                    if (flag.isReadable()) {\r\n                        fd.read(Buffer.alloc(stats.size), 0, stats.size, 0, (err, bytesRead, buff) => {\r\n                            if (err) {\r\n                                cb(err);\r\n                            }\r\n                            else {\r\n                                data = misc.bufferToTransferrableObject(buff);\r\n                                cb(null, {\r\n                                    type: SpecialArgType.FD,\r\n                                    id: id,\r\n                                    data: data,\r\n                                    stat: stat,\r\n                                    path: p,\r\n                                    flag: flag.getFlagString()\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n                    else {\r\n                        // File is not readable, which means writing to it will append or\r\n                        // truncate/replace existing contents. Return an empty arraybuffer.\r\n                        cb(null, {\r\n                            type: SpecialArgType.FD,\r\n                            id: id,\r\n                            data: new ArrayBuffer(0),\r\n                            stat: stat,\r\n                            path: p,\r\n                            flag: flag.getFlagString()\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        applyFdAPIRequest(request, cb) {\r\n            const fdArg = request.args[0];\r\n            this._applyFdChanges(fdArg, (err, fd) => {\r\n                if (err) {\r\n                    cb(err);\r\n                }\r\n                else {\r\n                    // Apply method on now-changed file descriptor.\r\n                    fd[request.method]((e) => {\r\n                        if (request.method === 'close') {\r\n                            delete this._fileDescriptors[fdArg.id];\r\n                        }\r\n                        cb(e);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        _applyFdChanges(remoteFd, cb) {\r\n            const fd = this._fileDescriptors[remoteFd.id], data = transferrableObjectToBuffer(remoteFd.data), remoteStats = Stats.fromBuffer(transferrableObjectToBuffer(remoteFd.stat));\r\n            // Write data if the file is writable.\r\n            const flag = FileFlag.getFileFlag(remoteFd.flag);\r\n            if (flag.isWriteable()) {\r\n                // Appendable: Write to end of file.\r\n                // Writeable: Replace entire contents of file.\r\n                fd.write(data, 0, data.length, flag.isAppendable() ? fd.getPos() : 0, (e) => {\r\n                    function applyStatChanges() {\r\n                        // Check if mode changed.\r\n                        fd.stat((e, stats) => {\r\n                            if (e) {\r\n                                cb(e);\r\n                            }\r\n                            else {\r\n                                if (stats.mode !== remoteStats.mode) {\r\n                                    fd.chmod(remoteStats.mode, (e) => {\r\n                                        cb(e, fd);\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    cb(e, fd);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                    if (e) {\r\n                        cb(e);\r\n                    }\r\n                    else {\r\n                        // If writeable & not appendable, we need to ensure file contents are\r\n                        // identical to those from the remote FD. Thus, we truncate to the\r\n                        // length of the remote file.\r\n                        if (!flag.isAppendable()) {\r\n                            fd.truncate(data.length, () => {\r\n                                applyStatChanges();\r\n                            });\r\n                        }\r\n                        else {\r\n                            applyStatChanges();\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                cb(null, fd);\r\n            }\r\n        }\r\n    }\r\n\r\n    return FileDescriptorArgumentConverter;\r\n});"]}