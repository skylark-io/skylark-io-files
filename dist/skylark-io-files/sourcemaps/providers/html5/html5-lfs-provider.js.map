{"version":3,"sources":["providers/html5/html5-lfs-provider.js"],"names":["define","async","paths","files","registry","PreloadFile","BaseProvider","ErrorCodes","FileError","ActionType","Stats","FileType","utils","Html5LfsFile","asyncEach","each","arrayBuffer2Buffer","_getFS","window","webkitRequestProvider","requestProvider","convertError","err","p","expectedDir","name","EEXIST","ENOSPC","ENOENT","EACCES","EPERM","ENOTDIR","EISDIR","EINVAL","Html5LfsProvider","constructor","size","type","PERSISTENT","super","this","Create","opts","cb","fs","_allocate","e","isAvailable","getName","Name","isReadOnly","supportsSymlinks","supportsProps","supportsSynch","empty","mainCb","_readdir","entries","entry","succ","error","fullPath","isDirectory","removeRecursively","remove","rename","oldPath","newPath","let","semaphore","successCount","root","currentPath","success","dirname","getDirectory","basename","file","moveTo","parentDir","unlink","getFile","stat","path","isLstat","create","loadAsDir","DIRECTORY","failedToLoad","FILE","open","flags","mode","isExclusive","pathNotExistsAction","CREATE_FILE","exclusive","reader","FileReader","onloadend","bfsFile","_makeFile","result","onerror","readAsArrayBuffer","_remove","rmdir","readdir","length","ENOTEMPTY","mkdir","rv","push","flag","data","ArrayBuffer","stats","buffer","dirEntry","createReader","readEntries","results","concat","Array","prototype","slice","call","_requestQuota","granted","errorCallback","navigator","webkitPersistentStorage","requestQuota","TEMPORARY","webkitTemporaryStorage","TypeError","webkitStorageInfo","isFile","Options","optional","description","add"],"mappings":"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","file":"../../../providers/html5/html5-lfs-provider.js","sourcesContent":["define([\r\n    \"skylark-langx-async\",\r\n    \"skylark-langx-paths\",\r\n    \"../../files\",\r\n    \"../registry\",\r\n    '../../preload-file',\r\n    \"../base-provider\",\r\n    '../../error-codes',\r\n    '../../file-error',\r\n    '../../action-type',\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../../utils',\r\n    \"./html5-lfs-file\"\r\n], function (async,paths, files,registry, PreloadFile, BaseProvider, ErrorCodes, FileError,ActionType, Stats,FileType, utils,Html5LfsFile) {\r\n    'use strict';\r\n\r\n    const asyncEach = async.each;\r\n\r\n    const { buffer2ArrayBuffer, arrayBuffer2Buffer } = utils;\r\n\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    function isDirectoryEntry(entry) {\r\n        return entry.isDirectory;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    const _getFS = window.webkitRequestProvider || window.requestProvider || null;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    function _requestQuota(type, size, success, errorCallback) {\r\n        // We cast navigator and window to '<any>' because everything here is\r\n        // nonstandard functionality, despite the fact that Chrome has the only\r\n        // implementation of the HTML5FS and is likely driving the standardization\r\n        // process. Thus, these objects defined off of navigator and window are not\r\n        // present in the DefinitelyTyped TypeScript typings for Provider.\r\n        if (typeof navigator['webkitPersistentStorage'] !== 'undefined') {\r\n            switch (type) {\r\n                case window.PERSISTENT:\r\n                    navigator.webkitPersistentStorage.requestQuota(size, success, errorCallback);\r\n                    break;\r\n                case window.TEMPORARY:\r\n                    navigator.webkitTemporaryStorage.requestQuota(size, success, errorCallback);\r\n                    break;\r\n                default:\r\n                    errorCallback(new TypeError(`Invalid storage type: ${type}`));\r\n                    break;\r\n            }\r\n        }\r\n        else {\r\n            window.webkitStorageInfo.requestQuota(type, size, success, errorCallback);\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function _toArray(list) {\r\n        return Array.prototype.slice.call(list || [], 0);\r\n    }\r\n    /**\r\n     * Converts the given DOMError into an appropriate FileError.\r\n     * @url https://developer.mozilla.org/en-US/docs/Web/API/DOMError\r\n     * @hidden\r\n     */\r\n    function convertError(err, p, expectedDir) {\r\n        switch (err.name) {\r\n            /* The user agent failed to create a file or directory due to the existence of a file or\r\n                directory with the same path.  */\r\n            case \"PathExistsError\":\r\n                return FileError.EEXIST(p);\r\n            /* The operation failed because it would cause the application to exceed its storage quota.  */\r\n            case 'QuotaExceededError':\r\n                return FileError.FileError(ErrorCodes.ENOSPC, p);\r\n            /*  A required file or directory could not be found at the time an operation was processed.   */\r\n            case 'NotFoundError':\r\n                return FileError.ENOENT(p);\r\n            /* This is a security error code to be used in situations not covered by any other error codes.\r\n                - A required file was unsafe for access within a Web application\r\n                - Too many calls are being made on filesystem resources */\r\n            case 'SecurityError':\r\n                return FileError.FileError(ErrorCodes.EACCES, p);\r\n            /* The modification requested was illegal. Examples of invalid modifications include moving a\r\n                directory into its own child, moving a file into its parent directory without changing its name,\r\n                or copying a directory to a path occupied by a file.  */\r\n            case 'InvalidModificationError':\r\n                return FileError.FileError(ErrorCodes.EPERM, p);\r\n            /* The user has attempted to look up a file or directory, but the Entry found is of the wrong type\r\n                [e.g. is a DirectoryEntry when the user requested a FileEntry].  */\r\n            case 'TypeMismatchError':\r\n                return FileError.FileError(expectedDir ? ErrorCodes.ENOTDIR : ErrorCodes.EISDIR, p);\r\n            /* A path or URL supplied to the API was malformed.  */\r\n            case \"EncodingError\":\r\n            /* An operation depended on state cached in an interface object, but that state that has changed\r\n                since it was read from disk.  */\r\n            case \"InvalidStateError\":\r\n            /* The user attempted to write to a file or directory which could not be modified due to the state\r\n                of the underlying filesystem.  */\r\n            case \"NoModificationAllowedError\":\r\n            default:\r\n                return FileError.FileError(ErrorCodes.EINVAL, p);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A read-write filesystem backed by the HTML5 Provider API.\r\n     *\r\n     * As the HTML5 Provider is only implemented in Blink, this interface is\r\n     * only available in Chrome.\r\n     */\r\n    class Html5LfsProvider extends BaseProvider {\r\n\r\n        /**\r\n         * @param size storage quota to request, in megabytes. Allocated value may be less.\r\n         * @param type window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT.\r\n         */\r\n        constructor(size = 5, type = window.PERSISTENT) {\r\n            super();\r\n            // Convert MB to bytes.\r\n            this.size = 1024 * 1024 * size;\r\n            this.type = type;\r\n        }\r\n\r\n        /**\r\n         * Creates an Html5LfsProvider instance with the given options.\r\n         */\r\n        static Create(opts, cb) {\r\n            const fs = new Html5LfsProvider(opts.size, opts.type);\r\n            fs._allocate((e) => e ? cb(e) : cb(null, fs));\r\n        }\r\n\r\n        static isAvailable() {\r\n            return !!_getFS;\r\n        }\r\n\r\n        getName() {\r\n            return Html5LfsProvider.Name;\r\n        }\r\n\r\n        isReadOnly() {\r\n            return false;\r\n        }\r\n\r\n        supportsSymlinks() {\r\n            return false;\r\n        }\r\n\r\n        supportsProps() {\r\n            return false;\r\n        }\r\n\r\n        supportsSynch() {\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Deletes everything in the FS. Used for testing.\r\n         * Karma clears the storage after you quit it but not between runs of the test\r\n         * suite, and the tests expect an empty FS every time.\r\n         */\r\n        empty(mainCb) {\r\n            // Get a list of all entries in the root directory to delete them\r\n            this._readdir('/', (err, entries) => {\r\n                if (err) {\r\n                    mainCb(err);\r\n                }\r\n                else {\r\n                    // Called when every entry has been operated on\r\n                    const finished = (er) => {\r\n                        if (err) {\r\n                            mainCb(err);\r\n                        }\r\n                        else {\r\n                            mainCb();\r\n                        }\r\n                    };\r\n                    // Removes files and recursively removes directories\r\n                    const deleteEntry = (entry, cb) => {\r\n                        const succ = () => {\r\n                            cb();\r\n                        };\r\n                        const error = (err) => {\r\n                            cb(convertError(err, entry.fullPath, !entry.isDirectory));\r\n                        };\r\n                        if (isDirectoryEntry(entry)) {\r\n                            entry.removeRecursively(succ, error);\r\n                        }\r\n                        else {\r\n                            entry.remove(succ, error);\r\n                        }\r\n                    };\r\n                    // Loop through the entries and remove them, then call the callback\r\n                    // when they're all finished.\r\n                    asyncEach(entries, deleteEntry, finished);\r\n                }\r\n            });\r\n        }\r\n\r\n        rename(oldPath, newPath, cb) {\r\n            let semaphore = 2;\r\n            let successCount = 0;\r\n            const root = this.fs.root;\r\n            let currentPath = oldPath;\r\n            const error = (err) => {\r\n                if (--semaphore <= 0) {\r\n                    cb(convertError(err, currentPath, false));\r\n                }\r\n            };\r\n            const success = (file) => {\r\n                if (++successCount === 2) {\r\n                    return cb(new FileError(ErrorCodes.EINVAL, \"Something was identified as both a file and a directory. This should never happen.\"));\r\n                }\r\n                // SPECIAL CASE: If newPath === oldPath, and the path exists, then\r\n                // this operation trivially succeeds.\r\n                if (oldPath === newPath) {\r\n                    return cb();\r\n                }\r\n                // Get the new parent directory.\r\n                currentPath = paths.dirname(newPath);\r\n                root.getDirectory(currentPath, {}, (parentDir) => {\r\n                    currentPath = paths.basename(newPath);\r\n                    file.moveTo(parentDir, currentPath, (entry) => { cb(); }, (err) => {\r\n                        // SPECIAL CASE: If oldPath is a directory, and newPath is a\r\n                        // file, rename should delete the file and perform the move.\r\n                        if (file.isDirectory) {\r\n                            currentPath = newPath;\r\n                            // Unlink only works on files. Try to delete newPath.\r\n                            this.unlink(newPath, (e) => {\r\n                                if (e) {\r\n                                    // newPath is probably a directory.\r\n                                    error(err);\r\n                                }\r\n                                else {\r\n                                    // Recur, now that newPath doesn't exist.\r\n                                    this.rename(oldPath, newPath, cb);\r\n                                }\r\n                            });\r\n                        }\r\n                        else {\r\n                            error(err);\r\n                        }\r\n                    });\r\n                }, error);\r\n            };\r\n            // We don't know if oldPath is a *file* or a *directory*, and there's no\r\n            // way to stat items. So launch both requests, see which one succeeds.\r\n            root.getFile(oldPath, {}, success, error);\r\n            root.getDirectory(oldPath, {}, success, error);\r\n        }\r\n\r\n        stat(path, isLstat, cb) {\r\n            // Throw an error if the entry doesn't exist, because then there's nothing\r\n            // to stat.\r\n            const opts = {\r\n                create: false\r\n            };\r\n            // Called when the path has been successfully loaded as a file.\r\n            const loadAsFile = (entry) => {\r\n                const fileFromEntry = (file) => {\r\n                    const stat = new Stats(FileType.FILE, file.size);\r\n                    cb(null, stat);\r\n                };\r\n                entry.file(fileFromEntry, failedToLoad);\r\n            };\r\n            // Called when the path has been successfully loaded as a directory.\r\n            const loadAsDir = (dir) => {\r\n                // Directory entry size can't be determined from the HTML5 FS API, and is\r\n                // implementation-dependant anyway, so a dummy value is used.\r\n                const size = 4096;\r\n                const stat = new Stats(FileType.DIRECTORY, size);\r\n                cb(null, stat);\r\n            };\r\n            // Called when the path couldn't be opened as a directory or a file.\r\n            const failedToLoad = (err) => {\r\n                cb(convertError(err, path, false /* Unknown / irrelevant */));\r\n            };\r\n            // Called when the path couldn't be opened as a file, but might still be a\r\n            // directory.\r\n            const failedToLoadAsFile = () => {\r\n                this.fs.root.getDirectory(path, opts, loadAsDir, failedToLoad);\r\n            };\r\n            // No method currently exists to determine whether a path refers to a\r\n            // directory or a file, so this implementation tries both and uses the first\r\n            // one that succeeds.\r\n            this.fs.root.getFile(path, opts, loadAsFile, failedToLoadAsFile);\r\n        }\r\n        open(p, flags, mode, cb) {\r\n            // XXX: err is a DOMError\r\n            const error = (err) => {\r\n                if (err.name === 'InvalidModificationError' && flags.isExclusive()) {\r\n                    cb(FileError.EEXIST(p));\r\n                }\r\n                else {\r\n                    cb(convertError(err, p, false));\r\n                }\r\n            };\r\n            this.fs.root.getFile(p, {\r\n                create: flags.pathNotExistsAction() === ActionType.CREATE_FILE,\r\n                exclusive: flags.isExclusive()\r\n            }, (entry) => {\r\n                // Try to fetch corresponding file.\r\n                entry.file((file) => {\r\n                    const reader = new FileReader();\r\n                    reader.onloadend = (event) => {\r\n                        const bfsFile = this._makeFile(p, entry, flags, file, reader.result);\r\n                        cb(null, bfsFile);\r\n                    };\r\n                    reader.onerror = (ev) => {\r\n                        error(reader.error);\r\n                    };\r\n                    reader.readAsArrayBuffer(file);\r\n                }, error);\r\n            }, error);\r\n        }\r\n        unlink(path, cb) {\r\n            this._remove(path, cb, true);\r\n        }\r\n        rmdir(path, cb) {\r\n            // Check if directory is non-empty, first.\r\n            this.readdir(path, (e, files) => {\r\n                if (e) {\r\n                    cb(e);\r\n                }\r\n                else if (files.length > 0) {\r\n                    cb(FileError.ENOTEMPTY(path));\r\n                }\r\n                else {\r\n                    this._remove(path, cb, false);\r\n                }\r\n            });\r\n        }\r\n        mkdir(path, mode, cb) {\r\n            // Create the directory, but throw an error if it already exists, as per\r\n            // mkdir(1)\r\n            const opts = {\r\n                create: true,\r\n                exclusive: true\r\n            };\r\n            const success = (dir) => {\r\n                cb();\r\n            };\r\n            const error = (err) => {\r\n                cb(convertError(err, path, true));\r\n            };\r\n            this.fs.root.getDirectory(path, opts, success, error);\r\n        }\r\n        /**\r\n         * Map _readdir's list of `FileEntry`s to their names and return that.\r\n         */\r\n        readdir(path, cb) {\r\n            this._readdir(path, (e, entries) => {\r\n                if (entries) {\r\n                    const rv = [];\r\n                    for (const entry of entries) {\r\n                        rv.push(entry.name);\r\n                    }\r\n                    cb(null, rv);\r\n                }\r\n                else {\r\n                    return cb(e);\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Returns a BrowserFS object representing a File.\r\n         */\r\n        _makeFile(path, entry, flag, stat, data = new ArrayBuffer(0)) {\r\n            const stats = new Stats(FileType.FILE, stat.size);\r\n            const buffer = arrayBuffer2Buffer(data);\r\n            return new Html5LfsFile(this, entry, path, flag, stats, buffer);\r\n        }\r\n        /**\r\n         * Returns an array of `FileEntry`s. Used internally by empty and readdir.\r\n         */\r\n        _readdir(path, cb) {\r\n            const error = (err) => {\r\n                cb(convertError(err, path, true));\r\n            };\r\n            // Grab the requested directory.\r\n            this.fs.root.getDirectory(path, { create: false }, (dirEntry) => {\r\n                const reader = dirEntry.createReader();\r\n                let entries = [];\r\n                // Call the reader.readEntries() until no more results are returned.\r\n                const readEntries = () => {\r\n                    reader.readEntries(((results) => {\r\n                        if (results.length) {\r\n                            entries = entries.concat(_toArray(results));\r\n                            readEntries();\r\n                        }\r\n                        else {\r\n                            cb(null, entries);\r\n                        }\r\n                    }), error);\r\n                };\r\n                readEntries();\r\n            }, error);\r\n        }\r\n        \r\n        /**\r\n         * Requests a storage quota from the browser to back this FS.\r\n         */\r\n        _allocate(cb) {\r\n            const success = (fs) => {\r\n                this.fs = fs;\r\n                cb();\r\n            };\r\n            const error = (err) => {\r\n                cb(convertError(err, \"/\", true));\r\n            };\r\n            if (this.type === window.PERSISTENT) {\r\n                _requestQuota(this.type, this.size, (granted) => {\r\n                    _getFS(this.type, granted, success, error);\r\n                }, error);\r\n            }\r\n            else {\r\n                _getFS(this.type, this.size, success, error);\r\n            }\r\n        }\r\n        /**\r\n         * Delete a file or directory from the file system\r\n         * isFile should reflect which call was made to remove the it (`unlink` or\r\n         * `rmdir`). If this doesn't match what's actually at `path`, an error will be\r\n         * returned\r\n         */\r\n        _remove(path, cb, isFile) {\r\n            const success = (entry) => {\r\n                const succ = () => {\r\n                    cb();\r\n                };\r\n                const err = (err) => {\r\n                    cb(convertError(err, path, !isFile));\r\n                };\r\n                entry.remove(succ, err);\r\n            };\r\n            const error = (err) => {\r\n                cb(convertError(err, path, !isFile));\r\n            };\r\n            // Deleting the entry, so don't create it\r\n            const opts = {\r\n                create: false\r\n            };\r\n            if (isFile) {\r\n                this.fs.root.getFile(path, opts, success, error);\r\n            }\r\n            else {\r\n                this.fs.root.getDirectory(path, opts, success, error);\r\n            }\r\n        }\r\n    }\r\n    Html5LfsProvider.Name = \"Html5LfsProvider\";\r\n    Html5LfsProvider.Options = {\r\n        size: {\r\n            type: \"number\",\r\n            optional: true,\r\n            description: \"Storage quota to request, in megabytes. Allocated value may be less. Defaults to 5.\"\r\n        },\r\n        type: {\r\n            type: \"number\",\r\n            optional: true,\r\n            description: \"window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT.\"\r\n        }\r\n    };\r\n\r\n    Html5LfsProvider.Html5LfsFile = Html5LfsFile;\r\n\r\n    registry.add(\"html5Lfs\",Html5LfsProvider);\r\n\r\n\r\n    return Html5LfsProvider;\r\n});"]}