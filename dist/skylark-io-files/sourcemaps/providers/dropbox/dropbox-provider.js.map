{"version":3,"sources":["providers/dropbox/dropbox-provider.js"],"names":["define","setImmediate","Buffer","paths","files","registry","BaseProvider","Stats","FileType","FileError","ErrorCodes","utils","DropboxFile","arrayBuffer2Buffer","buffer2ArrayBuffer","dirname","FixPath","p","ExtractTheFuckingError","e","obj2","obj","error","reason","JSON","parse","GetErrorMessage","err","user_message","text","error_summary","Error","stringify","LookupErrorToError","msg","EBADF","ENOENT","EISDIR","ENOTDIR","EPERM","EIO","WriteErrorToError","ENOSPC","FilesDeleteWrapped","client","cb","arg","path","filesDeleteV2","then","catch","path_lookup","path_write","setTimeout","Math","random","DropboxProvider","constructor","super","this","_client","Create","opts","isAvailable","Dropbox","getName","Name","isReadOnly","supportsSymlinks","supportsProps","supportsSynch","empty","mainCb","readdir","next","length","shift","rename","oldPath","newPath","stat","stats","relocationArg","from_path","to_path","filesMoveV2","from_lookup","from_write","to","isDirectory","unlink","isLstat","DIRECTORY","filesGetMetadata","ref","FILE","size","openFile","flags","downloadArg","filesDownload","b","res","fileBlob","fr","FileReader","onload","ab","result","byteLength","readAsArrayBuffer","createFile","mode","fileData","alloc","commitInfo","contents","Blob","type","filesUpload","rmdir","ENOTEMPTY","mkdir","parent","filesCreateFolderV2","filesListFolder","ContinueReadingDir","previousEntries","newEntries","entries","map","path_display","filter","concat","has_more","cursor","filesListFolderContinue","ProcessListFolderError","_syncFile","d",".tag","Options","description","add","providers"],"mappings":"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","file":"../../../providers/dropbox/dropbox-provider.js","sourcesContent":["define([\r\n    \"skylark-langx-funcs/defer\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"../../files\",\r\n    \"../registry\",\r\n    \"../base-provider\",\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    '../../utils',\r\n    './dropbox-file'\r\n], function (setImmediate,Buffer,paths,files, registry,BaseProvider, Stats,FileType,FileError, ErrorCodes, utils,DropboxFile) {\r\n    'use strict';\r\n\r\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer } =  utils;\r\n///    const { Dropbox } =  dropbox_bridge;\r\n    const { dirname } =  paths;\r\n\r\n\r\n    /**\r\n     * Dropbox paths do not begin with a /, they just begin with a folder at the root node.\r\n     * Here, we strip the `/`.\r\n     * @param p An absolute path\r\n     */\r\n    function FixPath(p) {\r\n        if (p === '/') {\r\n            return '';\r\n        }\r\n        else {\r\n            return p;\r\n        }\r\n    }\r\n    /**\r\n     * HACK: Dropbox errors are FUBAR'd sometimes.\r\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\r\n     * @param e\r\n     */\r\n    function ExtractTheFuckingError(e) {\r\n        const obj = e.error;\r\n        if (obj['.tag']) {\r\n            // Everything is OK.\r\n            return obj;\r\n        }\r\n        else if (obj['error']) {\r\n            // Terrible nested object bug.\r\n            const obj2 = obj.error;\r\n            if (obj2['.tag']) {\r\n                return obj2;\r\n            }\r\n            else if (obj2['reason'] && obj2['reason']['.tag']) {\r\n                return obj2.reason;\r\n            }\r\n            else {\r\n                return obj2;\r\n            }\r\n        }\r\n        else if (typeof (obj) === 'string') {\r\n            // Might be a fucking JSON object error.\r\n            try {\r\n                const obj2 = JSON.parse(obj);\r\n                if (obj2['error'] && obj2['error']['reason'] && obj2['error']['reason']['.tag']) {\r\n                    return obj2.error.reason;\r\n                }\r\n            }\r\n            catch (e) {\r\n                // Nope. Give up.\r\n            }\r\n        }\r\n        return obj;\r\n    }\r\n    /**\r\n     * Returns a user-facing error message given an error.\r\n     *\r\n     * HACK: Dropbox error messages sometimes lack a `user_message` field.\r\n     * Sometimes, they are even strings. Ugh.\r\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\r\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/145\r\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/144\r\n     * @param err An error.\r\n     */\r\n    function GetErrorMessage(err) {\r\n        if (err['user_message']) {\r\n            return err.user_message.text;\r\n        }\r\n        else if (err['error_summary']) {\r\n            return err.error_summary;\r\n        }\r\n        else if (typeof (err.error) === \"string\") {\r\n            return err.error;\r\n        }\r\n        else if (typeof (err.error) === \"object\") {\r\n            // DROPBOX BUG: Sometimes, error is a nested error.\r\n            return GetErrorMessage(err.error);\r\n        }\r\n        else {\r\n            throw new Error(`Dropbox's servers gave us a garbage error message: ${JSON.stringify(err)}`);\r\n        }\r\n    }\r\n    function LookupErrorToError(err, p, msg) {\r\n        switch (err['.tag']) {\r\n            case 'malformed_path':\r\n                return new FileError(ErrorCodes.EBADF, msg, p);\r\n            case 'not_found':\r\n                return FileError.ENOENT(p);\r\n            case 'not_file':\r\n                return FileError.EISDIR(p);\r\n            case 'not_folder':\r\n                return FileError.ENOTDIR(p);\r\n            case 'restricted_content':\r\n                return FileError.EPERM(p);\r\n            case 'other':\r\n            default:\r\n                return new FileError(ErrorCodes.EIO, msg, p);\r\n        }\r\n    }\r\n    function WriteErrorToError(err, p, msg) {\r\n        switch (err['.tag']) {\r\n            case 'malformed_path':\r\n            case 'disallowed_name':\r\n                return new FileError(ErrorCodes.EBADF, msg, p);\r\n            case 'conflict':\r\n            case 'no_write_permission':\r\n            case 'team_folder':\r\n                return FileError.EPERM(p);\r\n            case 'insufficient_space':\r\n                return new FileError(ErrorCodes.ENOSPC, msg);\r\n            case 'other':\r\n            default:\r\n                return new FileError(ErrorCodes.EIO, msg, p);\r\n        }\r\n    }\r\n    function FilesDeleteWrapped(client, p, cb) {\r\n        const arg = {\r\n            path: FixPath(p)\r\n        };\r\n        client.filesDeleteV2(arg)\r\n            .then(() => {\r\n            cb();\r\n        }).catch((e) => {\r\n            const err = ExtractTheFuckingError(e);\r\n            switch (err['.tag']) {\r\n                case 'path_lookup':\r\n                    cb(LookupErrorToError(err.path_lookup, p, GetErrorMessage(e)));\r\n                    break;\r\n                case 'path_write':\r\n                    cb(WriteErrorToError(err.path_write, p, GetErrorMessage(e)));\r\n                    break;\r\n                case 'too_many_write_operations':\r\n                    setTimeout(() => FilesDeleteWrapped(client, p, cb), 500 + (300 * (Math.random())));\r\n                    break;\r\n                case 'other':\r\n                default:\r\n                    cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * A read/write file system backed by Dropbox cloud storage.\r\n     *\r\n     * Uses the Dropbox V2 API, and the 2.x JS SDK.\r\n     */\r\n    class DropboxProvider extends BaseProvider {\r\n        constructor(client) {\r\n            super();\r\n            this._client = client;\r\n        }\r\n        /**\r\n         * Creates a new DropboxProvider instance with the given options.\r\n         * Must be given an *authenticated* Dropbox client from 2.x JS SDK.\r\n         */\r\n        static Create(opts, cb) {\r\n            cb(null, new DropboxProvider(opts.client));\r\n        }\r\n        static isAvailable() {\r\n            // Checks if the Dropbox library is loaded.\r\n            return typeof Dropbox !== 'undefined';\r\n        }\r\n        getName() {\r\n            return DropboxProvider.Name;\r\n        }\r\n        isReadOnly() {\r\n            return false;\r\n        }\r\n        // Dropbox doesn't support symlinks, properties, or synchronous calls\r\n        // TODO: does it???\r\n        supportsSymlinks() {\r\n            return false;\r\n        }\r\n        supportsProps() {\r\n            return false;\r\n        }\r\n        supportsSynch() {\r\n            return false;\r\n        }\r\n        /**\r\n         * Deletes *everything* in the file system. Mainly intended for unit testing!\r\n         * @param mainCb Called when operation completes.\r\n         */\r\n        empty(mainCb) {\r\n            this.readdir('/', (e, paths) => {\r\n                if (paths) {\r\n                    const next = (e) => {\r\n                        if (paths.length === 0) {\r\n                            mainCb();\r\n                        }\r\n                        else {\r\n                            FilesDeleteWrapped(this._client, paths.shift(), next);\r\n                        }\r\n                    };\r\n                    next();\r\n                }\r\n                else {\r\n                    mainCb(e);\r\n                }\r\n            });\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            // Dropbox doesn't let you rename things over existing things, but POSIX does.\r\n            // So, we need to see if newPath exists...\r\n            this.stat(newPath, false, (e, stats) => {\r\n                const rename = () => {\r\n                    const relocationArg = {\r\n                        from_path: FixPath(oldPath),\r\n                        to_path: FixPath(newPath)\r\n                    };\r\n                    this._client.filesMoveV2(relocationArg)\r\n                        .then(() => cb())\r\n                        .catch(function (e) {\r\n                        const err = ExtractTheFuckingError(e);\r\n                        switch (err['.tag']) {\r\n                            case 'from_lookup':\r\n                                cb(LookupErrorToError(err.from_lookup, oldPath, GetErrorMessage(e)));\r\n                                break;\r\n                            case 'from_write':\r\n                                cb(WriteErrorToError(err.from_write, oldPath, GetErrorMessage(e)));\r\n                                break;\r\n                            case 'to':\r\n                                cb(WriteErrorToError(err.to, newPath, GetErrorMessage(e)));\r\n                                break;\r\n                            case 'cant_copy_shared_folder':\r\n                            case 'cant_nest_shared_folder':\r\n                                cb(new FileError(ErrorCodes.EPERM, GetErrorMessage(e), oldPath));\r\n                                break;\r\n                            case 'cant_move_folder_into_itself':\r\n                            case 'duplicated_or_nested_paths':\r\n                                cb(new FileError(ErrorCodes.EBADF, GetErrorMessage(e), oldPath));\r\n                                break;\r\n                            case 'too_many_files':\r\n                                cb(new FileError(ErrorCodes.ENOSPC, GetErrorMessage(e), oldPath));\r\n                                break;\r\n                            case 'other':\r\n                            default:\r\n                                cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), oldPath));\r\n                                break;\r\n                        }\r\n                    });\r\n                };\r\n                if (e) {\r\n                    // Doesn't exist. Proceed!\r\n                    rename();\r\n                }\r\n                else if (oldPath === newPath) {\r\n                    // NOP if the path exists. Error if it doesn't exist.\r\n                    if (e) {\r\n                        cb(FileError.ENOENT(newPath));\r\n                    }\r\n                    else {\r\n                        cb();\r\n                    }\r\n                }\r\n                else if (stats && stats.isDirectory()) {\r\n                    // Exists, is a directory. Cannot rename over an existing directory.\r\n                    cb(FileError.EISDIR(newPath));\r\n                }\r\n                else {\r\n                    // Exists, is a file, and differs from oldPath. Delete and rename.\r\n                    this.unlink(newPath, (e) => {\r\n                        if (e) {\r\n                            cb(e);\r\n                        }\r\n                        else {\r\n                            rename();\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        stat(path, isLstat, cb) {\r\n            if (path === '/') {\r\n                // Dropbox doesn't support querying the root directory.\r\n                setImmediate(function () {\r\n                    cb(null, new Stats(FileType.DIRECTORY, 4096));\r\n                });\r\n                return;\r\n            }\r\n            const arg = {\r\n                path: FixPath(path)\r\n            };\r\n            this._client.filesGetMetadata(arg).then((ref) => {\r\n                switch (ref['.tag']) {\r\n                    case 'file':\r\n                        const fileMetadata = ref;\r\n                        // TODO: Parse time fields.\r\n                        cb(null, new Stats(FileType.FILE, fileMetadata.size));\r\n                        break;\r\n                    case 'folder':\r\n                        cb(null, new Stats(FileType.DIRECTORY, 4096));\r\n                        break;\r\n                    case 'deleted':\r\n                        cb(FileError.ENOENT(path));\r\n                        break;\r\n                    default:\r\n                        // Unknown.\r\n                        break;\r\n                }\r\n            }).catch((e) => {\r\n                const err = ExtractTheFuckingError(e);\r\n                switch (err['.tag']) {\r\n                    case 'path':\r\n                        cb(LookupErrorToError(err.path, path, GetErrorMessage(e)));\r\n                        break;\r\n                    default:\r\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\r\n                        break;\r\n                }\r\n            });\r\n        }\r\n        openFile(path, flags, cb) {\r\n            const downloadArg = {\r\n                path: FixPath(path)\r\n            };\r\n            this._client.filesDownload(downloadArg).then((res) => {\r\n                const b = res.fileBlob;\r\n                const fr = new FileReader();\r\n                fr.onload = () => {\r\n                    const ab = fr.result;\r\n                    cb(null, new DropboxFile(this, path, flags, new Stats(FileType.FILE, ab.byteLength), arrayBuffer2Buffer(ab)));\r\n                };\r\n                fr.readAsArrayBuffer(b);\r\n            }).catch((e) => {\r\n                const err = ExtractTheFuckingError(e);\r\n                switch (err['.tag']) {\r\n                    case 'path':\r\n                        const dpError = err;\r\n                        cb(LookupErrorToError(dpError.path, path, GetErrorMessage(e)));\r\n                        break;\r\n                    case 'other':\r\n                    default:\r\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\r\n                        break;\r\n                }\r\n            });\r\n        }\r\n        createFile(p, flags, mode, cb) {\r\n            const fileData = Buffer.alloc(0);\r\n            const blob = new Blob([buffer2ArrayBuffer(fileData)], { type: \"octet/stream\" });\r\n            const commitInfo = {\r\n                contents: blob,\r\n                path: FixPath(p)\r\n            };\r\n            this._client.filesUpload(commitInfo).then((metadata) => {\r\n                cb(null, new DropboxFile(this, p, flags, new Stats(FileType.FILE, 0), fileData));\r\n            }).catch((e) => {\r\n                const err = ExtractTheFuckingError(e);\r\n                // HACK: Casting to 'any' since tag can be 'too_many_write_operations'.\r\n                switch (err['.tag']) {\r\n                    case 'path':\r\n                        const upError = err;\r\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\r\n                        break;\r\n                    case 'too_many_write_operations':\r\n                        // Retry in (500, 800) ms.\r\n                        setTimeout(() => this.createFile(p, flags, mode, cb), 500 + (300 * (Math.random())));\r\n                        break;\r\n                    case 'other':\r\n                    default:\r\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\r\n                        break;\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Delete a file\r\n         */\r\n        unlink(path, cb) {\r\n            // Must be a file. Check first.\r\n            this.stat(path, false, (e, stat) => {\r\n                if (stat) {\r\n                    if (stat.isDirectory()) {\r\n                        cb(FileError.EISDIR(path));\r\n                    }\r\n                    else {\r\n                        FilesDeleteWrapped(this._client, path, cb);\r\n                    }\r\n                }\r\n                else {\r\n                    cb(e);\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Delete a directory\r\n         */\r\n        rmdir(path, cb) {\r\n            this.readdir(path, (e, paths) => {\r\n                if (paths) {\r\n                    if (paths.length > 0) {\r\n                        cb(FileError.ENOTEMPTY(path));\r\n                    }\r\n                    else {\r\n                        FilesDeleteWrapped(this._client, path, cb);\r\n                    }\r\n                }\r\n                else {\r\n                    cb(e);\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Create a directory\r\n         */\r\n        mkdir(p, mode, cb) {\r\n            // Dropbox's create_folder is recursive. Check if parent exists.\r\n            const parent = dirname(p);\r\n            this.stat(parent, false, (e, stats) => {\r\n                if (e) {\r\n                    cb(e);\r\n                }\r\n                else if (stats && !stats.isDirectory()) {\r\n                    cb(FileError.ENOTDIR(parent));\r\n                }\r\n                else {\r\n                    const arg = {\r\n                        path: FixPath(p)\r\n                    };\r\n                    this._client.filesCreateFolderV2(arg).then(() => cb()).catch((e) => {\r\n                        const err = ExtractTheFuckingError(e);\r\n                        if (err['.tag'] === \"too_many_write_operations\") {\r\n                            // Retry in a bit.\r\n                            setTimeout(() => this.mkdir(p, mode, cb), 500 + (300 * (Math.random())));\r\n                        }\r\n                        else {\r\n                            cb(WriteErrorToError(ExtractTheFuckingError(e).path, p, GetErrorMessage(e)));\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Get the names of the files in a directory\r\n         */\r\n        readdir(path, cb) {\r\n            const arg = {\r\n                path: FixPath(path)\r\n            };\r\n            this._client.filesListFolder(arg).then((res) => {\r\n                ContinueReadingDir(this._client, path, res, [], cb);\r\n            }).catch((e) => {\r\n                ProcessListFolderError(e, path, cb);\r\n            });\r\n        }\r\n        /**\r\n         * (Internal) Syncs file to Dropbox.\r\n         */\r\n        _syncFile(p, d, cb) {\r\n            const blob = new Blob([buffer2ArrayBuffer(d)], { type: \"octet/stream\" });\r\n            const arg = {\r\n                contents: blob,\r\n                path: FixPath(p),\r\n                mode: {\r\n                    '.tag': 'overwrite'\r\n                }\r\n            };\r\n            this._client.filesUpload(arg).then(() => {\r\n                cb();\r\n            }).catch((e) => {\r\n                const err = ExtractTheFuckingError(e);\r\n                switch (err['.tag']) {\r\n                    case 'path':\r\n                        const upError = err;\r\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\r\n                        break;\r\n                    case 'too_many_write_operations':\r\n                        setTimeout(() => this._syncFile(p, d, cb), 500 + (300 * (Math.random())));\r\n                        break;\r\n                    case 'other':\r\n                    default:\r\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\r\n                        break;\r\n                }\r\n            });\r\n        }\r\n    }\r\n    DropboxProvider.Name = \"DropboxV2\";\r\n    DropboxProvider.Options = {\r\n        client: {\r\n            type: \"object\",\r\n            description: \"An *authenticated* Dropbox client. Must be from the 2.5.x JS SDK.\"\r\n        }\r\n    };\r\n    function ProcessListFolderError(e, path, cb) {\r\n        const err = ExtractTheFuckingError(e);\r\n        switch (err['.tag']) {\r\n            case 'path':\r\n                const pathError = err;\r\n                cb(LookupErrorToError(pathError.path, path, GetErrorMessage(e)));\r\n                break;\r\n            case 'other':\r\n            default:\r\n                cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\r\n                break;\r\n        }\r\n    }\r\n    function ContinueReadingDir(client, path, res, previousEntries, cb) {\r\n        const newEntries = res.entries.map((e) => e.path_display).filter((p) => !!p);\r\n        const entries = previousEntries.concat(newEntries);\r\n        if (!res.has_more) {\r\n            cb(null, entries);\r\n        }\r\n        else {\r\n            const arg = {\r\n                cursor: res.cursor\r\n            };\r\n            client.filesListFolderContinue(arg).then((res) => {\r\n                ContinueReadingDir(client, path, res, entries, cb);\r\n            }).catch((e) => {\r\n                ProcessListFolderError(e, path, cb);\r\n            });\r\n        }\r\n    }\r\n\r\n    DropboxProvider.DropboxFile = DropboxFile;\r\n\r\n    registry.add(\"dropbox\",DropboxProvider);\r\n\r\n    return  files.providers.DropboxProvider= DropboxProvider;\r\n    \r\n});"]}