{"version":3,"sources":["providers/indexeddb/indexed-db-store.js"],"names":["define","FileError","ErrorCodes","IndexedDBROTransaction","IndexedDBRWTransaction","convertError","e","message","toString","name","ENOENT","ENOSPC","EIO","onErrorHandler","cb","code","preventDefault","undefined","IndexedDBStore","constructor","db","storeName","this","Create","openReq","indexedDB","open","onupgradeneeded","event","target","result","objectStoreNames","contains","deleteObjectStore","createObjectStore","onsuccess","onerror","EACCES","IndexedDBProvider","Name","clear","r","transaction","objectStore","setTimeout","beginTransaction","type","tx","EINVAL"],"mappings":";;;;;;;AAAAA,OAAO,CACH,mBACA,oBACA,8BACA,+BACD,SAAUC,EAAUC,EAAWC,EAAuBC,GACrD,aAQA,SAASC,EAAaC,EAAGC,EAAUD,EAAEE,SAAS,GAC1C,OAAQF,EAAEG,MACN,IAAK,gBACD,OAAO,IAAIR,EAAUC,EAAWQ,OAAQH,CAAO,EACnD,IAAK,qBACD,OAAO,IAAIN,EAAUC,EAAWS,OAAQJ,CAAO,EACnD,QAEI,OAAO,IAAIN,EAAUC,EAAWU,IAAKL,CAAO,CACpD,CACJ,CAOA,SAASM,EAAeC,EAAIC,EAAOb,EAAWU,IAAKL,EAAU,MACzD,OAAO,SAAUD,GAEbA,EAAEU,eAAe,EACjBF,EAAG,IAAIb,EAAUc,EAAkB,OAAZR,EAAmBA,EAAUU,KAAAA,CAAS,CAAC,CAClE,CACJ,CAsDA,aApDMC,EACFC,YAAYC,EAAIC,GACZC,KAAKF,GAAKA,EACVE,KAAKD,UAAYA,CACrB,CACAE,cAAcF,EAAWP,GACrB,IAAMU,EAAUC,UAAUC,KAAKL,EAAW,CAAC,EAC3CG,EAAQG,gBAAkB,KAChBP,EAAKQ,EAAMC,OAAOC,QAGjBC,iBAAiBC,SAASX,CAAS,GACtCD,EAAGa,kBAAkBZ,CAAS,EAElCD,EAAGc,kBAAkBb,CAAS,CAClC,EACAG,EAAQW,UAAY,IAChBrB,EAAG,KAAM,IAAII,EAAeU,EAAMC,OAAOC,OAAQT,CAAS,CAAC,CAC/D,EACAG,EAAQY,QAAUvB,EAAeC,EAAIZ,EAAWmC,MAAM,CAC1D,CACA5B,OACI,OAAO6B,kBAAkBC,KAAO,MAAQjB,KAAKD,SACjD,CACAmB,MAAM1B,GACF,IACI,IAA2G2B,EAAhGnB,KAAKF,GAAGsB,YAAYpB,KAAKD,UAAW,WAAW,EAAoBsB,YAAYrB,KAAKD,SAAS,EAAmBmB,MAAM,EACjIC,EAAEN,UAAY,IAEVS,WAAW9B,EAAI,CAAC,CACpB,EACA2B,EAAEL,QAAUvB,EAAeC,CAAE,CAIjC,CAFA,MAAOR,GACHQ,EAAGT,EAAaC,CAAC,CAAC,CACtB,CACJ,CACAuC,iBAAiBC,EAAO,YACpB,IAAMC,EAAKzB,KAAKF,GAAGsB,YAAYpB,KAAKD,UAAWyB,CAAI,EAAGH,EAAcI,EAAGJ,YAAYrB,KAAKD,SAAS,EACjG,GAAa,cAATyB,EACA,OAAO,IAAI1C,EAAuB2C,EAAIJ,CAAW,EAEhD,GAAa,aAATG,EACL,OAAO,IAAI3C,EAAuB4C,EAAIJ,CAAW,EAGjD,MAAM,IAAI1C,EAAUC,EAAW8C,OAAQ,2BAA2B,CAE1E,CACJ,CAIJ,CAAC","file":"../../../providers/indexeddb/indexed-db-store.js","sourcesContent":["define([\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    \"./indexed-db-ro-transaction\",\r\n    \"./indexed-db-rw-transaction\"\r\n], function (FileError,ErrorCodes,IndexedDBROTransaction,IndexedDBRWTransaction) {\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * Converts a DOMException or a DOMError from an IndexedDB event into a\r\n     * standardized BrowserFS API error.\r\n     * @hidden\r\n     */\r\n    function convertError(e, message = e.toString()) {\r\n        switch (e.name) {\r\n            case \"NotFoundError\":\r\n                return new FileError(ErrorCodes.ENOENT, message);\r\n            case \"QuotaExceededError\":\r\n                return new FileError(ErrorCodes.ENOSPC, message);\r\n            default:\r\n                // The rest do not seem to map cleanly to standard error codes.\r\n                return new FileError(ErrorCodes.EIO, message);\r\n        }\r\n    }\r\n    /**\r\n     * Produces a new onerror handler for IDB. Our errors are always fatal, so we\r\n     * handle them generically: Call the user-supplied callback with a translated\r\n     * version of the error, and let the error bubble up.\r\n     * @hidden\r\n     */\r\n    function onErrorHandler(cb, code = ErrorCodes.EIO, message = null) {\r\n        return function (e) {\r\n            // Prevent the error from canceling the transaction.\r\n            e.preventDefault();\r\n            cb(new FileError(code, message !== null ? message : undefined));\r\n        };\r\n    }\r\n\r\n    class IndexedDBStore {\r\n        constructor(db, storeName) {\r\n            this.db = db;\r\n            this.storeName = storeName;\r\n        }\r\n        static Create(storeName, cb) {\r\n            const openReq = indexedDB.open(storeName, 1);\r\n            openReq.onupgradeneeded = (event) => {\r\n                const db = event.target.result;\r\n                // Huh. This should never happen; we're at version 1. Why does another\r\n                // database exist?\r\n                if (db.objectStoreNames.contains(storeName)) {\r\n                    db.deleteObjectStore(storeName);\r\n                }\r\n                db.createObjectStore(storeName);\r\n            };\r\n            openReq.onsuccess = (event) => {\r\n                cb(null, new IndexedDBStore(event.target.result, storeName));\r\n            };\r\n            openReq.onerror = onErrorHandler(cb, ErrorCodes.EACCES);\r\n        }\r\n        name() {\r\n            return IndexedDBProvider.Name + \" - \" + this.storeName;\r\n        }\r\n        clear(cb) {\r\n            try {\r\n                const tx = this.db.transaction(this.storeName, 'readwrite'), objectStore = tx.objectStore(this.storeName), r = objectStore.clear();\r\n                r.onsuccess = (event) => {\r\n                    // Use setTimeout to commit transaction.\r\n                    setTimeout(cb, 0);\r\n                };\r\n                r.onerror = onErrorHandler(cb);\r\n            }\r\n            catch (e) {\r\n                cb(convertError(e));\r\n            }\r\n        }\r\n        beginTransaction(type = 'readonly') {\r\n            const tx = this.db.transaction(this.storeName, type), objectStore = tx.objectStore(this.storeName);\r\n            if (type === 'readwrite') {\r\n                return new IndexedDBRWTransaction(tx, objectStore);\r\n            }\r\n            else if (type === 'readonly') {\r\n                return new IndexedDBROTransaction(tx, objectStore);\r\n            }\r\n            else {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Invalid transaction type.');\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return IndexedDBStore;\r\n});"]}