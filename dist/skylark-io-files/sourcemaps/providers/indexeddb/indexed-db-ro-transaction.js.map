{"version":3,"sources":["providers/indexeddb/indexed-db-ro-transaction.js"],"names":["define","FileError","ErrorCodes","AsyncKeyValueProvider","utils","arrayBuffer2Buffer","convertError","e","message","toString","name","ENOENT","ENOSPC","EIO","constructor","tx","store","this","get","key","cb","r","onerror","code","preventDefault","undefined","onsuccess","result","event","target"],"mappings":";;;;;;;AAAAA,OAAO,CACH,mBACA,oBACA,8BACA,eACD,SAAUC,EAAUC,EAAYC,EAAwBC,GACvD,aAGA,MAAQC,EAA4CD,EAA5CC,sBAOR,SAASC,EAAaC,EAAGC,EAAUD,EAAEE,SAAS,GAC1C,OAAQF,EAAEG,MACN,IAAK,gBACD,OAAO,IAAIT,EAAUC,EAAWS,OAAQH,CAAO,EACnD,IAAK,qBACD,OAAO,IAAIP,EAAUC,EAAWU,OAAQJ,CAAO,EACnD,QAEI,OAAO,IAAIP,EAAUC,EAAWW,IAAKL,CAAO,CACpD,CACJ,CA+CA,aA7BIM,YAAYC,EAAIC,GACZC,KAAKF,GAAKA,EACVE,KAAKD,MAAQA,CACjB,CACAE,IAAIC,EAAKC,GACL,IACI,IAAMC,EAAIJ,KAAKD,MAAME,IAAIC,CAAG,EAC5BE,EAAEC,SAlBUF,EAkBeA,EAlBXG,EAAOrB,EAAWW,IAAKL,EAAU,KAClD,SAAUD,GAEbA,EAAEiB,eAAe,EACjBJ,EAAG,IAAInB,EAAUsB,EAAkB,OAAZf,EAAmBA,EAAUiB,KAAAA,CAAS,CAAC,CAClE,GAcQJ,EAAEK,UAAY,IAGJC,EAASC,EAAMC,OAAOF,OAExBP,EAAG,KADQK,KAAAA,IAAXE,EACSA,EAIAtB,EAAmBsB,CAAM,CAJnB,CAMvB,CAIJ,CAFA,MAAOpB,GACHa,EAAGd,EAAaC,CAAC,CAAC,CACtB,CAlCR,IAAwBa,EAAIG,EAAuBf,CAmC/C,CACJ,CAKJ,CAAC","file":"../../../providers/indexeddb/indexed-db-ro-transaction.js","sourcesContent":["define([\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    '../async-key-value-provider',\r\n    '../../utils'\r\n], function (FileError,ErrorCodes, AsyncKeyValueProvider,  utils) {\r\n    'use strict';\r\n\r\n\r\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer }  = utils;\r\n\r\n    /**\r\n     * Converts a DOMException or a DOMError from an IndexedDB event into a\r\n     * standardized BrowserFS API error.\r\n     * @hidden\r\n     */\r\n    function convertError(e, message = e.toString()) {\r\n        switch (e.name) {\r\n            case \"NotFoundError\":\r\n                return new FileError(ErrorCodes.ENOENT, message);\r\n            case \"QuotaExceededError\":\r\n                return new FileError(ErrorCodes.ENOSPC, message);\r\n            default:\r\n                // The rest do not seem to map cleanly to standard error codes.\r\n                return new FileError(ErrorCodes.EIO, message);\r\n        }\r\n    }\r\n    /**\r\n     * Produces a new onerror handler for IDB. Our errors are always fatal, so we\r\n     * handle them generically: Call the user-supplied callback with a translated\r\n     * version of the error, and let the error bubble up.\r\n     * @hidden\r\n     */\r\n    function onErrorHandler(cb, code = ErrorCodes.EIO, message = null) {\r\n        return function (e) {\r\n            // Prevent the error from canceling the transaction.\r\n            e.preventDefault();\r\n            cb(new FileError(code, message !== null ? message : undefined));\r\n        };\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    class IndexedDBROTransaction {\r\n        constructor(tx, store) {\r\n            this.tx = tx;\r\n            this.store = store;\r\n        }\r\n        get(key, cb) {\r\n            try {\r\n                const r = this.store.get(key);\r\n                r.onerror = onErrorHandler(cb);\r\n                r.onsuccess = (event) => {\r\n                    // IDB returns the value 'undefined' when you try to get keys that\r\n                    // don't exist. The caller expects this behavior.\r\n                    const result = event.target.result;\r\n                    if (result === undefined) {\r\n                        cb(null, result);\r\n                    }\r\n                    else {\r\n                        // IDB data is stored as an ArrayBuffer\r\n                        cb(null, arrayBuffer2Buffer(result));\r\n                    }\r\n                };\r\n            }\r\n            catch (e) {\r\n                cb(convertError(e));\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    return IndexedDBROTransaction;\r\n});"]}