{"version":3,"sources":["providers/zip/zip-provider.js"],"names":["define","setImmediate","async","paths","inflateRaw","DirInode","FileInode","FIleIndex","NoSyncFile","BaseProvider","ErrorCodes","FileError","ActionType","Stats","FileType","global","util","ExtendedASCII","CentralDirectory","CompressionMethod","EndOfCentralDirectory","ZipTOC","arrayish2Buffer","copyingSlice","bufferValidator","ZipProvider","SynchronousProvider","constructor","input","name","super","this","_index","FileIndex","_directoryEntries","_eocd","index","directoryEntries","eocd","data","Create","opts","cb","_computeIndex","zipData","e","zipTOC","fs","isAvailable","_getEOCD","endOffset","Math","min","startOffset","length","let","i","readUInt32LE","slice","EINVAL","_addToIndex","cd","filename","fileName","charAt","EPERM","substr","isDirectory","addPathFast","cdPtr","cdEnd","diskNumber","cdDiskNumber","cdOffset","cdSize","_computeIndexResponsive","_computeIndexResponsiveTrampoline","cdEntries","count","totalSize","push","getName","Name","getCentralDirectoryEntry","path","inode","getInode","ENOENT","isFileInode","getData","isDirInode","getCentralDirectoryEntryAt","dirEntry","RangeError","getNumberOfCentralDirectoryEntries","getEndOfCentralDirectory","diskSpace","isReadOnly","supportsLinks","supportsProps","supportsSynch","statSync","isLstat","stats","getStats","openSync","flags","mode","isWriteable","EISDIR","cdRecord","pathExistsAction","THROW_EXCEPTION","TRUNCATE_FILE","EEXIST","NOP","readdirSync","getListing","ENOTDIR","readFileSync","fname","encoding","flag","fd","fdBuff","getBuffer","toString","closeSync","Options","type","description","validator","optional","RegisterDecompressionMethod","DEFLATE","compressedSize","uncompressedSize","chunkSize","STORED","registry","add"],"mappings":"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","file":"../../../providers/zip/zip-provider.js","sourcesContent":["define([\r\n    \"skylark-langx-funcs/defer\",\r\n    \"skylark-langx-async\",\r\n    \"skylark-langx-paths\",\r\n    \"skylark-data-compression/inflate-raw\",\r\n    \"../../inodes/dir-inode\",\r\n    \"../../inodes/file-inode\",    \r\n    \"../../inodes/file-index\",    \r\n    '../../no-sync-file',\r\n    \"../synchronous-provider\",\r\n    '../../error-codes',\r\n    '../../file-error',\r\n    '../../action-type',\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../core/global',\r\n    '../core/util',\r\n    \"./extended_ascii\",\r\n    \"./central-directory\",\r\n    \"./compression-method\",\r\n    \"./end-of-central-directory\",\r\n    \"./zip-toc\"\r\n], function (\r\n    setImmediate,\r\n    async,\r\n    paths,\r\n    inflateRaw,\r\n    DirInode,\r\n    FileInode,\r\n    FIleIndex,\r\n    NoSyncFile, \r\n    BaseProvider, \r\n    ErrorCodes, \r\n    FileError,\r\n    ActionType, \r\n    Stats,\r\n    FileType, \r\n    global, \r\n    util,\r\n    ExtendedASCII,\r\n    CentralDirectory,\r\n    CompressionMethod,\r\n    EndOfCentralDirectory,\r\n    ZipTOC\r\n) {\r\n\r\n    const { arrayish2Buffer, copyingSlice, bufferValidator }  = util;\r\n\r\n\r\n    /*\r\n       4.3.6 Overall .ZIP file format:\r\n\r\n          [local file header 1]\r\n          [encryption header 1]\r\n          [file data 1]\r\n          [data descriptor 1]\r\n          .\r\n          .\r\n          .\r\n          [local file header n]\r\n          [encryption header n]\r\n          [file data n]\r\n          [data descriptor n]\r\n          [archive decryption header]\r\n          [archive extra data record]\r\n          [central directory header 1]\r\n          .\r\n          .\r\n          .\r\n          [central directory header n]\r\n          [zip64 end of central directory record]\r\n          [zip64 end of central directory locator]\r\n          [end of central directory record]\r\n    */\r\n\r\n\r\n\r\n    /**\r\n     * Zip file-backed filesystem\r\n     * Implemented according to the standard:\r\n     * http://www.pkware.com/documents/casestudies/APPNOTE.TXT\r\n     *\r\n     * While there are a few zip libraries for JavaScript (e.g. JSZip and zip.js),\r\n     * they are not a good match for BrowserFS. In particular, these libraries\r\n     * perform a lot of unneeded data copying, and eagerly decompress every file\r\n     * in the zip file upon loading to check the CRC32. They also eagerly decode\r\n     * strings. Furthermore, these libraries duplicate functionality already present\r\n     * in BrowserFS (e.g. UTF-8 decoding and binary data manipulation).\r\n     *\r\n     * This filesystem takes advantage of BrowserFS's Buffer implementation, which\r\n     * efficiently represents the zip file in memory (in both ArrayBuffer-enabled\r\n     * browsers *and* non-ArrayBuffer browsers), and which can neatly be 'sliced'\r\n     * without copying data. Each struct defined in the standard is represented with\r\n     * a buffer slice pointing to an offset in the zip file, and has getters for\r\n     * each field. As we anticipate that this data will not be read often, we choose\r\n     * not to store each struct field in the JavaScript object; instead, to reduce\r\n     * memory consumption, we retrieve it directly from the binary data each time it\r\n     * is requested.\r\n     *\r\n     * When the filesystem is instantiated, we determine the directory structure\r\n     * of the zip file as quickly as possible. We lazily decompress and check the\r\n     * CRC32 of files. We do not cache decompressed files; if this is a desired\r\n     * feature, it is best implemented as a generic file system wrapper that can\r\n     * cache data from arbitrary file systems.\r\n     *\r\n     * For inflation, we use `pako`'s implementation:\r\n     * https://github.com/nodeca/pako\r\n     *\r\n     * Current limitations:\r\n     * * No encryption.\r\n     * * No ZIP64 support.\r\n     * * Read-only.\r\n     *   Write support would require that we:\r\n     *   - Keep track of changed/new files.\r\n     *   - Compress changed files, and generate appropriate metadata for each.\r\n     *   - Update file offsets for other files in the zip file.\r\n     *   - Stream it out to a location.\r\n     *   This isn't that bad, so we might do this at a later date.\r\n     */\r\n    class ZipProvider extends SynchronousProvider {\r\n        constructor(input, name = '') {\r\n            super();\r\n            this.name = name;\r\n            this._index = new FileIndex();\r\n            this._directoryEntries = [];\r\n            this._eocd = null;\r\n            this._index = input.index;\r\n            this._directoryEntries = input.directoryEntries;\r\n            this._eocd = input.eocd;\r\n            this.data = input.data;\r\n        }\r\n        /**\r\n         * Constructs a ZipProvider instance with the given options.\r\n         */\r\n        static Create(opts, cb) {\r\n            try {\r\n                ZipProvider._computeIndex(opts.zipData, (e, zipTOC) => {\r\n                    if (zipTOC) {\r\n                        const fs = new ZipProvider(zipTOC, opts.name);\r\n                        cb(null, fs);\r\n                    }\r\n                    else {\r\n                        cb(e);\r\n                    }\r\n                });\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        static isAvailable() { return true; }\r\n\r\n        /**\r\n         * Locates the end of central directory record at the end of the file.\r\n         * Throws an exception if it cannot be found.\r\n         */\r\n        static _getEOCD(data) {\r\n            // Unfortunately, the comment is variable size and up to 64K in size.\r\n            // We assume that the magic signature does not appear in the comment, and\r\n            // in the bytes between the comment and the signature. Other ZIP\r\n            // implementations make this same assumption, since the alternative is to\r\n            // read thread every entry in the file to get to it. :(\r\n            // These are *negative* offsets from the end of the file.\r\n            const startOffset = 22;\r\n            const endOffset = Math.min(startOffset + 0xFFFF, data.length - 1);\r\n            // There's not even a byte alignment guarantee on the comment so we need to\r\n            // search byte by byte. *grumble grumble*\r\n            for (let i = startOffset; i < endOffset; i++) {\r\n                // Magic number: EOCD Signature\r\n                if (data.readUInt32LE(data.length - i) === 0x06054b50) {\r\n                    return new EndOfCentralDirectory(data.slice(data.length - i));\r\n                }\r\n            }\r\n            throw new FileError(ErrorCodes.EINVAL, \"Invalid ZIP file: Could not locate End of Central Directory signature.\");\r\n        }\r\n        static _addToIndex(cd, index) {\r\n            // Paths must be absolute, yet zip file paths are always relative to the\r\n            // zip root. So we append '/' and call it a day.\r\n            let filename = cd.fileName();\r\n            if (filename.charAt(0) === '/') {\r\n                throw new FileError(ErrorCodes.EPERM, `Unexpectedly encountered an absolute path in a zip file. Please file a bug.`);\r\n            }\r\n            // XXX: For the file index, strip the trailing '/'.\r\n            if (filename.charAt(filename.length - 1) === '/') {\r\n                filename = filename.substr(0, filename.length - 1);\r\n            }\r\n            if (cd.isDirectory()) {\r\n                index.addPathFast('/' + filename, new DirInode(cd));\r\n            }\r\n            else {\r\n                index.addPathFast('/' + filename, new FileInode(cd));\r\n            }\r\n        }\r\n        static _computeIndex(data, cb) {\r\n            try {\r\n                const index = new FileIndex();\r\n                const eocd = ZipProvider._getEOCD(data);\r\n                if (eocd.diskNumber() !== eocd.cdDiskNumber()) {\r\n                    return cb(new FileError(ErrorCodes.EINVAL, \"ZipProvider does not support spanned zip files.\"));\r\n                }\r\n                const cdPtr = eocd.cdOffset();\r\n                if (cdPtr === 0xFFFFFFFF) {\r\n                    return cb(new FileError(ErrorCodes.EINVAL, \"ZipProvider does not support Zip64.\"));\r\n                }\r\n                const cdEnd = cdPtr + eocd.cdSize();\r\n                ZipProvider._computeIndexResponsive(data, index, cdPtr, cdEnd, cb, [], eocd);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        static _computeIndexResponsiveTrampoline(data, index, cdPtr, cdEnd, cb, cdEntries, eocd) {\r\n            try {\r\n                ZipProvider._computeIndexResponsive(data, index, cdPtr, cdEnd, cb, cdEntries, eocd);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        static _computeIndexResponsive(data, index, cdPtr, cdEnd, cb, cdEntries, eocd) {\r\n            if (cdPtr < cdEnd) {\r\n                let count = 0;\r\n                while (count++ < 200 && cdPtr < cdEnd) {\r\n                    const cd = new CentralDirectory(data, data.slice(cdPtr));\r\n                    ZipProvider._addToIndex(cd, index);\r\n                    cdPtr += cd.totalSize();\r\n                    cdEntries.push(cd);\r\n                }\r\n                setImmediate(() => {\r\n                    ZipProvider._computeIndexResponsiveTrampoline(data, index, cdPtr, cdEnd, cb, cdEntries, eocd);\r\n                });\r\n            }\r\n            else {\r\n                cb(null, new ZipTOC(index, cdEntries, eocd, data));\r\n            }\r\n        }\r\n        getName() {\r\n            return ZipProvider.Name + (this.name !== '' ? ` ${this.name}` : '');\r\n        }\r\n        /**\r\n         * Get the CentralDirectory object for the given path.\r\n         */\r\n        getCentralDirectoryEntry(path) {\r\n            const inode = this._index.getInode(path);\r\n            if (inode === null) {\r\n                throw FileError.ENOENT(path);\r\n            }\r\n            if (FileInode.isFileInode(inode)) {\r\n                return inode.getData();\r\n            }\r\n            else if (DirInode.isDirInode(inode)) {\r\n                return inode.getData();\r\n            }\r\n            else {\r\n                // Should never occur.\r\n                throw FileError.EPERM(`Invalid inode: ${inode}`);\r\n            }\r\n        }\r\n        getCentralDirectoryEntryAt(index) {\r\n            const dirEntry = this._directoryEntries[index];\r\n            if (!dirEntry) {\r\n                throw new RangeError(`Invalid directory index: ${index}.`);\r\n            }\r\n            return dirEntry;\r\n        }\r\n        getNumberOfCentralDirectoryEntries() {\r\n            return this._directoryEntries.length;\r\n        }\r\n        getEndOfCentralDirectory() {\r\n            return this._eocd;\r\n        }\r\n        diskSpace(path, cb) {\r\n            // Read-only file system.\r\n            cb(this.data.length, 0);\r\n        }\r\n        isReadOnly() {\r\n            return true;\r\n        }\r\n        supportsLinks() {\r\n            return false;\r\n        }\r\n        supportsProps() {\r\n            return false;\r\n        }\r\n        supportsSynch() {\r\n            return true;\r\n        }\r\n        statSync(path, isLstat) {\r\n            const inode = this._index.getInode(path);\r\n            if (inode === null) {\r\n                throw FileError.ENOENT(path);\r\n            }\r\n            let stats;\r\n            if (FileInode.isFileInode(inode)) {\r\n                stats = inode.getData().getStats();\r\n            }\r\n            else if (DirInode.isDirInode(inode)) {\r\n                stats = inode.getStats();\r\n            }\r\n            else {\r\n                throw new FileError(ErrorCodes.EINVAL, \"Invalid inode.\");\r\n            }\r\n            return stats;\r\n        }\r\n        openSync(path, flags, mode) {\r\n            // INVARIANT: Cannot write to RO file systems.\r\n            if (flags.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, path);\r\n            }\r\n            // Check if the path exists, and is a file.\r\n            const inode = this._index.getInode(path);\r\n            if (!inode) {\r\n                throw FileError.ENOENT(path);\r\n            }\r\n            else if (FileInode.isFileInode(inode)) {\r\n                const cdRecord = inode.getData();\r\n                const stats = cdRecord.getStats();\r\n                switch (flags.pathExistsAction()) {\r\n                    case ActionType.THROW_EXCEPTION:\r\n                    case ActionType.TRUNCATE_FILE:\r\n                        throw FileError.EEXIST(path);\r\n                    case ActionType.NOP:\r\n                        return new NoSyncFile(this, path, flags, stats, cdRecord.getData());\r\n                    default:\r\n                        throw new FileError(ErrorCodes.EINVAL, 'Invalid FileMode object.');\r\n                }\r\n            }\r\n            else {\r\n                throw FileError.EISDIR(path);\r\n            }\r\n        }\r\n        readdirSync(path) {\r\n            // Check if it exists.\r\n            const inode = this._index.getInode(path);\r\n            if (!inode) {\r\n                throw FileError.ENOENT(path);\r\n            }\r\n            else if (DirInode.isDirInode(inode)) {\r\n                return inode.getListing();\r\n            }\r\n            else {\r\n                throw FileError.ENOTDIR(path);\r\n            }\r\n        }\r\n        /**\r\n         * Specially-optimized readfile.\r\n         */\r\n        readFileSync(fname, encoding, flag) {\r\n            // Get file.\r\n            const fd = this.openSync(fname, flag, 0x1a4);\r\n            try {\r\n                const fdCast = fd;\r\n                const fdBuff = fdCast.getBuffer();\r\n                if (encoding === null) {\r\n                    return copyingSlice(fdBuff);\r\n                }\r\n                return fdBuff.toString(encoding);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n    }\r\n    \r\n    ZipProvider.Name = \"ZipProvider\";\r\n    ZipProvider.Options = {\r\n        zipData: {\r\n            type: \"object\",\r\n            description: \"The zip file as a Buffer object.\",\r\n            validator: bufferValidator\r\n        },\r\n        name: {\r\n            type: \"string\",\r\n            optional: true,\r\n            description: \"The name of the zip file (optional).\"\r\n        }\r\n    };\r\n    ZipProvider.CompressionMethod = CompressionMethod;\r\n    ZipProvider.RegisterDecompressionMethod(CompressionMethod.DEFLATE, (data, compressedSize, uncompressedSize) => {\r\n        return arrayish2Buffer(inflateRaw(data.slice(0, compressedSize), { chunkSize: uncompressedSize }));\r\n    });\r\n    ZipProvider.RegisterDecompressionMethod(CompressionMethod.STORED, (data, compressedSize, uncompressedSize) => {\r\n        return copyingSlice(data, 0, uncompressedSize);\r\n    });\r\n\r\n\r\n    registry.add(\"zip\",ZipProvider);\r\n\r\n\r\n    return ZipProvider;\r\n\r\n});"]}