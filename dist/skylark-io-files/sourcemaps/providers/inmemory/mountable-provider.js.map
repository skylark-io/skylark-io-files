{"version":3,"sources":["providers/inmemory/mountable-provider.js"],"names":["define","paths","files","registry","BaseProvider","InMemoryProvider","FileError","ErrorCodes","utils","mkdirpSync","MountableProvider","constructor","rootFs","super","this","mountList","mntMap","Create","opts","cb","e","imfs","fs","Object","keys","forEach","mount","mountPoint","isAvailable","resolve","EINVAL","push","sort","a","b","length","umount","splice","indexOf","readdirSync","rmdirSync","dirname","_getFs","path","len","let","i","substr","getName","Name","diskSpace","isReadOnly","supportsLinks","supportsProps","supportsSynch","standardizeError","err","realPath","index","message","rename","oldPath","newPath","fs1rv","fs2rv","readFile","data","writeFile","unlink","renameSync","readFileSync","writeFileSync","unlinkSync","p","fsInfo","rv","rv2","concat","filter","val","readdir","realpathSync","cache","mountedPath","join","realpath","_containsMountPt","ENOTEMPTY","rmdir","mountPoints","pt","slice","defineFcn","name","isSync","args","apply","Options","fsCmdMap","fnName","prototype","providers"],"mappings":"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","file":"../../../providers/inmemory/mountable-provider.js","sourcesContent":["define([\r\n    \"skylark-langx-paths\",\r\n    \"../../files\",\r\n    \"../registry\",\r\n    \"../base-provider\",\r\n    './in-memory-provider',\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    '../../utils'\r\n], function (paths,files,registry,BaseProvider, InMemoryProvider, FileError, ErrorCodes, utils) {\r\n    'use strict';\r\n    const { mkdirpSync }  = utils;\r\n\r\n    /**\r\n     * The mountable filesystem provider allows you to mount multiple backend types or\r\n     * multiple instantiations of the same backend into a single file system tree.\r\n     * The file systems do not need to know about each other; all interactions are\r\n     * automatically facilitated through this interface.\r\n     *\r\n     * For example, if a file system is mounted at /mnt/blah, and a request came in\r\n     * for /mnt/blah/foo.txt, the file system would see a request for /foo.txt.\r\n     *\r\n     * You can mount file systems when you configure the file system:\r\n     * ```javascript\r\n     * BrowserFS.configure({\r\n     *   fs: \"MountableProvider\",\r\n     *   options: {\r\n     *     '/data': { fs: 'HTTPRequest', options: { index: \"http://mysite.com/files/index.json\" } },\r\n     *     '/home': { fs: 'LocalStorage' }\r\n     *   }\r\n     * }, function(e) {\r\n     *\r\n     * });\r\n     * ```\r\n     *\r\n     * For advanced users, you can also mount file systems *after* MFS is constructed:\r\n     * ```javascript\r\n     * BrowserFS.Provider.HTTPRequest.Create({\r\n     *   index: \"http://mysite.com/files/index.json\"\r\n     * }, function(e, xhrfs) {\r\n     *   BrowserFS.Provider.MountableProvider.Create({\r\n     *     '/data': xhrfs\r\n     *   }, function(e, mfs) {\r\n     *     BrowserFS.initialize(mfs);\r\n     *\r\n     *     // Added after-the-fact...\r\n     *     BrowserFS.Provider.LocalStorage.Create(function(e, lsfs) {\r\n     *       mfs.mount('/home', lsfs);\r\n     *     });\r\n     *   });\r\n     * });\r\n     * ```\r\n     *\r\n     * Since MountableProvider simply proxies requests to mounted file systems, it supports all of the operations that the mounted file systems support.\r\n     *\r\n     * With no mounted file systems, `MountableProvider` acts as a simple `InMemory` filesystem.\r\n     */\r\n    class MountableProvider extends BaseProvider {\r\n        /**\r\n         * Creates a new, empty MountableProvider.\r\n         */\r\n        constructor(rootFs) {\r\n            super();\r\n            // Contains the list of mount points in mntMap, sorted by string length in decreasing order.\r\n            // Ensures that we scan the most specific mount points for a match first, which lets us\r\n            // nest mount points.\r\n            this.mountList = [];\r\n            this.mntMap = {};\r\n            this.rootFs = rootFs;\r\n        }\r\n        /**\r\n         * Creates a MountableProvider instance with the given options.\r\n         */\r\n        static Create(opts, cb) {\r\n            InMemoryProvider.Create({}, (e, imfs) => {\r\n                if (imfs) {\r\n                    const fs = new MountableProvider(imfs);\r\n                    try {\r\n                        Object.keys(opts).forEach((mountPoint) => {\r\n                            fs.mount(mountPoint, opts[mountPoint]);\r\n                        });\r\n                    }\r\n                    catch (e) {\r\n                        return cb(e);\r\n                    }\r\n                    cb(null, fs);\r\n                }\r\n                else {\r\n                    cb(e);\r\n                }\r\n            });\r\n        }\r\n        static isAvailable() {\r\n            return true;\r\n        }\r\n        /**\r\n         * Mounts the file system at the given mount point.\r\n         */\r\n        mount(mountPoint, fs) {\r\n            if (mountPoint[0] !== '/') {\r\n                mountPoint = `/${mountPoint}`;\r\n            }\r\n            mountPoint = paths.resolve(mountPoint);\r\n            if (this.mntMap[mountPoint]) {\r\n                throw new FileError(ErrorCodes.EINVAL, \"Mount point \" + mountPoint + \" is already taken.\");\r\n            }\r\n            mkdirpSync(mountPoint, 0x1ff, this.rootFs);\r\n            this.mntMap[mountPoint] = fs;\r\n            this.mountList.push(mountPoint);\r\n            this.mountList = this.mountList.sort((a, b) => b.length - a.length);\r\n        }\r\n        umount(mountPoint) {\r\n            if (mountPoint[0] !== '/') {\r\n                mountPoint = `/${mountPoint}`;\r\n            }\r\n            mountPoint = paths.resolve(mountPoint);\r\n            if (!this.mntMap[mountPoint]) {\r\n                throw new FileError(ErrorCodes.EINVAL, \"Mount point \" + mountPoint + \" is already unmounted.\");\r\n            }\r\n            delete this.mntMap[mountPoint];\r\n            this.mountList.splice(this.mountList.indexOf(mountPoint), 1);\r\n            while (mountPoint !== '/') {\r\n                if (this.rootFs.readdirSync(mountPoint).length === 0) {\r\n                    this.rootFs.rmdirSync(mountPoint);\r\n                    mountPoint = paths.dirname(mountPoint);\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Returns the file system that the path points to.\r\n         */\r\n        _getFs(path) {\r\n            const mountList = this.mountList, len = mountList.length;\r\n            for (let i = 0; i < len; i++) {\r\n                const mountPoint = mountList[i];\r\n                // We know path is normalized, so it is a substring of the mount point.\r\n                if (mountPoint.length <= path.length && path.indexOf(mountPoint) === 0) {\r\n                    path = path.substr(mountPoint.length > 1 ? mountPoint.length : 0);\r\n                    if (path === '') {\r\n                        path = '/';\r\n                    }\r\n                    return { fs: this.mntMap[mountPoint], path: path, mountPoint: mountPoint };\r\n                }\r\n            }\r\n            // Query our root file system.\r\n            return { fs: this.rootFs, path: path, mountPoint: '/' };\r\n        }\r\n        // Global information methods\r\n        getName() {\r\n            return MountableProvider.Name;\r\n        }\r\n        diskSpace(path, cb) {\r\n            cb(0, 0);\r\n        }\r\n        isReadOnly() {\r\n            return false;\r\n        }\r\n        supportsLinks() {\r\n            // I'm not ready for cross-FS links yet.\r\n            return false;\r\n        }\r\n        supportsProps() {\r\n            return false;\r\n        }\r\n        supportsSynch() {\r\n            return true;\r\n        }\r\n        /**\r\n         * Fixes up error messages so they mention the mounted file location relative\r\n         * to the MFS root, not to the particular FS's root.\r\n         * Mutates the input error, and returns it.\r\n         */\r\n        standardizeError(err, path, realPath) {\r\n            const index = err.message.indexOf(path);\r\n            if (index !== -1) {\r\n                err.message = err.message.substr(0, index) + realPath + err.message.substr(index + path.length);\r\n                err.path = realPath;\r\n            }\r\n            return err;\r\n        }\r\n        // The following methods involve multiple file systems, and thus have custom\r\n        // logic.\r\n        // Note that we go through the Node API to use its robust default argument\r\n        // processing.\r\n        rename(oldPath, newPath, cb) {\r\n            // Scenario 1: old and new are on same FS.\r\n            const fs1rv = this._getFs(oldPath);\r\n            const fs2rv = this._getFs(newPath);\r\n            if (fs1rv.fs === fs2rv.fs) {\r\n                return fs1rv.fs.rename(fs1rv.path, fs2rv.path, (e) => {\r\n                    if (e) {\r\n                        this.standardizeError(this.standardizeError(e, fs1rv.path, oldPath), fs2rv.path, newPath);\r\n                    }\r\n                    cb(e);\r\n                });\r\n            }\r\n            // Scenario 2: Different file systems.\r\n            // Read old file, write new file, delete old file.\r\n            return fs.readFile(oldPath, function (err, data) {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                fs.writeFile(newPath, data, function (err) {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    fs.unlink(oldPath, cb);\r\n                });\r\n            });\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            // Scenario 1: old and new are on same FS.\r\n            const fs1rv = this._getFs(oldPath);\r\n            const fs2rv = this._getFs(newPath);\r\n            if (fs1rv.fs === fs2rv.fs) {\r\n                try {\r\n                    return fs1rv.fs.renameSync(fs1rv.path, fs2rv.path);\r\n                }\r\n                catch (e) {\r\n                    this.standardizeError(this.standardizeError(e, fs1rv.path, oldPath), fs2rv.path, newPath);\r\n                    throw e;\r\n                }\r\n            }\r\n            // Scenario 2: Different file systems.\r\n            const data = fs.readFileSync(oldPath);\r\n            fs.writeFileSync(newPath, data);\r\n            return fs.unlinkSync(oldPath);\r\n        }\r\n        readdirSync(p) {\r\n            const fsInfo = this._getFs(p);\r\n            // If null, rootfs did not have the directory\r\n            // (or the target FS is the root fs).\r\n            let rv = null;\r\n            // Mount points are all defined in the root FS.\r\n            // Ensure that we list those, too.\r\n            if (fsInfo.fs !== this.rootFs) {\r\n                try {\r\n                    rv = this.rootFs.readdirSync(p);\r\n                }\r\n                catch (e) {\r\n                    // Ignore.\r\n                }\r\n            }\r\n            try {\r\n                const rv2 = fsInfo.fs.readdirSync(fsInfo.path);\r\n                if (rv === null) {\r\n                    return rv2;\r\n                }\r\n                else {\r\n                    // Filter out duplicates.\r\n                    return rv2.concat(rv.filter((val) => rv2.indexOf(val) === -1));\r\n                }\r\n            }\r\n            catch (e) {\r\n                if (rv === null) {\r\n                    throw this.standardizeError(e, fsInfo.path, p);\r\n                }\r\n                else {\r\n                    // The root FS had something.\r\n                    return rv;\r\n                }\r\n            }\r\n        }\r\n        readdir(p, cb) {\r\n            const fsInfo = this._getFs(p);\r\n            fsInfo.fs.readdir(fsInfo.path, (err, files) => {\r\n                if (fsInfo.fs !== this.rootFs) {\r\n                    try {\r\n                        const rv = this.rootFs.readdirSync(p);\r\n                        if (files) {\r\n                            // Filter out duplicates.\r\n                            files = files.concat(rv.filter((val) => files.indexOf(val) === -1));\r\n                        }\r\n                        else {\r\n                            files = rv;\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        // Root FS and target FS did not have directory.\r\n                        if (err) {\r\n                            return cb(this.standardizeError(err, fsInfo.path, p));\r\n                        }\r\n                    }\r\n                }\r\n                else if (err) {\r\n                    // Root FS and target FS are the same, and did not have directory.\r\n                    return cb(this.standardizeError(err, fsInfo.path, p));\r\n                }\r\n                cb(null, files);\r\n            });\r\n        }\r\n        realpathSync(p, cache) {\r\n            const fsInfo = this._getFs(p);\r\n            try {\r\n                const mountedPath = fsInfo.fs.realpathSync(fsInfo.path, {});\r\n                // resolve is there to remove any trailing slash that may be present\r\n                return paths.resolve(paths.join(fsInfo.mountPoint, mountedPath));\r\n            }\r\n            catch (e) {\r\n                throw this.standardizeError(e, fsInfo.path, p);\r\n            }\r\n        }\r\n        realpath(p, cache, cb) {\r\n            const fsInfo = this._getFs(p);\r\n            fsInfo.fs.realpath(fsInfo.path, {}, (err, rv) => {\r\n                if (err) {\r\n                    cb(this.standardizeError(err, fsInfo.path, p));\r\n                }\r\n                else {\r\n                    // resolve is there to remove any trailing slash that may be present\r\n                    cb(null, paths.resolve(paths.join(fsInfo.mountPoint, rv)));\r\n                }\r\n            });\r\n        }\r\n        rmdirSync(p) {\r\n            const fsInfo = this._getFs(p);\r\n            if (this._containsMountPt(p)) {\r\n                throw FileError.ENOTEMPTY(p);\r\n            }\r\n            else {\r\n                try {\r\n                    fsInfo.fs.rmdirSync(fsInfo.path);\r\n                }\r\n                catch (e) {\r\n                    throw this.standardizeError(e, fsInfo.path, p);\r\n                }\r\n            }\r\n        }\r\n        rmdir(p, cb) {\r\n            const fsInfo = this._getFs(p);\r\n            if (this._containsMountPt(p)) {\r\n                cb(FileError.ENOTEMPTY(p));\r\n            }\r\n            else {\r\n                fsInfo.fs.rmdir(fsInfo.path, (err) => {\r\n                    cb(err ? this.standardizeError(err, fsInfo.path, p) : null);\r\n                });\r\n            }\r\n        }\r\n        /**\r\n         * Returns true if the given path contains a mount point.\r\n         */\r\n        _containsMountPt(p) {\r\n            const mountPoints = this.mountList, len = mountPoints.length;\r\n            for (let i = 0; i < len; i++) {\r\n                const pt = mountPoints[i];\r\n                if (pt.length >= p.length && pt.slice(0, p.length) === p) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    MountableProvider.Name = \"MountableProvider\";\r\n    MountableProvider.Options = {};\r\n    /**\r\n     * Tricky: Define all of the functions that merely forward arguments to the\r\n     * relevant file system, or return/throw an error.\r\n     * Take advantage of the fact that the *first* argument is always the path, and\r\n     * the *last* is the callback function (if async).\r\n     * @todo Can use numArgs to make proxying more efficient.\r\n     * @hidden\r\n     */\r\n    function defineFcn(name, isSync, numArgs) {\r\n        if (isSync) {\r\n            return function (...args) {\r\n                const path = args[0];\r\n                const rv = this._getFs(path);\r\n                args[0] = rv.path;\r\n                try {\r\n                    return rv.fs[name].apply(rv.fs, args);\r\n                }\r\n                catch (e) {\r\n                    this.standardizeError(e, rv.path, path);\r\n                    throw e;\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            return function (...args) {\r\n                const path = args[0];\r\n                const rv = this._getFs(path);\r\n                args[0] = rv.path;\r\n                if (typeof args[args.length - 1] === 'function') {\r\n                    const cb = args[args.length - 1];\r\n                    args[args.length - 1] = (...args) => {\r\n                        if (args.length > 0 && args[0] instanceof FileError) {\r\n                            this.standardizeError(args[0], rv.path, path);\r\n                        }\r\n                        cb.apply(null, args);\r\n                    };\r\n                }\r\n                return rv.fs[name].apply(rv.fs, args);\r\n            };\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    const fsCmdMap = [\r\n        // 1 arg functions\r\n        ['exists', 'unlink', 'readlink'],\r\n        // 2 arg functions\r\n        ['stat', 'mkdir', 'truncate'],\r\n        // 3 arg functions\r\n        ['open', 'readFile', 'chmod', 'utimes'],\r\n        // 4 arg functions\r\n        ['chown'],\r\n        // 5 arg functions\r\n        ['writeFile', 'appendFile']\r\n    ];\r\n    for (let i = 0; i < fsCmdMap.length; i++) {\r\n        const cmds = fsCmdMap[i];\r\n        for (const fnName of cmds) {\r\n            MountableProvider.prototype[fnName] = defineFcn(fnName, false, i + 1);\r\n            MountableProvider.prototype[fnName + 'Sync'] = defineFcn(fnName + 'Sync', true, i + 1);\r\n        }\r\n    }\r\n\r\n\r\n    return files.providers.MountableProvider = MountableProvider;\r\n});"]}