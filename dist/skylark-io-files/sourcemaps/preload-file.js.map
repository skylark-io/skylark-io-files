{"version":3,"sources":["preload-file.js"],"names":["define","Buffer","files","ErrorCodes","FileError","Stats","BaseFile","utils","emptyBuffer","PreloadFile","constructor","_fs","_path","_flag","_stat","contents","super","this","_pos","_dirty","_buffer","size","length","isReadable","Error","getBuffer","getStats","getFlag","getPath","getPos","isAppendable","advancePos","delta","setPos","newPos","sync","cb","syncSync","e","ENOTSUP","close","closeSync","stat","clone","statSync","truncate","len","truncateSync","isSynchronous","fs","getRootFS","supportsSynch","isWriteable","EPERM","newBuff","mtimeMs","Date","now","buf","alloc","writeSync","copy","write","buffer","offset","position","endFp","read","readSync","rv","atimeMs","chmod","mode","chmodSync","supportsProps","isDirty","resetDirty"],"mappings":"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","file":"../preload-file.js","sourcesContent":["define([\r\n    \"skylark-langx-binary/buffer\",\r\n    \"./files\",\r\n    \"./error-codes\",\r\n    './file-error',\r\n    \"./stats\",\r\n    \"./base-file\",\r\n    './utils'\r\n], function (Buffer,files,ErrorCodes,FileError,Stats,BaseFile, utils) {\r\n    'use strict';\r\n\r\n    ////fs     '../core/node_fs',\r\n\r\n    const { emptyBuffer } = utils;\r\n\r\n    /**\r\n     * An implementation of the File interface that operates on a file that is\r\n     * completely in-memory. PreloadFiles are backed by a Buffer.\r\n     *\r\n     * This is also an abstract class, as it lacks an implementation of 'sync' and\r\n     * 'close'. Each filesystem that wishes to use this file representation must\r\n     * extend this class and implement those two methods.\r\n     * @todo 'close' lever that disables functionality once closed.\r\n     */\r\n    class PreloadFile extends BaseFile {\r\n        /**\r\n         * Creates a file with the given path and, optionally, the given contents. Note\r\n         * that, if contents is specified, it will be mutated by the file!\r\n         * @param _fs The file system that created the file.\r\n         * @param _path\r\n         * @param _mode The mode that the file was opened using.\r\n         *   Dictates permissions and where the file pointer starts.\r\n         * @param _stat The stats object for the given file.\r\n         *   PreloadFile will mutate this object. Note that this object must contain\r\n         *   the appropriate mode that the file was opened as.\r\n         * @param contents A buffer containing the entire\r\n         *   contents of the file. PreloadFile will mutate this buffer. If not\r\n         *   specified, we assume it is a new file.\r\n         */\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super();\r\n            this._pos = 0;\r\n            this._dirty = false;\r\n            this._fs = _fs;\r\n            this._path = _path;\r\n            this._flag = _flag;\r\n            this._stat = _stat;\r\n            this._buffer = contents ? contents : emptyBuffer();\r\n            // Note: This invariant is *not* maintained once the file starts getting\r\n            // modified.\r\n            // Note: Only actually matters if file is readable, as writeable modes may\r\n            // truncate/append to file.\r\n            if (this._stat.size !== this._buffer.length && this._flag.isReadable()) {\r\n                throw new Error(`Invalid buffer: Buffer is ${this._buffer.length} long, yet Stats object specifies that file is ${this._stat.size} long.`);\r\n            }\r\n        }\r\n        /**\r\n         * NONSTANDARD: Get the underlying buffer for this file. !!DO NOT MUTATE!! Will mess up dirty tracking.\r\n         */\r\n        getBuffer() {\r\n            return this._buffer;\r\n        }\r\n        /**\r\n         * NONSTANDARD: Get underlying stats for this file. !!DO NOT MUTATE!!\r\n         */\r\n        getStats() {\r\n            return this._stat;\r\n        }\r\n        getFlag() {\r\n            return this._flag;\r\n        }\r\n        /**\r\n         * Get the path to this file.\r\n         * @return [String] The path to the file.\r\n         */\r\n        getPath() {\r\n            return this._path;\r\n        }\r\n        /**\r\n         * Get the current file position.\r\n         *\r\n         * We emulate the following bug mentioned in the Node documentation:\r\n         * > On Linux, positional writes don't work when the file is opened in append\r\n         *   mode. The kernel ignores the position argument and always appends the data\r\n         *   to the end of the file.\r\n         * @return [Number] The current file position.\r\n         */\r\n        getPos() {\r\n            if (this._flag.isAppendable()) {\r\n                return this._stat.size;\r\n            }\r\n            return this._pos;\r\n        }\r\n        /**\r\n         * Advance the current file position by the indicated number of positions.\r\n         * @param [Number] delta\r\n         */\r\n        advancePos(delta) {\r\n            return this._pos += delta;\r\n        }\r\n        /**\r\n         * Set the file position.\r\n         * @param [Number] newPos\r\n         */\r\n        setPos(newPos) {\r\n            return this._pos = newPos;\r\n        }\r\n        /**\r\n         * **Core**: Asynchronous sync. Must be implemented by subclasses of this\r\n         * class.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        sync(cb) {\r\n            try {\r\n                this.syncSync();\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * **Core**: Synchronous sync.\r\n         */\r\n        syncSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * **Core**: Asynchronous close. Must be implemented by subclasses of this\r\n         * class.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        close(cb) {\r\n            try {\r\n                this.closeSync();\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * **Core**: Synchronous close.\r\n         */\r\n        closeSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Asynchronous `stat`.\r\n         * @param [Function(BrowserFS.FileError, BrowserFS.node.fs.Stats)] cb\r\n         */\r\n        stat(cb) {\r\n            try {\r\n                cb(null, Stats.clone(this._stat));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `stat`.\r\n         */\r\n        statSync() {\r\n            return Stats.clone(this._stat);\r\n        }\r\n        /**\r\n         * Asynchronous truncate.\r\n         * @param [Number] len\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        truncate(len, cb) {\r\n            try {\r\n                this.truncateSync(len);\r\n                if (this._flag.isSynchronous() && !fs.getRootFS().supportsSynch()) {\r\n                    this.sync(cb);\r\n                }\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                return cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous truncate.\r\n         * @param [Number] len\r\n         */\r\n        truncateSync(len) {\r\n            this._dirty = true;\r\n            if (!this._flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a writeable mode.');\r\n            }\r\n            this._stat.mtimeMs = Date.now();\r\n            if (len > this._buffer.length) {\r\n                const buf = Buffer.alloc(len - this._buffer.length, 0);\r\n                // Write will set @_stat.size for us.\r\n                this.writeSync(buf, 0, buf.length, this._buffer.length);\r\n                if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\r\n                    this.syncSync();\r\n                }\r\n                return;\r\n            }\r\n            this._stat.size = len;\r\n            // Truncate buffer to 'len'.\r\n            const newBuff = Buffer.alloc(len);\r\n            this._buffer.copy(newBuff, 0, 0, len);\r\n            this._buffer = newBuff;\r\n            if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\r\n                this.syncSync();\r\n            }\r\n        }\r\n        /**\r\n         * Write buffer to the file.\r\n         * Note that it is unsafe to use fs.write multiple times on the same file\r\n         * without waiting for the callback.\r\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\r\n         *  the file.\r\n         * @param [Number] offset Offset in the buffer to start reading data from.\r\n         * @param [Number] length The amount of bytes to write to the file.\r\n         * @param [Number] position Offset from the beginning of the file where this\r\n         *   data should be written. If position is null, the data will be written at\r\n         *   the current position.\r\n         * @param [Function(BrowserFS.FileError, Number, BrowserFS.node.Buffer)]\r\n         *   cb The number specifies the number of bytes written into the file.\r\n         */\r\n        write(buffer, offset, length, position, cb) {\r\n            try {\r\n                cb(null, this.writeSync(buffer, offset, length, position), buffer);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Write buffer to the file.\r\n         * Note that it is unsafe to use fs.writeSync multiple times on the same file\r\n         * without waiting for the callback.\r\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\r\n         *  the file.\r\n         * @param [Number] offset Offset in the buffer to start reading data from.\r\n         * @param [Number] length The amount of bytes to write to the file.\r\n         * @param [Number] position Offset from the beginning of the file where this\r\n         *   data should be written. If position is null, the data will be written at\r\n         *   the current position.\r\n         * @return [Number]\r\n         */\r\n        writeSync(buffer, offset, length, position) {\r\n            this._dirty = true;\r\n            if (position === undefined || position === null) {\r\n                position = this.getPos();\r\n            }\r\n            if (!this._flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a writeable mode.');\r\n            }\r\n            const endFp = position + length;\r\n            if (endFp > this._stat.size) {\r\n                this._stat.size = endFp;\r\n                if (endFp > this._buffer.length) {\r\n                    // Extend the buffer!\r\n                    const newBuff = Buffer.alloc(endFp);\r\n                    this._buffer.copy(newBuff);\r\n                    this._buffer = newBuff;\r\n                }\r\n            }\r\n            const len = buffer.copy(this._buffer, position, offset, offset + length);\r\n            this._stat.mtimeMs = Date.now();\r\n            if (this._flag.isSynchronous()) {\r\n                this.syncSync();\r\n                return len;\r\n            }\r\n            this.setPos(position + len);\r\n            return len;\r\n        }\r\n        /**\r\n         * Read data from the file.\r\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\r\n         *   written to.\r\n         * @param [Number] offset The offset within the buffer where writing will\r\n         *   start.\r\n         * @param [Number] length An integer specifying the number of bytes to read.\r\n         * @param [Number] position An integer specifying where to begin reading from\r\n         *   in the file. If position is null, data will be read from the current file\r\n         *   position.\r\n         * @param [Function(BrowserFS.FileError, Number, BrowserFS.node.Buffer)] cb The\r\n         *   number is the number of bytes read\r\n         */\r\n        read(buffer, offset, length, position, cb) {\r\n            try {\r\n                cb(null, this.readSync(buffer, offset, length, position), buffer);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Read data from the file.\r\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\r\n         *   written to.\r\n         * @param [Number] offset The offset within the buffer where writing will\r\n         *   start.\r\n         * @param [Number] length An integer specifying the number of bytes to read.\r\n         * @param [Number] position An integer specifying where to begin reading from\r\n         *   in the file. If position is null, data will be read from the current file\r\n         *   position.\r\n         * @return [Number]\r\n         */\r\n        readSync(buffer, offset, length, position) {\r\n            if (!this._flag.isReadable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a readable mode.');\r\n            }\r\n            if (position === undefined || position === null) {\r\n                position = this.getPos();\r\n            }\r\n            const endRead = position + length;\r\n            if (endRead > this._stat.size) {\r\n                length = this._stat.size - position;\r\n            }\r\n            const rv = this._buffer.copy(buffer, offset, position, position + length);\r\n            this._stat.atimeMs = Date.now();\r\n            this._pos = position + length;\r\n            return rv;\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param [Number|String] mode\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        chmod(mode, cb) {\r\n            try {\r\n                this.chmodSync(mode);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param [Number] mode\r\n         */\r\n        chmodSync(mode) {\r\n            if (!this._fs.supportsProps()) {\r\n                throw new FileError(ErrorCodes.ENOTSUP);\r\n            }\r\n            this._dirty = true;\r\n            this._stat.chmod(mode);\r\n            this.syncSync();\r\n        }\r\n        isDirty() {\r\n            return this._dirty;\r\n        }\r\n        /**\r\n         * Resets the dirty bit. Should only be called after a sync has completed successfully.\r\n         */\r\n        resetDirty() {\r\n            this._dirty = false;\r\n        }\r\n    }\r\n\r\n    return files.PreloadFile = PreloadFile;\r\n});"]}