{"version":3,"sources":["skylark-io-files.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-io-files.js","sourcesContent":["define('skylark-io-files/files',[\r\n\t\"skylark-langx-ns\"\r\n],function(skylark){\r\n\treturn skylark.attach(\"data.files\",{\r\n\t\tproviders : {\r\n\t\t\t\r\n\t\t}\r\n\t});\r\n});\ndefine('skylark-io-files/action-type',[\r\n  \"./files\"\r\n],function (files) {\r\n  'use strict';\r\n\r\n  var ActionType;\r\n  (function (ActionType) {\r\n      // Indicates that the code should not do anything.\r\n      ActionType[ActionType[\"NOP\"] = 0] = \"NOP\";\r\n      // Indicates that the code should throw an exception.\r\n      ActionType[ActionType[\"THROW_EXCEPTION\"] = 1] = \"THROW_EXCEPTION\";\r\n      // Indicates that the code should truncate the file, but only if it is a file.\r\n      ActionType[ActionType[\"TRUNCATE_FILE\"] = 2] = \"TRUNCATE_FILE\";\r\n      // Indicates that the code should create the file.\r\n      ActionType[ActionType[\"CREATE_FILE\"] = 3] = \"CREATE_FILE\";\r\n  })(ActionType || (ActionType = {}));\r\n\r\n  return files.ActionType = ActionType;\r\n});\r\n  \ndefine('skylark-io-files/error-codes',[\r\n  \"./files\"\r\n],function (files) {\r\n  'use strict';\r\n\r\n  /**\r\n   * Standard libc error codes. Add more to this enum and ErrorStrings as they are\r\n   * needed.\r\n   * @url http://www.gnu.org/software/libc/manual/html_node/Error-Codes.html\r\n   */\r\n  var ErrorCodes;\r\n  (function (ErrorCodes) {\r\n      ErrorCodes[ErrorCodes[\"EPERM\"] = 1] = \"EPERM\";\r\n      ErrorCodes[ErrorCodes[\"ENOENT\"] = 2] = \"ENOENT\";\r\n      ErrorCodes[ErrorCodes[\"EIO\"] = 5] = \"EIO\";\r\n      ErrorCodes[ErrorCodes[\"EBADF\"] = 9] = \"EBADF\";\r\n      ErrorCodes[ErrorCodes[\"EACCES\"] = 13] = \"EACCES\";\r\n      ErrorCodes[ErrorCodes[\"EBUSY\"] = 16] = \"EBUSY\";\r\n      ErrorCodes[ErrorCodes[\"EEXIST\"] = 17] = \"EEXIST\";\r\n      ErrorCodes[ErrorCodes[\"ENOTDIR\"] = 20] = \"ENOTDIR\";\r\n      ErrorCodes[ErrorCodes[\"EISDIR\"] = 21] = \"EISDIR\";\r\n      ErrorCodes[ErrorCodes[\"EINVAL\"] = 22] = \"EINVAL\";\r\n      ErrorCodes[ErrorCodes[\"EFBIG\"] = 27] = \"EFBIG\";\r\n      ErrorCodes[ErrorCodes[\"ENOSPC\"] = 28] = \"ENOSPC\";\r\n      ErrorCodes[ErrorCodes[\"EROFS\"] = 30] = \"EROFS\";\r\n      ErrorCodes[ErrorCodes[\"ENOTEMPTY\"] = 39] = \"ENOTEMPTY\";\r\n      ErrorCodes[ErrorCodes[\"ENOTSUP\"] = 95] = \"ENOTSUP\";\r\n  })(ErrorCodes || (ErrorCodes = {}));\r\n\r\n  return files.ErrorCodes = ErrorCodes;\r\n});\r\n  \ndefine('skylark-io-files/error-strings',[\r\n  \"./files\",\r\n  \"./error-codes\"\r\n],function (files,ErrorCodes) {\r\n  'use strict';\r\n\r\n  /* tslint:disable:variable-name */\r\n  /**\r\n   * Strings associated with each error code.\r\n   * @hidden\r\n   */\r\n  const ErrorStrings = {};\r\n  ErrorStrings[ErrorCodes.EPERM] = 'Operation not permitted.';\r\n  ErrorStrings[ErrorCodes.ENOENT] = 'No such file or directory.';\r\n  ErrorStrings[ErrorCodes.EIO] = 'Input/output error.';\r\n  ErrorStrings[ErrorCodes.EBADF] = 'Bad file descriptor.';\r\n  ErrorStrings[ErrorCodes.EACCES] = 'Permission denied.';\r\n  ErrorStrings[ErrorCodes.EBUSY] = 'Resource busy or locked.';\r\n  ErrorStrings[ErrorCodes.EEXIST] = 'File exists.';\r\n  ErrorStrings[ErrorCodes.ENOTDIR] = 'File is not a directory.';\r\n  ErrorStrings[ErrorCodes.EISDIR] = 'File is a directory.';\r\n  ErrorStrings[ErrorCodes.EINVAL] = 'Invalid argument.';\r\n  ErrorStrings[ErrorCodes.EFBIG] = 'File is too big.';\r\n  ErrorStrings[ErrorCodes.ENOSPC] = 'No space left on disk.';\r\n  ErrorStrings[ErrorCodes.EROFS] = 'Cannot modify a read-only file system.';\r\n  ErrorStrings[ErrorCodes.ENOTEMPTY] = 'Directory is not empty.';\r\n  ErrorStrings[ErrorCodes.ENOTSUP] = 'Operation is not supported.';\r\n\r\n  return files.ErrorStrings = ErrorStrings;\r\n});\r\n  \ndefine('skylark-io-files/file-error',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"./files\",\r\n    \"./error-codes\",\r\n    \"./error-strings\"\r\n],function (Buffer,files,ErrorCodes,ErrorStrings) {\r\n   'use strict';\r\n   \r\n\r\n    /* tslint:enable:variable-name */\r\n    /**\r\n     * Represents a BrowserFS error. Passed back to applications after a failed\r\n     * call to the BrowserFS API.\r\n     */\r\n    class FileError extends Error {\r\n        /**\r\n         * Represents a BrowserFS error. Passed back to applications after a failed\r\n         * call to the BrowserFS API.\r\n         *\r\n         * Error codes mirror those returned by regular Unix file operations, which is\r\n         * what Node returns.\r\n         * @constructor FileError\r\n         * @param type The type of the error.\r\n         * @param [message] A descriptive error message.\r\n         */\r\n        constructor(type, message = ErrorStrings[type], path) {\r\n            super(message);\r\n            // Unsupported.\r\n            this.syscall = \"\";\r\n            this.errno = type;\r\n            this.code = ErrorCodes[type];\r\n            this.path = path;\r\n            this.stack = new Error().stack;\r\n            this.message = `Error: ${this.code}: ${message}${this.path ? `, '${this.path}'` : ''}`;\r\n        }\r\n        static fromJSON(json) {\r\n            const err = new FileError(0);\r\n            err.errno = json.errno;\r\n            err.code = json.code;\r\n            err.path = json.path;\r\n            err.stack = json.stack;\r\n            err.message = json.message;\r\n            return err;\r\n        }\r\n        /**\r\n         * Creates an FileError object from a buffer.\r\n         */\r\n        static fromBuffer(buffer, i = 0) {\r\n            return FileError.fromJSON(JSON.parse(buffer.toString('utf8', i + 4, i + 4 + buffer.readUInt32LE(i))));\r\n        }\r\n        static create(code, p) {\r\n            return new FileError(code, ErrorStrings[code], p);\r\n        }\r\n        static ENOENT(path) {\r\n            return this.create(ErrorCodes.ENOENT, path);\r\n        }\r\n        static EEXIST(path) {\r\n            return this.create(ErrorCodes.EEXIST, path);\r\n        }\r\n        static EISDIR(path) {\r\n            return this.create(ErrorCodes.EISDIR, path);\r\n        }\r\n        static ENOTDIR(path) {\r\n            return this.create(ErrorCodes.ENOTDIR, path);\r\n        }\r\n        static EPERM(path) {\r\n            return this.create(ErrorCodes.EPERM, path);\r\n        }\r\n        static ENOTEMPTY(path) {\r\n            return this.create(ErrorCodes.ENOTEMPTY, path);\r\n        }\r\n        /**\r\n         * @return A friendly error message.\r\n         */\r\n        toString() {\r\n            return this.message;\r\n        }\r\n        toJSON() {\r\n            return {\r\n                errno: this.errno,\r\n                code: this.code,\r\n                path: this.path,\r\n                stack: this.stack,\r\n                message: this.message\r\n            };\r\n        }\r\n        /**\r\n         * Writes the API error into a buffer.\r\n         */\r\n        writeToBuffer(buffer = Buffer.alloc(this.bufferSize()), i = 0) {\r\n            const bytesWritten = buffer.write(JSON.stringify(this.toJSON()), i + 4);\r\n            buffer.writeUInt32LE(bytesWritten, i);\r\n            return buffer;\r\n        }\r\n        /**\r\n         * The size of the API error in buffer-form in bytes.\r\n         */\r\n        bufferSize() {\r\n            // 4 bytes for string length.\r\n            return 4 + Buffer.byteLength(JSON.stringify(this.toJSON()));\r\n        }\r\n    }\r\n\r\n    return files.FileError = FileError;\r\n\r\n});\ndefine('skylark-io-files/base-file',[\r\n    \"./files\",\r\n    './error-codes',\r\n    \"./file-error\"\r\n], function (files,ErrorCodes, FileError) {\r\n    'use strict';\r\n\r\n    /**\r\n     * Base class that contains shared implementations of functions for the file\r\n     * object.\r\n     */\r\n    class BaseFile {\r\n        sync(cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        syncSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        datasync(cb) {\r\n            this.sync(cb);\r\n        }\r\n        datasyncSync() {\r\n            return this.syncSync();\r\n        }\r\n        chown(uid, gid, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chownSync(uid, gid) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        chmod(mode, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chmodSync(mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        utimes(atime, mtime, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        utimesSync(atime, mtime) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n    }\r\n    return files.BaseFile = BaseFile;\r\n});\ndefine('skylark-io-files/file-flag',[\r\n  \"./files\",\r\n  './error-codes',\r\n  \"./file-error\",\r\n  \"./action-type\"\r\n], function (files,ErrorCodes,FileError,ActionType) {\r\n    'use strict';\r\n\r\n\r\n\r\n  /**\r\n   * Represents one of the following file flags. A convenience object.\r\n   *\r\n   * * `'r'` - Open file for reading. An exception occurs if the file does not exist.\r\n   * * `'r+'` - Open file for reading and writing. An exception occurs if the file does not exist.\r\n   * * `'rs'` - Open file for reading in synchronous mode. Instructs the filesystem to not cache writes.\r\n   * * `'rs+'` - Open file for reading and writing, and opens the file in synchronous mode.\r\n   * * `'w'` - Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\r\n   * * `'wx'` - Like 'w' but opens the file in exclusive mode.\r\n   * * `'w+'` - Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\r\n   * * `'wx+'` - Like 'w+' but opens the file in exclusive mode.\r\n   * * `'a'` - Open file for appending. The file is created if it does not exist.\r\n   * * `'ax'` - Like 'a' but opens the file in exclusive mode.\r\n   * * `'a+'` - Open file for reading and appending. The file is created if it does not exist.\r\n   * * `'ax+'` - Like 'a+' but opens the file in exclusive mode.\r\n   *\r\n   * Exclusive mode ensures that the file path is newly created.\r\n   */\r\n  class FileFlag {\r\n      /**\r\n       * This should never be called directly.\r\n       * @param modeStr The string representing the mode\r\n       * @throw when the mode string is invalid\r\n       */\r\n      constructor(flagStr) {\r\n          this.flagStr = flagStr;\r\n          if (FileFlag.validFlagStrs.indexOf(flagStr) < 0) {\r\n              throw new FileError(ErrorCodes.EINVAL, \"Invalid flag: \" + flagStr);\r\n          }\r\n      }\r\n      /**\r\n       * Get an object representing the given file flag.\r\n       * @param modeStr The string representing the flag\r\n       * @return The FileFlag object representing the flag\r\n       * @throw when the flag string is invalid\r\n       */\r\n      static getFileFlag(flagStr) {\r\n          // Check cache first.\r\n          if (FileFlag.flagCache.hasOwnProperty(flagStr)) {\r\n              return FileFlag.flagCache[flagStr];\r\n          }\r\n          return FileFlag.flagCache[flagStr] = new FileFlag(flagStr);\r\n      }\r\n      /**\r\n       * Get the underlying flag string for this flag.\r\n       */\r\n      getFlagString() {\r\n          return this.flagStr;\r\n      }\r\n      /**\r\n       * Returns true if the file is readable.\r\n       */\r\n      isReadable() {\r\n          return this.flagStr.indexOf('r') !== -1 || this.flagStr.indexOf('+') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is writeable.\r\n       */\r\n      isWriteable() {\r\n          return this.flagStr.indexOf('w') !== -1 || this.flagStr.indexOf('a') !== -1 || this.flagStr.indexOf('+') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file mode should truncate.\r\n       */\r\n      isTruncating() {\r\n          return this.flagStr.indexOf('w') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is appendable.\r\n       */\r\n      isAppendable() {\r\n          return this.flagStr.indexOf('a') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is open in synchronous mode.\r\n       */\r\n      isSynchronous() {\r\n          return this.flagStr.indexOf('s') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is open in exclusive mode.\r\n       */\r\n      isExclusive() {\r\n          return this.flagStr.indexOf('x') !== -1;\r\n      }\r\n      /**\r\n       * Returns one of the static fields on this object that indicates the\r\n       * appropriate response to the path existing.\r\n       */\r\n      pathExistsAction() {\r\n          if (this.isExclusive()) {\r\n              return ActionType.THROW_EXCEPTION;\r\n          }\r\n          else if (this.isTruncating()) {\r\n              return ActionType.TRUNCATE_FILE;\r\n          }\r\n          else {\r\n              return ActionType.NOP;\r\n          }\r\n      }\r\n      /**\r\n       * Returns one of the static fields on this object that indicates the\r\n       * appropriate response to the path not existing.\r\n       */\r\n      pathNotExistsAction() {\r\n          if ((this.isWriteable() || this.isAppendable()) && this.flagStr !== 'r+') {\r\n              return ActionType.CREATE_FILE;\r\n          }\r\n          else {\r\n              return ActionType.THROW_EXCEPTION;\r\n          }\r\n      }\r\n  }\r\n  // Contains cached FileMode instances.\r\n  FileFlag.flagCache = {};\r\n  // Array of valid mode strings.\r\n  FileFlag.validFlagStrs = ['r', 'r+', 'rs', 'rs+', 'w', 'wx', 'w+', 'wx+', 'a', 'ax', 'a+', 'ax+'];\r\n\r\n\r\n\r\n  return files.FileFlag = FileFlag;\r\n});\ndefine('skylark-io-files/file-type',[\r\n  \"./files\"\r\n],function (files) {\r\n  'use strict';\r\n\r\n  /**\r\n    * Indicates the type of the given file. Applied to 'mode'.\r\n    */\r\n  var FileType;\r\n  (function (FileType) {\r\n      FileType[FileType[\"FILE\"] = 32768] = \"FILE\";\r\n      FileType[FileType[\"DIRECTORY\"] = 16384] = \"DIRECTORY\";\r\n      FileType[FileType[\"SYMLINK\"] = 40960] = \"SYMLINK\";\r\n  })(FileType || (FileType = {}));\r\n\r\n  return files.FileType = FileType;\r\n});\r\n  \ndefine('skylark-io-files/stats',[\r\n    'skylark-langx-binary/buffer',\r\n    \"./files\",\r\n    \"./file-type\"\r\n],function (Buffer,files,FileType) {\r\n    'use strict';\r\n\r\n    /**\r\n     * Emulation of Node's `fs.Stats` object.\r\n     *\r\n     * Attribute descriptions are from `man 2 stat'\r\n     * @see http://nodejs.org/api/fs.html#fs_class_fs_stats\r\n     * @see http://man7.org/linux/man-pages/man2/stat.2.html\r\n     */\r\n    class Stats {\r\n        /**\r\n         * Provides information about a particular entry in the file system.\r\n         * @param itemType Type of the item (FILE, DIRECTORY, SYMLINK, or SOCKET)\r\n         * @param size Size of the item in bytes. For directories/symlinks,\r\n         *   this is normally the size of the struct that represents the item.\r\n         * @param mode Unix-style file mode (e.g. 0o644)\r\n         * @param atimeMs time of last access, in milliseconds since epoch\r\n         * @param mtimeMs time of last modification, in milliseconds since epoch\r\n         * @param ctimeMs time of last time file status was changed, in milliseconds since epoch\r\n         * @param birthtimeMs time of file creation, in milliseconds since epoch\r\n         */\r\n        constructor(itemType, size, mode, atimeMs, mtimeMs, ctimeMs, birthtimeMs) {\r\n            /**\r\n             * UNSUPPORTED ATTRIBUTES\r\n             * I assume no one is going to need these details, although we could fake\r\n             * appropriate values if need be.\r\n             */\r\n            // ID of device containing file\r\n            this.dev = 0;\r\n            // inode number\r\n            this.ino = 0;\r\n            // device ID (if special file)\r\n            this.rdev = 0;\r\n            // number of hard links\r\n            this.nlink = 1;\r\n            // blocksize for file system I/O\r\n            this.blksize = 4096;\r\n            // @todo Maybe support these? atm, it's a one-user filesystem.\r\n            // user ID of owner\r\n            this.uid = 0;\r\n            // group ID of owner\r\n            this.gid = 0;\r\n            // XXX: Some file systems stash data on stats objects.\r\n            this.fileData = null;\r\n            this.size = size;\r\n            let currentTime = 0;\r\n            if (typeof (atimeMs) !== 'number') {\r\n                currentTime = Date.now();\r\n                atimeMs = currentTime;\r\n            }\r\n            if (typeof (mtimeMs) !== 'number') {\r\n                if (!currentTime) {\r\n                    currentTime = Date.now();\r\n                }\r\n                mtimeMs = currentTime;\r\n            }\r\n            if (typeof (ctimeMs) !== 'number') {\r\n                if (!currentTime) {\r\n                    currentTime = Date.now();\r\n                }\r\n                ctimeMs = currentTime;\r\n            }\r\n            if (typeof (birthtimeMs) !== 'number') {\r\n                if (!currentTime) {\r\n                    currentTime = Date.now();\r\n                }\r\n                birthtimeMs = currentTime;\r\n            }\r\n            this.atimeMs = atimeMs;\r\n            this.ctimeMs = ctimeMs;\r\n            this.mtimeMs = mtimeMs;\r\n            this.birthtimeMs = birthtimeMs;\r\n            if (!mode) {\r\n                switch (itemType) {\r\n                    case FileType.FILE:\r\n                        this.mode = 0x1a4;\r\n                        break;\r\n                    case FileType.DIRECTORY:\r\n                    default:\r\n                        this.mode = 0x1ff;\r\n                }\r\n            }\r\n            else {\r\n                this.mode = mode;\r\n            }\r\n            // number of 512B blocks allocated\r\n            this.blocks = Math.ceil(size / 512);\r\n            // Check if mode also includes top-most bits, which indicate the file's\r\n            // type.\r\n            if (this.mode < 0x1000) {\r\n                this.mode |= itemType;\r\n            }\r\n        }\r\n        static fromBuffer(buffer) {\r\n            const size = buffer.readUInt32LE(0), mode = buffer.readUInt32LE(4), atime = buffer.readDoubleLE(8), mtime = buffer.readDoubleLE(16), ctime = buffer.readDoubleLE(24);\r\n            return new Stats(mode & 0xF000, size, mode & 0xFFF, atime, mtime, ctime);\r\n        }\r\n        /**\r\n         * Clones the stats object.\r\n         */\r\n        static clone(s) {\r\n            return new Stats(s.mode & 0xF000, s.size, s.mode & 0xFFF, s.atimeMs, s.mtimeMs, s.ctimeMs, s.birthtimeMs);\r\n        }\r\n        get atime() {\r\n            return new Date(this.atimeMs);\r\n        }\r\n        get mtime() {\r\n            return new Date(this.mtimeMs);\r\n        }\r\n        get ctime() {\r\n            return new Date(this.ctimeMs);\r\n        }\r\n        get birthtime() {\r\n            return new Date(this.birthtimeMs);\r\n        }\r\n        toBuffer() {\r\n            const buffer = Buffer.alloc(32);\r\n            buffer.writeUInt32LE(this.size, 0);\r\n            buffer.writeUInt32LE(this.mode, 4);\r\n            buffer.writeDoubleLE(this.atime.getTime(), 8);\r\n            buffer.writeDoubleLE(this.mtime.getTime(), 16);\r\n            buffer.writeDoubleLE(this.ctime.getTime(), 24);\r\n            return buffer;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a file.\r\n         */\r\n        isFile() {\r\n            return (this.mode & 0xF000) === FileType.FILE;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a directory.\r\n         */\r\n        isDirectory() {\r\n            return (this.mode & 0xF000) === FileType.DIRECTORY;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a symbolic link (only valid through lstat)\r\n         */\r\n        isSymbolicLink() {\r\n            return (this.mode & 0xF000) === FileType.SYMLINK;\r\n        }\r\n        /**\r\n         * Change the mode of the file. We use this helper function to prevent messing\r\n         * up the type of the file, which is encoded in mode.\r\n         */\r\n        chmod(mode) {\r\n            this.mode = (this.mode & 0xF000) | mode;\r\n        }\r\n        // We don't support the following types of files.\r\n        isSocket() {\r\n            return false;\r\n        }\r\n        isBlockDevice() {\r\n            return false;\r\n        }\r\n        isCharacterDevice() {\r\n            return false;\r\n        }\r\n        isFIFO() {\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    return files.Stats = Stats;\r\n});\ndefine('skylark-io-files/file-system',[\r\n    \"skylark-langx-funcs/defer\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"./files\",\r\n    './error-codes',\r\n    \"./file-error\",\r\n    './file-flag',\r\n    './stats'\r\n], function (setImmediate,Buffer, paths, files,ErrorCodes,FileError, FileFlag,  Stats) {\r\n    'use strict';\r\n\r\n\r\n    /** Used for unit testing. Defaults to a NOP. */\r\n    let wrapCbHook = function (cb, numArgs) {\r\n        return cb;\r\n    };\r\n    /**\r\n     * Wraps a callback function, ensuring it is invoked through setImmediate.\r\n     * @hidden\r\n     */\r\n    function wrapCb(cb, numArgs) {\r\n        if (typeof cb !== 'function') {\r\n            throw new Error('Callback must be a function.');\r\n        }\r\n        const hookedCb = wrapCbHook(cb, numArgs);\r\n        // We could use `arguments`, but Function.call/apply is expensive. And we only\r\n        // need to handle 1-3 arguments\r\n        switch (numArgs) {\r\n            case 1:\r\n                return function (arg1) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1);\r\n                    });\r\n                };\r\n            case 2:\r\n                return function (arg1, arg2) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1, arg2);\r\n                    });\r\n                };\r\n            case 3:\r\n                return function (arg1, arg2, arg3) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1, arg2, arg3);\r\n                    });\r\n                };\r\n            default:\r\n                throw new Error('Invalid invocation of wrapCb.');\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function assertRoot(fs) {\r\n        if (fs) {\r\n            return fs;\r\n        }\r\n        throw new FileError(ErrorCodes.EIO, `Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)`);\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeMode(mode, def) {\r\n        switch (typeof mode) {\r\n            case 'number':\r\n                // (path, flag, mode, cb?)\r\n                return mode;\r\n            case 'string':\r\n                // (path, flag, modeString, cb?)\r\n                const trueMode = parseInt(mode, 8);\r\n                if (!isNaN(trueMode)) {\r\n                    return trueMode;\r\n                }\r\n                // Invalid string.\r\n                return def;\r\n            default:\r\n                return def;\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeTime(time) {\r\n        if (time instanceof Date) {\r\n            return time;\r\n        }\r\n        else if (typeof time === 'number') {\r\n            return new Date(time * 1000);\r\n        }\r\n        else {\r\n            throw new FileError(ErrorCodes.EINVAL, `Invalid time.`);\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizePath(p) {\r\n        // Node doesn't allow null characters in paths.\r\n        if (p.indexOf('\\u0000') >= 0) {\r\n            throw new FileError(ErrorCodes.EINVAL, 'Path must be a string without null bytes.');\r\n        }\r\n        else if (p === '') {\r\n            throw new FileError(ErrorCodes.EINVAL, 'Path must not be empty.');\r\n        }\r\n        return paths.resolve(p);\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeOptions(options, defEnc, defFlag, defMode) {\r\n        // typeof null === 'object' so special-case handing is needed.\r\n        switch (options === null ? 'null' : typeof options) {\r\n            case 'object':\r\n                return {\r\n                    encoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,\r\n                    flag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,\r\n                    mode: normalizeMode(options['mode'], defMode)\r\n                };\r\n            case 'string':\r\n                return {\r\n                    encoding: options,\r\n                    flag: defFlag,\r\n                    mode: defMode\r\n                };\r\n            case 'null':\r\n            case 'undefined':\r\n            case 'function':\r\n                return {\r\n                    encoding: defEnc,\r\n                    flag: defFlag,\r\n                    mode: defMode\r\n                };\r\n            default:\r\n                throw new TypeError(`\"options\" must be a string or an object, got ${typeof options} instead.`);\r\n        }\r\n    }\r\n    /**\r\n     * The default callback is a NOP.\r\n     * @hidden\r\n     * @private\r\n     */\r\n    function nopCb() {\r\n        // NOP.\r\n    }\r\n    /**\r\n     * The node frontend to all filesystems.\r\n     * This layer handles:\r\n     *\r\n     * * Sanity checking inputs.\r\n     * * Normalizing paths.\r\n     * * Resetting stack depth for asynchronous operations which may not go through\r\n     *   the browser by wrapping all input callbacks using `setImmediate`.\r\n     * * Performing the requested operation through the filesystem or the file\r\n     *   descriptor, as appropriate.\r\n     * * Handling optional arguments and setting default arguments.\r\n     * @see http://nodejs.org/api/fs.html\r\n     */\r\n    class FileSystem {\r\n        constructor() {\r\n            /* tslint:enable:variable-name */\r\n            this.F_OK = 0;\r\n            this.R_OK = 4;\r\n            this.W_OK = 2;\r\n            this.X_OK = 1;\r\n            this.root = null;\r\n            this.fdMap = {};\r\n            this.nextFd = 100;\r\n        }\r\n        initialize(rootFS) {\r\n            if (!rootFS.constructor.isAvailable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Tried to instantiate BrowserFS with an unavailable file system.');\r\n            }\r\n            return this.root = rootFS;\r\n        }\r\n        /**\r\n         * converts Date or number to a fractional UNIX timestamp\r\n         * Grabbed from NodeJS sources (lib/fs.js)\r\n         */\r\n        _toUnixTimestamp(time) {\r\n            if (typeof time === 'number') {\r\n                return time;\r\n            }\r\n            else if (time instanceof Date) {\r\n                return time.getTime() / 1000;\r\n            }\r\n            throw new Error(\"Cannot parse time: \" + time);\r\n        }\r\n        /**\r\n         * **NONSTANDARD**: Grab the FileSystem instance that backs this API.\r\n         * @return [BrowserFS.FileSystem | null] Returns null if the file system has\r\n         *   not been initialized.\r\n         */\r\n        getRootFS() {\r\n            if (this.root) {\r\n                return this.root;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        // FILE OR DIRECTORY METHODS\r\n        /**\r\n         * Asynchronous rename. No arguments other than a possible exception are given\r\n         * to the completion callback.\r\n         * @param oldPath\r\n         * @param newPath\r\n         * @param callback\r\n         */\r\n        rename(oldPath, newPath, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                assertRoot(this.root).rename(normalizePath(oldPath), normalizePath(newPath), newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous rename.\r\n         * @param oldPath\r\n         * @param newPath\r\n         */\r\n        renameSync(oldPath, newPath) {\r\n            assertRoot(this.root).renameSync(normalizePath(oldPath), normalizePath(newPath));\r\n        }\r\n        /**\r\n         * Test whether or not the given path exists by checking with the file system.\r\n         * Then call the callback argument with either true or false.\r\n         * @example Sample invocation\r\n         *   fs.exists('/etc/passwd', function (exists) {\r\n         *     util.debug(exists ? \"it's there\" : \"no passwd!\");\r\n         *   });\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        exists(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                return assertRoot(this.root).exists(normalizePath(path), newCb);\r\n            }\r\n            catch (e) {\r\n                // Doesn't return an error. If something bad happens, we assume it just\r\n                // doesn't exist.\r\n                return newCb(false);\r\n            }\r\n        }\r\n        /**\r\n         * Test whether or not the given path exists by checking with the file system.\r\n         * @param path\r\n         * @return [boolean]\r\n         */\r\n        existsSync(path) {\r\n            try {\r\n                return assertRoot(this.root).existsSync(normalizePath(path));\r\n            }\r\n            catch (e) {\r\n                // Doesn't return an error. If something bad happens, we assume it just\r\n                // doesn't exist.\r\n                return false;\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `stat`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        stat(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                return assertRoot(this.root).stat(normalizePath(path), false, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `stat`.\r\n         * @param path\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        statSync(path) {\r\n            return assertRoot(this.root).statSync(normalizePath(path), false);\r\n        }\r\n        /**\r\n         * Asynchronous `lstat`.\r\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\r\n         * then the link itself is stat-ed, not the file that it refers to.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        lstat(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                return assertRoot(this.root).stat(normalizePath(path), true, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lstat`.\r\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\r\n         * then the link itself is stat-ed, not the file that it refers to.\r\n         * @param path\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        lstatSync(path) {\r\n            return assertRoot(this.root).statSync(normalizePath(path), true);\r\n        }\r\n        truncate(path, arg2 = 0, cb = nopCb) {\r\n            let len = 0;\r\n            if (typeof arg2 === 'function') {\r\n                cb = arg2;\r\n            }\r\n            else if (typeof arg2 === 'number') {\r\n                len = arg2;\r\n            }\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                if (len < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL);\r\n                }\r\n                return assertRoot(this.root).truncate(normalizePath(path), len, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `truncate`.\r\n         * @param path\r\n         * @param len\r\n         */\r\n        truncateSync(path, len = 0) {\r\n            if (len < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL);\r\n            }\r\n            return assertRoot(this.root).truncateSync(normalizePath(path), len);\r\n        }\r\n        /**\r\n         * Asynchronous `unlink`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        unlink(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                return assertRoot(this.root).unlink(normalizePath(path), newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `unlink`.\r\n         * @param path\r\n         */\r\n        unlinkSync(path) {\r\n            return assertRoot(this.root).unlinkSync(normalizePath(path));\r\n        }\r\n        open(path, flag, arg2, cb = nopCb) {\r\n            const mode = normalizeMode(arg2, 0x1a4);\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                assertRoot(this.root).open(normalizePath(path), FileFlag.getFileFlag(flag), mode, (e, file) => {\r\n                    if (file) {\r\n                        newCb(e, this.getFdForFile(file));\r\n                    }\r\n                    else {\r\n                        newCb(e);\r\n                    }\r\n                });\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous file open.\r\n         * @see http://www.manpagez.com/man/2/open/\r\n         * @param path\r\n         * @param flags\r\n         * @param mode defaults to `0644`\r\n         * @return [BrowserFS.File]\r\n         */\r\n        openSync(path, flag, mode = 0x1a4) {\r\n            return this.getFdForFile(assertRoot(this.root).openSync(normalizePath(path), FileFlag.getFileFlag(flag), normalizeMode(mode, 0x1a4)));\r\n        }\r\n        readFile(filename, arg2 = {}, cb = nopCb) {\r\n            const options = normalizeOptions(arg2, null, 'r', null);\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options['flag']);\r\n                if (!flag.isReadable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to readFile must allow for reading.'));\r\n                }\r\n                return assertRoot(this.root).readFile(normalizePath(filename), options.encoding, flag, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        readFileSync(filename, arg2 = {}) {\r\n            const options = normalizeOptions(arg2, null, 'r', null);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isReadable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to readFile must allow for reading.');\r\n            }\r\n            return assertRoot(this.root).readFileSync(normalizePath(filename), options.encoding, flag);\r\n        }\r\n        writeFile(filename, data, arg3 = {}, cb = nopCb) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options.flag);\r\n                if (!flag.isWriteable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to writeFile must allow for writing.'));\r\n                }\r\n                return assertRoot(this.root).writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        writeFileSync(filename, data, arg3) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to writeFile must allow for writing.');\r\n            }\r\n            return assertRoot(this.root).writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\r\n        }\r\n        appendFile(filename, data, arg3, cb = nopCb) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options.flag);\r\n                if (!flag.isAppendable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to appendFile must allow for appending.'));\r\n                }\r\n                assertRoot(this.root).appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        appendFileSync(filename, data, arg3) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isAppendable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to appendFile must allow for appending.');\r\n            }\r\n            return assertRoot(this.root).appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\r\n        }\r\n        // FILE DESCRIPTOR METHODS\r\n        /**\r\n         * Asynchronous `fstat`.\r\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\n         * specified by the file descriptor `fd`.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fstat(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                file.stat(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fstat`.\r\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\n         * specified by the file descriptor `fd`.\r\n         * @param fd\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        fstatSync(fd) {\r\n            return this.fd2file(fd).statSync();\r\n        }\r\n        /**\r\n         * Asynchronous close.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        close(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).close((e) => {\r\n                    if (!e) {\r\n                        this.closeFd(fd);\r\n                    }\r\n                    newCb(e);\r\n                });\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous close.\r\n         * @param fd\r\n         */\r\n        closeSync(fd) {\r\n            this.fd2file(fd).closeSync();\r\n            this.closeFd(fd);\r\n        }\r\n        ftruncate(fd, arg2, cb = nopCb) {\r\n            const length = typeof arg2 === 'number' ? arg2 : 0;\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (length < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL);\r\n                }\r\n                file.truncate(length, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous ftruncate.\r\n         * @param fd\r\n         * @param len\r\n         */\r\n        ftruncateSync(fd, len = 0) {\r\n            const file = this.fd2file(fd);\r\n            if (len < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL);\r\n            }\r\n            file.truncateSync(len);\r\n        }\r\n        /**\r\n         * Asynchronous fsync.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fsync(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).sync(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous fsync.\r\n         * @param fd\r\n         */\r\n        fsyncSync(fd) {\r\n            this.fd2file(fd).syncSync();\r\n        }\r\n        /**\r\n         * Asynchronous fdatasync.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fdatasync(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).datasync(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous fdatasync.\r\n         * @param fd\r\n         */\r\n        fdatasyncSync(fd) {\r\n            this.fd2file(fd).datasyncSync();\r\n        }\r\n        write(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\r\n            let buffer, offset, length, position = null;\r\n            if (typeof arg2 === 'string') {\r\n                // Signature 1: (fd, string, [position?, [encoding?]], cb?)\r\n                let encoding = 'utf8';\r\n                switch (typeof arg3) {\r\n                    case 'function':\r\n                        // (fd, string, cb)\r\n                        cb = arg3;\r\n                        break;\r\n                    case 'number':\r\n                        // (fd, string, position, encoding?, cb?)\r\n                        position = arg3;\r\n                        encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\r\n                        cb = typeof arg5 === 'function' ? arg5 : cb;\r\n                        break;\r\n                    default:\r\n                        // ...try to find the callback and get out of here!\r\n                        cb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, 'Invalid arguments.'));\r\n                }\r\n                buffer = Buffer.from(arg2, encoding);\r\n                offset = 0;\r\n                length = buffer.length;\r\n            }\r\n            else {\r\n                // Signature 2: (fd, buffer, offset, length, position?, cb?)\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = typeof arg5 === 'number' ? arg5 : null;\r\n                cb = typeof arg5 === 'function' ? arg5 : cb;\r\n            }\r\n            const newCb = wrapCb(cb, 3);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (position === undefined || position === null) {\r\n                    position = file.getPos();\r\n                }\r\n                file.write(buffer, offset, length, position, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        writeSync(fd, arg2, arg3, arg4, arg5) {\r\n            let buffer, offset = 0, length, position;\r\n            if (typeof arg2 === 'string') {\r\n                // Signature 1: (fd, string, [position?, [encoding?]])\r\n                position = typeof arg3 === 'number' ? arg3 : null;\r\n                const encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\r\n                offset = 0;\r\n                buffer = Buffer.from(arg2, encoding);\r\n                length = buffer.length;\r\n            }\r\n            else {\r\n                // Signature 2: (fd, buffer, offset, length, position?)\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = typeof arg5 === 'number' ? arg5 : null;\r\n            }\r\n            const file = this.fd2file(fd);\r\n            if (position === undefined || position === null) {\r\n                position = file.getPos();\r\n            }\r\n            return file.writeSync(buffer, offset, length, position);\r\n        }\r\n        read(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\r\n            let position, offset, length, buffer, newCb;\r\n            if (typeof arg2 === 'number') {\r\n                // legacy interface\r\n                // (fd, length, position, encoding, callback)\r\n                length = arg2;\r\n                position = arg3;\r\n                const encoding = arg4;\r\n                cb = typeof arg5 === 'function' ? arg5 : cb;\r\n                offset = 0;\r\n                buffer = Buffer.alloc(length);\r\n                // XXX: Inefficient.\r\n                // Wrap the cb so we shelter upper layers of the API from these\r\n                // shenanigans.\r\n                newCb = wrapCb((err, bytesRead, buf) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    cb(err, buf.toString(encoding), bytesRead);\r\n                }, 3);\r\n            }\r\n            else {\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = arg5;\r\n                newCb = wrapCb(cb, 3);\r\n            }\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (position === undefined || position === null) {\r\n                    position = file.getPos();\r\n                }\r\n                file.read(buffer, offset, length, position, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        readSync(fd, arg2, arg3, arg4, arg5) {\r\n            let shenanigans = false;\r\n            let buffer, offset, length, position, encoding = 'utf8';\r\n            if (typeof arg2 === 'number') {\r\n                length = arg2;\r\n                position = arg3;\r\n                encoding = arg4;\r\n                offset = 0;\r\n                buffer = Buffer.alloc(length);\r\n                shenanigans = true;\r\n            }\r\n            else {\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = arg5;\r\n            }\r\n            const file = this.fd2file(fd);\r\n            if (position === undefined || position === null) {\r\n                position = file.getPos();\r\n            }\r\n            const rv = file.readSync(buffer, offset, length, position);\r\n            if (!shenanigans) {\r\n                return rv;\r\n            }\r\n            else {\r\n                return [buffer.toString(encoding), rv];\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `fchown`.\r\n         * @param fd\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        fchown(fd, uid, gid, callback = nopCb) {\r\n            const newCb = wrapCb(callback, 1);\r\n            try {\r\n                this.fd2file(fd).chown(uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fchown`.\r\n         * @param fd\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        fchownSync(fd, uid, gid) {\r\n            this.fd2file(fd).chownSync(uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param fd\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        fchmod(fd, mode, cb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\r\n                this.fd2file(fd).chmod(numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fchmod`.\r\n         * @param fd\r\n         * @param mode\r\n         */\r\n        fchmodSync(fd, mode) {\r\n            const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\r\n            this.fd2file(fd).chmodSync(numMode);\r\n        }\r\n        /**\r\n         * Change the file timestamps of a file referenced by the supplied file\r\n         * descriptor.\r\n         * @param fd\r\n         * @param atime\r\n         * @param mtime\r\n         * @param callback\r\n         */\r\n        futimes(fd, atime, mtime, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (typeof atime === 'number') {\r\n                    atime = new Date(atime * 1000);\r\n                }\r\n                if (typeof mtime === 'number') {\r\n                    mtime = new Date(mtime * 1000);\r\n                }\r\n                file.utimes(atime, mtime, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Change the file timestamps of a file referenced by the supplied file\r\n         * descriptor.\r\n         * @param fd\r\n         * @param atime\r\n         * @param mtime\r\n         */\r\n        futimesSync(fd, atime, mtime) {\r\n            this.fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));\r\n        }\r\n        // DIRECTORY-ONLY METHODS\r\n        /**\r\n         * Asynchronous `rmdir`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        rmdir(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).rmdir(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `rmdir`.\r\n         * @param path\r\n         */\r\n        rmdirSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).rmdirSync(path);\r\n        }\r\n        /**\r\n         * Asynchronous `mkdir`.\r\n         * @param path\r\n         * @param mode defaults to `0777`\r\n         * @param callback\r\n         */\r\n        mkdir(path, mode, cb = nopCb) {\r\n            if (typeof mode === 'function') {\r\n                cb = mode;\r\n                mode = 0x1ff;\r\n            }\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).mkdir(path, mode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `mkdir`.\r\n         * @param path\r\n         * @param mode defaults to `0777`\r\n         */\r\n        mkdirSync(path, mode) {\r\n            assertRoot(this.root).mkdirSync(normalizePath(path), normalizeMode(mode, 0x1ff));\r\n        }\r\n        /**\r\n         * Asynchronous `readdir`. Reads the contents of a directory.\r\n         * The callback gets two arguments `(err, files)` where `files` is an array of\r\n         * the names of the files in the directory excluding `'.'` and `'..'`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        readdir(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).readdir(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `readdir`. Reads the contents of a directory.\r\n         * @param path\r\n         * @return [String[]]\r\n         */\r\n        readdirSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).readdirSync(path);\r\n        }\r\n        // SYMLINK METHODS\r\n        /**\r\n         * Asynchronous `link`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         * @param callback\r\n         */\r\n        link(srcpath, dstpath, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                srcpath = normalizePath(srcpath);\r\n                dstpath = normalizePath(dstpath);\r\n                assertRoot(this.root).link(srcpath, dstpath, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `link`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         */\r\n        linkSync(srcpath, dstpath) {\r\n            srcpath = normalizePath(srcpath);\r\n            dstpath = normalizePath(dstpath);\r\n            return assertRoot(this.root).linkSync(srcpath, dstpath);\r\n        }\r\n        symlink(srcpath, dstpath, arg3, cb = nopCb) {\r\n            const type = typeof arg3 === 'string' ? arg3 : 'file';\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                if (type !== 'file' && type !== 'dir') {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, \"Invalid type: \" + type));\r\n                }\r\n                srcpath = normalizePath(srcpath);\r\n                dstpath = normalizePath(dstpath);\r\n                assertRoot(this.root).symlink(srcpath, dstpath, type, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `symlink`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         * @param type can be either `'dir'` or `'file'` (default is `'file'`)\r\n         */\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            if (!type) {\r\n                type = 'file';\r\n            }\r\n            else if (type !== 'file' && type !== 'dir') {\r\n                throw new FileError(ErrorCodes.EINVAL, \"Invalid type: \" + type);\r\n            }\r\n            srcpath = normalizePath(srcpath);\r\n            dstpath = normalizePath(dstpath);\r\n            return assertRoot(this.root).symlinkSync(srcpath, dstpath, type);\r\n        }\r\n        /**\r\n         * Asynchronous readlink.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        readlink(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).readlink(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous readlink.\r\n         * @param path\r\n         * @return [String]\r\n         */\r\n        readlinkSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).readlinkSync(path);\r\n        }\r\n        // PROPERTY OPERATIONS\r\n        /**\r\n         * Asynchronous `chown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        chown(path, uid, gid, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).chown(path, false, uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `chown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        chownSync(path, uid, gid) {\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chownSync(path, false, uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `lchown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        lchown(path, uid, gid, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).chown(path, true, uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lchown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        lchownSync(path, uid, gid) {\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chownSync(path, true, uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `chmod`.\r\n         * @param path\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        chmod(path, mode, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = normalizeMode(mode, -1);\r\n                if (numMode < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n                }\r\n                assertRoot(this.root).chmod(normalizePath(path), false, numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `chmod`.\r\n         * @param path\r\n         * @param mode\r\n         */\r\n        chmodSync(path, mode) {\r\n            const numMode = normalizeMode(mode, -1);\r\n            if (numMode < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n            }\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chmodSync(path, false, numMode);\r\n        }\r\n        /**\r\n         * Asynchronous `lchmod`.\r\n         * @param path\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        lchmod(path, mode, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = normalizeMode(mode, -1);\r\n                if (numMode < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n                }\r\n                assertRoot(this.root).chmod(normalizePath(path), true, numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lchmod`.\r\n         * @param path\r\n         * @param mode\r\n         */\r\n        lchmodSync(path, mode) {\r\n            const numMode = normalizeMode(mode, -1);\r\n            if (numMode < 1) {\r\n                throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n            }\r\n            assertRoot(this.root).chmodSync(normalizePath(path), true, numMode);\r\n        }\r\n        /**\r\n         * Change file timestamps of the file referenced by the supplied path.\r\n         * @param path\r\n         * @param atime\r\n         * @param mtime\r\n         * @param callback\r\n         */\r\n        utimes(path, atime, mtime, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                assertRoot(this.root).utimes(normalizePath(path), normalizeTime(atime), normalizeTime(mtime), newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Change file timestamps of the file referenced by the supplied path.\r\n         * @param path\r\n         * @param atime\r\n         * @param mtime\r\n         */\r\n        utimesSync(path, atime, mtime) {\r\n            assertRoot(this.root).utimesSync(normalizePath(path), normalizeTime(atime), normalizeTime(mtime));\r\n        }\r\n        realpath(path, arg2, cb = nopCb) {\r\n            const cache = typeof (arg2) === 'object' ? arg2 : {};\r\n            cb = typeof (arg2) === 'function' ? arg2 : nopCb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).realpath(path, cache, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `realpath`.\r\n         * @param path\r\n         * @param cache An object literal of mapped paths that can be used to\r\n         *   force a specific path resolution or avoid additional `fs.stat` calls for\r\n         *   known real paths.\r\n         * @return [String]\r\n         */\r\n        realpathSync(path, cache = {}) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).realpathSync(path, cache);\r\n        }\r\n        watchFile(filename, arg2, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        unwatchFile(filename, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        watch(filename, arg2, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        access(path, arg2, cb = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        accessSync(path, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        createReadStream(path, options) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        createWriteStream(path, options) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * For unit testing. Passes all incoming callbacks to cbWrapper for wrapping.\r\n         */\r\n        wrapCallbacks(cbWrapper) {\r\n            wrapCbHook = cbWrapper;\r\n        }\r\n        getFdForFile(file) {\r\n            const fd = this.nextFd++;\r\n            this.fdMap[fd] = file;\r\n            return fd;\r\n        }\r\n        fd2file(fd) {\r\n            const rv = this.fdMap[fd];\r\n            if (rv) {\r\n                return rv;\r\n            }\r\n            else {\r\n                throw new FileError(ErrorCodes.EBADF, 'Invalid file descriptor.');\r\n            }\r\n        }\r\n        closeFd(fd) {\r\n            delete this.fdMap[fd];\r\n        }\r\n    }\r\n    \r\n    return files.FileSystem = FileSystem;\r\n});\ndefine('skylark-io-files/utils',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    './file-error',\r\n    './error-codes'\r\n], function (Buffer,paths, FileError, ErrorCodes) {\r\n    'use strict';\r\n\r\n    function deprecationMessage(print, fsName, opts) {\r\n        if (print) {\r\n            // tslint:disable-next-line:no-console\r\n            console.warn(`[${fsName}] Direct file system constructor usage is deprecated for this file system, and will be removed in the next major version. Please use the '${fsName}.Create(${JSON.stringify(opts)}, callback)' method instead. See https://github.com/jvilk/BrowserFS/issues/176 for more details.`);\r\n            // tslint:enable-next-line:no-console\r\n        }\r\n    }\r\n    /**\r\n     * Checks for any IE version, including IE11 which removed MSIE from the\r\n     * userAgent string.\r\n     * @hidden\r\n     */\r\n    const isIE = typeof navigator !== \"undefined\" && !!(/(msie) ([\\w.]+)/.exec(navigator.userAgent.toLowerCase()) || navigator.userAgent.indexOf('Trident') !== -1);\r\n    /**\r\n     * Check if we're in a web worker.\r\n     * @hidden\r\n     */\r\n    const isWebWorker = typeof window === \"undefined\";\r\n    /**\r\n     * Throws an exception. Called on code paths that should be impossible.\r\n     * @hidden\r\n     */\r\n    function fail() {\r\n        throw new Error(\"BFS has reached an impossible code path; please file a bug.\");\r\n    }\r\n    /**\r\n     * Synchronous recursive makedir.\r\n     * @hidden\r\n     */\r\n    function mkdirpSync(p, mode, fs) {\r\n        if (!fs.existsSync(p)) {\r\n            mkdirpSync(paths.dirname(p), mode, fs);\r\n            fs.mkdirSync(p, mode);\r\n        }\r\n    }\r\n    /**\r\n     * Converts a buffer into an array buffer. Attempts to do so in a\r\n     * zero-copy manner, e.g. the array references the same memory.\r\n     * @hidden\r\n     */\r\n    function buffer2ArrayBuffer(buff) {\r\n        const u8 = buffer2Uint8array(buff), u8offset = u8.byteOffset, u8Len = u8.byteLength;\r\n        if (u8offset === 0 && u8Len === u8.buffer.byteLength) {\r\n            return u8.buffer;\r\n        }\r\n        else {\r\n            return u8.buffer.slice(u8offset, u8offset + u8Len);\r\n        }\r\n    }\r\n    /**\r\n     * Converts a buffer into a Uint8Array. Attempts to do so in a\r\n     * zero-copy manner, e.g. the array references the same memory.\r\n     * @hidden\r\n     */\r\n    function buffer2Uint8array(buff) {\r\n        if (buff instanceof Uint8Array) {\r\n            // BFS & Node v4.0 buffers *are* Uint8Arrays.\r\n            return buff;\r\n        }\r\n        else {\r\n            // Uint8Arrays can be constructed from arrayish numbers.\r\n            // At this point, we assume this isn't a BFS array.\r\n            return new Uint8Array(buff);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given arrayish object into a Buffer. Attempts to\r\n     * be zero-copy.\r\n     * @hidden\r\n     */\r\n    function arrayish2Buffer(arr) {\r\n        if (arr instanceof Buffer) {\r\n            return arr;\r\n        }\r\n        else if (arr instanceof Uint8Array) {\r\n            return uint8Array2Buffer(arr);\r\n        }\r\n        else {\r\n            return Buffer.from(arr);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given Uint8Array into a Buffer. Attempts to be zero-copy.\r\n     * @hidden\r\n     */\r\n    function uint8Array2Buffer(u8) {\r\n        if (u8 instanceof Buffer) {\r\n            return u8;\r\n        }\r\n        else if (u8.byteOffset === 0 && u8.byteLength === u8.buffer.byteLength) {\r\n            return arrayBuffer2Buffer(u8.buffer);\r\n        }\r\n        else {\r\n            return Buffer.from(u8.buffer, u8.byteOffset, u8.byteLength);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given array buffer into a Buffer. Attempts to be\r\n     * zero-copy.\r\n     * @hidden\r\n     */\r\n    function arrayBuffer2Buffer(ab) {\r\n        return Buffer.from(ab);\r\n    }\r\n    /**\r\n     * Copies a slice of the given buffer\r\n     * @hidden\r\n     */\r\n    function copyingSlice(buff, start = 0, end = buff.length) {\r\n        if (start < 0 || end < 0 || end > buff.length || start > end) {\r\n            throw new TypeError(`Invalid slice bounds on buffer of length ${buff.length}: [${start}, ${end}]`);\r\n        }\r\n        if (buff.length === 0) {\r\n            // Avoid s0 corner case in ArrayBuffer case.\r\n            return emptyBuffer();\r\n        }\r\n        else {\r\n            const u8 = buffer2Uint8array(buff), s0 = buff[0], newS0 = (s0 + 1) % 0xFF;\r\n            buff[0] = newS0;\r\n            if (u8[0] === newS0) {\r\n                // Same memory. Revert & copy.\r\n                u8[0] = s0;\r\n                return uint8Array2Buffer(u8.slice(start, end));\r\n            }\r\n            else {\r\n                // Revert.\r\n                buff[0] = s0;\r\n                return uint8Array2Buffer(u8.subarray(start, end));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    let emptyBuff = null;\r\n    /**\r\n     * Returns an empty buffer.\r\n     * @hidden\r\n     */\r\n    function emptyBuffer() {\r\n        if (emptyBuff) {\r\n            return emptyBuff;\r\n        }\r\n        return emptyBuff = Buffer.alloc(0);\r\n    }\r\n    /**\r\n     * Option validator for a Buffer file system option.\r\n     * @hidden\r\n     */\r\n    function bufferValidator(v, cb) {\r\n        if (Buffer.isBuffer(v)) {\r\n            cb();\r\n        }\r\n        else {\r\n            cb(new FileError(ErrorCodes.EINVAL, `option must be a Buffer.`));\r\n        }\r\n    }\r\n    /**\r\n     * Checks that the given options object is valid for the file system options.\r\n     * @hidden\r\n     */\r\n    function checkOptions(fsType, opts, cb) {\r\n        const optsInfo = fsType.Options;\r\n        const fsName = fsType.Name;\r\n        let pendingValidators = 0;\r\n        let callbackCalled = false;\r\n        let loopEnded = false;\r\n        function validatorCallback(e) {\r\n            if (!callbackCalled) {\r\n                if (e) {\r\n                    callbackCalled = true;\r\n                    cb(e);\r\n                }\r\n                pendingValidators--;\r\n                if (pendingValidators === 0 && loopEnded) {\r\n                    cb();\r\n                }\r\n            }\r\n        }\r\n        // Check for required options.\r\n        for (const optName in optsInfo) {\r\n            if (optsInfo.hasOwnProperty(optName)) {\r\n                const opt = optsInfo[optName];\r\n                const providedValue = opts[optName];\r\n                if (providedValue === undefined || providedValue === null) {\r\n                    if (!opt.optional) {\r\n                        // Required option, not provided.\r\n                        // Any incorrect options provided? Which ones are close to the provided one?\r\n                        // (edit distance 5 === close)\r\n                        const incorrectOptions = Object.keys(opts).filter((o) => !(o in optsInfo)).map((a) => {\r\n                            return { str: a, distance: levenshtein(optName, a) };\r\n                        }).filter((o) => o.distance < 5).sort((a, b) => a.distance - b.distance);\r\n                        // Validators may be synchronous.\r\n                        if (callbackCalled) {\r\n                            return;\r\n                        }\r\n                        callbackCalled = true;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, `[${fsName}] Required option '${optName}' not provided.${incorrectOptions.length > 0 ? ` You provided unrecognized option '${incorrectOptions[0].str}'; perhaps you meant to type '${optName}'.` : ''}\\nOption description: ${opt.description}`));\r\n                    }\r\n                    // Else: Optional option, not provided. That is OK.\r\n                }\r\n                else {\r\n                    // Option provided! Check type.\r\n                    let typeMatches = false;\r\n                    if (Array.isArray(opt.type)) {\r\n                        typeMatches = opt.type.indexOf(typeof (providedValue)) !== -1;\r\n                    }\r\n                    else {\r\n                        typeMatches = typeof (providedValue) === opt.type;\r\n                    }\r\n                    if (!typeMatches) {\r\n                        // Validators may be synchronous.\r\n                        if (callbackCalled) {\r\n                            return;\r\n                        }\r\n                        callbackCalled = true;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, `[${fsName}] Value provided for option ${optName} is not the proper type. Expected ${Array.isArray(opt.type) ? `one of {${opt.type.join(\", \")}}` : opt.type}, but received ${typeof (providedValue)}\\nOption description: ${opt.description}`));\r\n                    }\r\n                    else if (opt.validator) {\r\n                        pendingValidators++;\r\n                        opt.validator(providedValue, validatorCallback);\r\n                    }\r\n                    // Otherwise: All good!\r\n                }\r\n            }\r\n        }\r\n        loopEnded = true;\r\n        if (pendingValidators === 0 && !callbackCalled) {\r\n            cb();\r\n        }\r\n    }\r\n\r\n    return {\r\n        deprecationMessage: deprecationMessage,\r\n        isIE: isIE,\r\n        isWebWorker: isWebWorker,\r\n        fail: fail,\r\n        mkdirpSync: mkdirpSync,\r\n        buffer2ArrayBuffer: buffer2ArrayBuffer,\r\n        buffer2Uint8array: buffer2Uint8array,\r\n        arrayish2Buffer: arrayish2Buffer,\r\n        uint8Array2Buffer: uint8Array2Buffer,\r\n        arrayBuffer2Buffer: arrayBuffer2Buffer,\r\n        copyingSlice: copyingSlice,\r\n        emptyBuffer: emptyBuffer,\r\n        bufferValidator: bufferValidator,\r\n        checkOptions: checkOptions\r\n    };\r\n});\ndefine('skylark-io-files/preload-file',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"./files\",\r\n    \"./error-codes\",\r\n    './file-error',\r\n    \"./stats\",\r\n    \"./base-file\",\r\n    './utils'\r\n], function (Buffer,files,ErrorCodes,FileError,Stats,BaseFile, utils) {\r\n    'use strict';\r\n\r\n    ////fs     '../core/node_fs',\r\n\r\n    const { emptyBuffer } = utils;\r\n\r\n    /**\r\n     * An implementation of the File interface that operates on a file that is\r\n     * completely in-memory. PreloadFiles are backed by a Buffer.\r\n     *\r\n     * This is also an abstract class, as it lacks an implementation of 'sync' and\r\n     * 'close'. Each filesystem that wishes to use this file representation must\r\n     * extend this class and implement those two methods.\r\n     * @todo 'close' lever that disables functionality once closed.\r\n     */\r\n    class PreloadFile extends BaseFile {\r\n        /**\r\n         * Creates a file with the given path and, optionally, the given contents. Note\r\n         * that, if contents is specified, it will be mutated by the file!\r\n         * @param _fs The file system that created the file.\r\n         * @param _path\r\n         * @param _mode The mode that the file was opened using.\r\n         *   Dictates permissions and where the file pointer starts.\r\n         * @param _stat The stats object for the given file.\r\n         *   PreloadFile will mutate this object. Note that this object must contain\r\n         *   the appropriate mode that the file was opened as.\r\n         * @param contents A buffer containing the entire\r\n         *   contents of the file. PreloadFile will mutate this buffer. If not\r\n         *   specified, we assume it is a new file.\r\n         */\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super();\r\n            this._pos = 0;\r\n            this._dirty = false;\r\n            this._fs = _fs;\r\n            this._path = _path;\r\n            this._flag = _flag;\r\n            this._stat = _stat;\r\n            this._buffer = contents ? contents : emptyBuffer();\r\n            // Note: This invariant is *not* maintained once the file starts getting\r\n            // modified.\r\n            // Note: Only actually matters if file is readable, as writeable modes may\r\n            // truncate/append to file.\r\n            if (this._stat.size !== this._buffer.length && this._flag.isReadable()) {\r\n                throw new Error(`Invalid buffer: Buffer is ${this._buffer.length} long, yet Stats object specifies that file is ${this._stat.size} long.`);\r\n            }\r\n        }\r\n        /**\r\n         * NONSTANDARD: Get the underlying buffer for this file. !!DO NOT MUTATE!! Will mess up dirty tracking.\r\n         */\r\n        getBuffer() {\r\n            return this._buffer;\r\n        }\r\n        /**\r\n         * NONSTANDARD: Get underlying stats for this file. !!DO NOT MUTATE!!\r\n         */\r\n        getStats() {\r\n            return this._stat;\r\n        }\r\n        getFlag() {\r\n            return this._flag;\r\n        }\r\n        /**\r\n         * Get the path to this file.\r\n         * @return [String] The path to the file.\r\n         */\r\n        getPath() {\r\n            return this._path;\r\n        }\r\n        /**\r\n         * Get the current file position.\r\n         *\r\n         * We emulate the following bug mentioned in the Node documentation:\r\n         * > On Linux, positional writes don't work when the file is opened in append\r\n         *   mode. The kernel ignores the position argument and always appends the data\r\n         *   to the end of the file.\r\n         * @return [Number] The current file position.\r\n         */\r\n        getPos() {\r\n            if (this._flag.isAppendable()) {\r\n                return this._stat.size;\r\n            }\r\n            return this._pos;\r\n        }\r\n        /**\r\n         * Advance the current file position by the indicated number of positions.\r\n         * @param [Number] delta\r\n         */\r\n        advancePos(delta) {\r\n            return this._pos += delta;\r\n        }\r\n        /**\r\n         * Set the file position.\r\n         * @param [Number] newPos\r\n         */\r\n        setPos(newPos) {\r\n            return this._pos = newPos;\r\n        }\r\n        /**\r\n         * **Core**: Asynchronous sync. Must be implemented by subclasses of this\r\n         * class.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        sync(cb) {\r\n            try {\r\n                this.syncSync();\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * **Core**: Synchronous sync.\r\n         */\r\n        syncSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * **Core**: Asynchronous close. Must be implemented by subclasses of this\r\n         * class.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        close(cb) {\r\n            try {\r\n                this.closeSync();\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * **Core**: Synchronous close.\r\n         */\r\n        closeSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Asynchronous `stat`.\r\n         * @param [Function(BrowserFS.FileError, BrowserFS.node.fs.Stats)] cb\r\n         */\r\n        stat(cb) {\r\n            try {\r\n                cb(null, Stats.clone(this._stat));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `stat`.\r\n         */\r\n        statSync() {\r\n            return Stats.clone(this._stat);\r\n        }\r\n        /**\r\n         * Asynchronous truncate.\r\n         * @param [Number] len\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        truncate(len, cb) {\r\n            try {\r\n                this.truncateSync(len);\r\n                if (this._flag.isSynchronous() && !fs.getRootFS().supportsSynch()) {\r\n                    this.sync(cb);\r\n                }\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                return cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous truncate.\r\n         * @param [Number] len\r\n         */\r\n        truncateSync(len) {\r\n            this._dirty = true;\r\n            if (!this._flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a writeable mode.');\r\n            }\r\n            this._stat.mtimeMs = Date.now();\r\n            if (len > this._buffer.length) {\r\n                const buf = Buffer.alloc(len - this._buffer.length, 0);\r\n                // Write will set @_stat.size for us.\r\n                this.writeSync(buf, 0, buf.length, this._buffer.length);\r\n                if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\r\n                    this.syncSync();\r\n                }\r\n                return;\r\n            }\r\n            this._stat.size = len;\r\n            // Truncate buffer to 'len'.\r\n            const newBuff = Buffer.alloc(len);\r\n            this._buffer.copy(newBuff, 0, 0, len);\r\n            this._buffer = newBuff;\r\n            if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\r\n                this.syncSync();\r\n            }\r\n        }\r\n        /**\r\n         * Write buffer to the file.\r\n         * Note that it is unsafe to use fs.write multiple times on the same file\r\n         * without waiting for the callback.\r\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\r\n         *  the file.\r\n         * @param [Number] offset Offset in the buffer to start reading data from.\r\n         * @param [Number] length The amount of bytes to write to the file.\r\n         * @param [Number] position Offset from the beginning of the file where this\r\n         *   data should be written. If position is null, the data will be written at\r\n         *   the current position.\r\n         * @param [Function(BrowserFS.FileError, Number, BrowserFS.node.Buffer)]\r\n         *   cb The number specifies the number of bytes written into the file.\r\n         */\r\n        write(buffer, offset, length, position, cb) {\r\n            try {\r\n                cb(null, this.writeSync(buffer, offset, length, position), buffer);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Write buffer to the file.\r\n         * Note that it is unsafe to use fs.writeSync multiple times on the same file\r\n         * without waiting for the callback.\r\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\r\n         *  the file.\r\n         * @param [Number] offset Offset in the buffer to start reading data from.\r\n         * @param [Number] length The amount of bytes to write to the file.\r\n         * @param [Number] position Offset from the beginning of the file where this\r\n         *   data should be written. If position is null, the data will be written at\r\n         *   the current position.\r\n         * @return [Number]\r\n         */\r\n        writeSync(buffer, offset, length, position) {\r\n            this._dirty = true;\r\n            if (position === undefined || position === null) {\r\n                position = this.getPos();\r\n            }\r\n            if (!this._flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a writeable mode.');\r\n            }\r\n            const endFp = position + length;\r\n            if (endFp > this._stat.size) {\r\n                this._stat.size = endFp;\r\n                if (endFp > this._buffer.length) {\r\n                    // Extend the buffer!\r\n                    const newBuff = Buffer.alloc(endFp);\r\n                    this._buffer.copy(newBuff);\r\n                    this._buffer = newBuff;\r\n                }\r\n            }\r\n            const len = buffer.copy(this._buffer, position, offset, offset + length);\r\n            this._stat.mtimeMs = Date.now();\r\n            if (this._flag.isSynchronous()) {\r\n                this.syncSync();\r\n                return len;\r\n            }\r\n            this.setPos(position + len);\r\n            return len;\r\n        }\r\n        /**\r\n         * Read data from the file.\r\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\r\n         *   written to.\r\n         * @param [Number] offset The offset within the buffer where writing will\r\n         *   start.\r\n         * @param [Number] length An integer specifying the number of bytes to read.\r\n         * @param [Number] position An integer specifying where to begin reading from\r\n         *   in the file. If position is null, data will be read from the current file\r\n         *   position.\r\n         * @param [Function(BrowserFS.FileError, Number, BrowserFS.node.Buffer)] cb The\r\n         *   number is the number of bytes read\r\n         */\r\n        read(buffer, offset, length, position, cb) {\r\n            try {\r\n                cb(null, this.readSync(buffer, offset, length, position), buffer);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Read data from the file.\r\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\r\n         *   written to.\r\n         * @param [Number] offset The offset within the buffer where writing will\r\n         *   start.\r\n         * @param [Number] length An integer specifying the number of bytes to read.\r\n         * @param [Number] position An integer specifying where to begin reading from\r\n         *   in the file. If position is null, data will be read from the current file\r\n         *   position.\r\n         * @return [Number]\r\n         */\r\n        readSync(buffer, offset, length, position) {\r\n            if (!this._flag.isReadable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a readable mode.');\r\n            }\r\n            if (position === undefined || position === null) {\r\n                position = this.getPos();\r\n            }\r\n            const endRead = position + length;\r\n            if (endRead > this._stat.size) {\r\n                length = this._stat.size - position;\r\n            }\r\n            const rv = this._buffer.copy(buffer, offset, position, position + length);\r\n            this._stat.atimeMs = Date.now();\r\n            this._pos = position + length;\r\n            return rv;\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param [Number|String] mode\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        chmod(mode, cb) {\r\n            try {\r\n                this.chmodSync(mode);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param [Number] mode\r\n         */\r\n        chmodSync(mode) {\r\n            if (!this._fs.supportsProps()) {\r\n                throw new FileError(ErrorCodes.ENOTSUP);\r\n            }\r\n            this._dirty = true;\r\n            this._stat.chmod(mode);\r\n            this.syncSync();\r\n        }\r\n        isDirty() {\r\n            return this._dirty;\r\n        }\r\n        /**\r\n         * Resets the dirty bit. Should only be called after a sync has completed successfully.\r\n         */\r\n        resetDirty() {\r\n            this._dirty = false;\r\n        }\r\n    }\r\n\r\n    return files.PreloadFile = PreloadFile;\r\n});\ndefine('skylark-io-files/no-sync-file',[\r\n     \"./files\",\r\n     \"./preload-file\"\r\n], function (files,PreloadFile) {\r\n    'use strict';\r\n    /**\r\n     * File class for the InMemory and XHR file systems.\r\n     * Doesn't sync to anything, so it works nicely for memory-only files.\r\n     */\r\n    class NoSyncFile extends PreloadFile {\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super(_fs, _path, _flag, _stat, contents);\r\n        }\r\n        /**\r\n         * Asynchronous sync. Doesn't do anything, simply calls the cb.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        sync(cb) {\r\n            cb();\r\n        }\r\n        /**\r\n         * Synchronous sync. Doesn't do anything.\r\n         */\r\n        syncSync() {\r\n            // NOP.\r\n        }\r\n        /**\r\n         * Asynchronous close. Doesn't do anything, simply calls the cb.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        close(cb) {\r\n            cb();\r\n        }\r\n        /**\r\n         * Synchronous close. Doesn't do anything.\r\n         */\r\n        closeSync() {\r\n            // NOP.\r\n        }\r\n    }\r\n\r\n    return files.NoSyncFile = NoSyncFile;\r\n    \r\n});\ndefine('skylark-io-files/providers/registry',[\r\n\t\"../files\"\r\n],function(files){\r\n\r\n\tvar cache = {}\r\n\r\n\tfunction get(name) {\r\n\t\treturn cache[name];\r\n\t}\r\n\r\n\tfunction add(name,provider) {\r\n\t\tcache[name] = provider;\r\n\t}\r\n\t\r\n\r\n\treturn files.providers.registry = {\r\n\t\tget,\r\n\t\tadd\r\n\t};\r\n});\ndefine('skylark-io-files/configure',[\r\n    \"./files\",\r\n    './file-system',\r\n    \"./error-codes\",\r\n    \"./file-error\",\r\n    './providers/registry',\r\n], function(files, FileSystem, ErrorCodes,FileError,registry) {\r\n    'use strict';\r\n\r\n    var fs = files.fs = new FileSystem();\r\n\r\n    /**\r\n     * Initializes BrowserFS with the given root file system.\r\n     */\r\n    function initialize(rootfs) {\r\n        return fs.initialize(rootfs);\r\n    }\r\n    /**\r\n     * Creates a file system with the given configuration, and initializes BrowserFS with it.\r\n     * See the FileSystemConfiguration type for more info on the configuration object.\r\n     */\r\n    function configure(config, cb) {\r\n        getFileSystem(config, (e, provider) => {\r\n            if (provider) {\r\n                initialize(provider);\r\n                cb(null,fs);\r\n            }\r\n            else {\r\n                cb(e);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Retrieve a file system with the given configuration.\r\n     * @param config A FileSystemConfiguration object. See FileSystemConfiguration for details.\r\n     * @param cb Called when the file system is constructed, or when an error occurs.\r\n     */\r\n    function getFileSystem(config, cb) {\r\n        const fsName = config['fs'];\r\n        if (!fsName) {\r\n            return cb(new FileError(ErrorCodes.EPERM, 'Missing \"fs\" property on configuration object.'));\r\n        }\r\n        const options = config['options'];\r\n        let waitCount = 0;\r\n        let called = false;\r\n        function finish() {\r\n            if (!called) {\r\n                called = true;\r\n                const fsc = registry.get(fsName);\r\n                if (!fsc) {\r\n                    cb(new FileError(ErrorCodes.EPERM, `File system ${fsName} is not available in BrowserFS.`));\r\n                }\r\n                else {\r\n                    fsc.Create(options, cb);\r\n                }\r\n            }\r\n        }\r\n        if (options !== null && typeof (options) === \"object\") {\r\n            let finishedIterating = false;\r\n            const props = Object.keys(options).filter((k) => k !== 'fs');\r\n            // Check recursively if other fields have 'fs' properties.\r\n            props.forEach((p) => {\r\n                const d = options[p];\r\n                if (d !== null && typeof (d) === \"object\" && d['fs']) {\r\n                    waitCount++;\r\n                    getFileSystem(d, function (e, fs) {\r\n                        waitCount--;\r\n                        if (e) {\r\n                            if (called) {\r\n                                return;\r\n                            }\r\n                            called = true;\r\n                            cb(e);\r\n                        }\r\n                        else {\r\n                            options[p] = fs;\r\n                            if (waitCount === 0 && finishedIterating) {\r\n                                finish();\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n            finishedIterating = true;\r\n        }\r\n        if (waitCount === 0) {\r\n            finish();\r\n        }\r\n    }\r\n\r\n    return files.configure = configure;\r\n});\ndefine('skylark-io-files/providers/base-provider',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error',\r\n    '../action-type',\r\n    '../file-flag',\r\n    '../utils'\r\n], function (Buffer,paths, files,ErrorCodes, FileError, ActionType, FileFlag, utils) {\r\n    'use strict';\r\n\r\n    const { fail } = utils;\r\n\r\n    /**\r\n     * Basic filesystem class. Most filesystems should extend this class, as it\r\n     * provides default implementations for a handful of methods.\r\n     */\r\n    class BaseProvider {\r\n        supportsLinks() {\r\n            return false;\r\n        }\r\n        diskSpace(p, cb) {\r\n            cb(0, 0);\r\n        }\r\n        /**\r\n         * Opens the file at path p with the given flag. The file must exist.\r\n         * @param p The path to open.\r\n         * @param flag The flag to use when opening the file.\r\n         */\r\n        openFile(p, flag, cb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Create the file at path p with the given mode. Then, open it with the given\r\n         * flag.\r\n         */\r\n        createFile(p, flag, mode, cb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        open(p, flag, mode, cb) {\r\n            const mustBeFile = (e, stats) => {\r\n                if (e) {\r\n                    // File does not exist.\r\n                    switch (flag.pathNotExistsAction()) {\r\n                        case ActionType.CREATE_FILE:\r\n                            // Ensure parent exists.\r\n                            return this.stat(paths.dirname(p), false, (e, parentStats) => {\r\n                                if (e) {\r\n                                    cb(e);\r\n                                }\r\n                                else if (parentStats && !parentStats.isDirectory()) {\r\n                                    cb(FileError.ENOTDIR(paths.dirname(p)));\r\n                                }\r\n                                else {\r\n                                    this.createFile(p, flag, mode, cb);\r\n                                }\r\n                            });\r\n                        case ActionType.THROW_EXCEPTION:\r\n                            return cb(FileError.ENOENT(p));\r\n                        default:\r\n                            return cb(new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.'));\r\n                    }\r\n                }\r\n                else {\r\n                    // File exists.\r\n                    if (stats && stats.isDirectory()) {\r\n                        return cb(FileError.EISDIR(p));\r\n                    }\r\n                    switch (flag.pathExistsAction()) {\r\n                        case ActionType.THROW_EXCEPTION:\r\n                            return cb(FileError.EEXIST(p));\r\n                        case ActionType.TRUNCATE_FILE:\r\n                            // NOTE: In a previous implementation, we deleted the file and\r\n                            // re-created it. However, this created a race condition if another\r\n                            // asynchronous request was trying to read the file, as the file\r\n                            // would not exist for a small period of time.\r\n                            return this.openFile(p, flag, (e, fd) => {\r\n                                if (e) {\r\n                                    cb(e);\r\n                                }\r\n                                else if (fd) {\r\n                                    fd.truncate(0, () => {\r\n                                        fd.sync(() => {\r\n                                            cb(null, fd);\r\n                                        });\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    fail();\r\n                                }\r\n                            });\r\n                        case ActionType.NOP:\r\n                            return this.openFile(p, flag, cb);\r\n                        default:\r\n                            return cb(new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.'));\r\n                    }\r\n                }\r\n            };\r\n            this.stat(p, false, mustBeFile);\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        statSync(p, isLstat) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Opens the file at path p with the given flag. The file must exist.\r\n         * @param p The path to open.\r\n         * @param flag The flag to use when opening the file.\r\n         * @return A File object corresponding to the opened file.\r\n         */\r\n        openFileSync(p, flag, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Create the file at path p with the given mode. Then, open it with the given\r\n         * flag.\r\n         */\r\n        createFileSync(p, flag, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        openSync(p, flag, mode) {\r\n            // Check if the path exists, and is a file.\r\n            let stats;\r\n            try {\r\n                stats = this.statSync(p, false);\r\n            }\r\n            catch (e) {\r\n                // File does not exist.\r\n                switch (flag.pathNotExistsAction()) {\r\n                    case ActionType.CREATE_FILE:\r\n                        // Ensure parent exists.\r\n                        const parentStats = this.statSync(paths.dirname(p), false);\r\n                        if (!parentStats.isDirectory()) {\r\n                            throw FileError.ENOTDIR(paths.dirname(p));\r\n                        }\r\n                        return this.createFileSync(p, flag, mode);\r\n                    case ActionType.THROW_EXCEPTION:\r\n                        throw FileError.ENOENT(p);\r\n                    default:\r\n                        throw new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.');\r\n                }\r\n            }\r\n            // File exists.\r\n            if (stats.isDirectory()) {\r\n                throw FileError.EISDIR(p);\r\n            }\r\n            switch (flag.pathExistsAction()) {\r\n                case ActionType.THROW_EXCEPTION:\r\n                    throw FileError.EEXIST(p);\r\n                case ActionType.TRUNCATE_FILE:\r\n                    // Delete file.\r\n                    this.unlinkSync(p);\r\n                    // Create file. Use the same mode as the old file.\r\n                    // Node itself modifies the ctime when this occurs, so this action\r\n                    // will preserve that behavior if the underlying file system\r\n                    // supports those properties.\r\n                    return this.createFileSync(p, flag, stats.mode);\r\n                case ActionType.NOP:\r\n                    return this.openFileSync(p, flag, mode);\r\n                default:\r\n                    throw new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.');\r\n            }\r\n        }\r\n        unlink(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        unlinkSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        rmdir(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        rmdirSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        mkdirSync(p, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        readdir(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        readdirSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        exists(p, cb) {\r\n            this.stat(p, null, function (err) {\r\n                cb(!err);\r\n            });\r\n        }\r\n        existsSync(p) {\r\n            try {\r\n                this.statSync(p, true);\r\n                return true;\r\n            }\r\n            catch (e) {\r\n                return false;\r\n            }\r\n        }\r\n        realpath(p, cache, cb) {\r\n            if (this.supportsLinks()) {\r\n                // The path could contain symlinks. Split up the path,\r\n                // resolve any symlinks, return the resolved string.\r\n                const splitPath = p.split(paths.sep);\r\n                // TODO: Simpler to just pass through file, find sep and such.\r\n                for (let i = 0; i < splitPath.length; i++) {\r\n                    const addPaths = splitPath.slice(0, i + 1);\r\n                    splitPath[i] = paths.join.apply(null, addPaths);\r\n                }\r\n            }\r\n            else {\r\n                // No symlinks. We just need to verify that it exists.\r\n                this.exists(p, function (doesExist) {\r\n                    if (doesExist) {\r\n                        cb(null, p);\r\n                    }\r\n                    else {\r\n                        cb(FileError.ENOENT(p));\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        realpathSync(p, cache) {\r\n            if (this.supportsLinks()) {\r\n                // The path could contain symlinks. Split up the path,\r\n                // resolve any symlinks, return the resolved string.\r\n                const splitPath = p.split(paths.sep);\r\n                // TODO: Simpler to just pass through file, find sep and such.\r\n                for (let i = 0; i < splitPath.length; i++) {\r\n                    const addPaths = splitPath.slice(0, i + 1);\r\n                    splitPath[i] = paths.join.apply(path, addPaths);\r\n                }\r\n                return splitPath.join(paths.sep);\r\n            }\r\n            else {\r\n                // No symlinks. We just need to verify that it exists.\r\n                if (this.existsSync(p)) {\r\n                    return p;\r\n                }\r\n                else {\r\n                    throw FileError.ENOENT(p);\r\n                }\r\n            }\r\n        }\r\n        truncate(p, len, cb) {\r\n            this.open(p, FileFlag.getFileFlag('r+'), 0x1a4, (function (er, fd) {\r\n                if (er) {\r\n                    return cb(er);\r\n                }\r\n                fd.truncate(len, (function (er) {\r\n                    fd.close((function (er2) {\r\n                        cb(er || er2);\r\n                    }));\r\n                }));\r\n            }));\r\n        }\r\n        truncateSync(p, len) {\r\n            const fd = this.openSync(p, FileFlag.getFileFlag('r+'), 0x1a4);\r\n            // Need to safely close FD, regardless of whether or not truncate succeeds.\r\n            try {\r\n                fd.truncateSync(len);\r\n            }\r\n            catch (e) {\r\n                throw e;\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        readFile(fname, encoding, flag, cb) {\r\n            // Wrap cb in file closing code.\r\n            const oldCb = cb;\r\n            // Get file.\r\n            this.open(fname, flag, 0x1a4, (err, fd) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                cb = function (err, arg) {\r\n                    fd.close(function (err2) {\r\n                        if (!err) {\r\n                            err = err2;\r\n                        }\r\n                        return oldCb(err, arg);\r\n                    });\r\n                };\r\n                fd.stat((err, stat) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    // Allocate buffer.\r\n                    const buf = Buffer.alloc(stat.size);\r\n                    fd.read(buf, 0, stat.size, 0, (err) => {\r\n                        if (err) {\r\n                            return cb(err);\r\n                        }\r\n                        else if (encoding === null) {\r\n                            return cb(err, buf);\r\n                        }\r\n                        try {\r\n                            cb(null, buf.toString(encoding));\r\n                        }\r\n                        catch (e) {\r\n                            cb(e);\r\n                        }\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        readFileSync(fname, encoding, flag) {\r\n            // Get file.\r\n            const fd = this.openSync(fname, flag, 0x1a4);\r\n            try {\r\n                const stat = fd.statSync();\r\n                // Allocate buffer.\r\n                const buf = Buffer.alloc(stat.size);\r\n                fd.readSync(buf, 0, stat.size, 0);\r\n                fd.closeSync();\r\n                if (encoding === null) {\r\n                    return buf;\r\n                }\r\n                return buf.toString(encoding);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        writeFile(fname, data, encoding, flag, mode, cb) {\r\n            // Wrap cb in file closing code.\r\n            const oldCb = cb;\r\n            // Get file.\r\n            this.open(fname, flag, 0x1a4, function (err, fd) {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                cb = function (err) {\r\n                    fd.close(function (err2) {\r\n                        oldCb(err ? err : err2);\r\n                    });\r\n                };\r\n                try {\r\n                    if (typeof data === 'string') {\r\n                        data = Buffer.from(data, encoding);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    return cb(e);\r\n                }\r\n                // Write into file.\r\n                fd.write(data, 0, data.length, 0, cb);\r\n            });\r\n        }\r\n        writeFileSync(fname, data, encoding, flag, mode) {\r\n            // Get file.\r\n            const fd = this.openSync(fname, flag, mode);\r\n            try {\r\n                if (typeof data === 'string') {\r\n                    data = Buffer.from(data, encoding);\r\n                }\r\n                // Write into file.\r\n                fd.writeSync(data, 0, data.length, 0);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        appendFile(fname, data, encoding, flag, mode, cb) {\r\n            // Wrap cb in file closing code.\r\n            const oldCb = cb;\r\n            this.open(fname, flag, mode, function (err, fd) {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                cb = function (err) {\r\n                    fd.close(function (err2) {\r\n                        oldCb(err ? err : err2);\r\n                    });\r\n                };\r\n                if (typeof data === 'string') {\r\n                    data = Buffer.from(data, encoding);\r\n                }\r\n                fd.write(data, 0, data.length, null, cb);\r\n            });\r\n        }\r\n        appendFileSync(fname, data, encoding, flag, mode) {\r\n            const fd = this.openSync(fname, flag, mode);\r\n            try {\r\n                if (typeof data === 'string') {\r\n                    data = Buffer.from(data, encoding);\r\n                }\r\n                fd.writeSync(data, 0, data.length, null);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chmodSync(p, isLchmod, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        chown(p, isLchown, uid, gid, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chownSync(p, isLchown, uid, gid) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        utimesSync(p, atime, mtime) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        link(srcpath, dstpath, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        linkSync(srcpath, dstpath) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        symlink(srcpath, dstpath, type, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        readlink(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        readlinkSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n    }\r\n\r\n\r\n    return files.providers.BaseProvider = BaseProvider;\r\n});\ndefine('skylark-io-files/providers/dropbox/dropbox-file',[\r\n    '../../preload-file'\r\n], function (PreloadFile) {\r\n    'use strict';\r\n\r\n    class DropboxFile extends PreloadFile {\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super(_fs, _path, _flag, _stat, contents);\r\n        }\r\n        sync(cb) {\r\n            this._fs._syncFile(this.getPath(), this.getBuffer(), cb);\r\n        }\r\n        close(cb) {\r\n            this.sync(cb);\r\n        }\r\n    }\r\n\r\n    return  DropboxFile;\r\n    \r\n});\ndefine('skylark-io-files/providers/dropbox/dropbox-provider',[\r\n    \"skylark-langx-funcs/defer\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"../../files\",\r\n    \"../registry\",\r\n    \"../base-provider\",\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    '../../utils',\r\n    './dropbox-file'\r\n], function (setImmediate,Buffer,paths,files, registry,BaseProvider, Stats,FileType,FileError, ErrorCodes, utils,DropboxFile) {\r\n    'use strict';\r\n\r\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer } =  utils;\r\n///    const { Dropbox } =  dropbox_bridge;\r\n    const { dirname } =  paths;\r\n\r\n\r\n    /**\r\n     * Dropbox paths do not begin with a /, they just begin with a folder at the root node.\r\n     * Here, we strip the `/`.\r\n     * @param p An absolute path\r\n     */\r\n    function FixPath(p) {\r\n        if (p === '/') {\r\n            return '';\r\n        }\r\n        else {\r\n            return p;\r\n        }\r\n    }\r\n    /**\r\n     * HACK: Dropbox errors are FUBAR'd sometimes.\r\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\r\n     * @param e\r\n     */\r\n    function ExtractTheFuckingError(e) {\r\n        const obj = e.error;\r\n        if (obj['.tag']) {\r\n            // Everything is OK.\r\n            return obj;\r\n        }\r\n        else if (obj['error']) {\r\n            // Terrible nested object bug.\r\n            const obj2 = obj.error;\r\n            if (obj2['.tag']) {\r\n                return obj2;\r\n            }\r\n            else if (obj2['reason'] && obj2['reason']['.tag']) {\r\n                return obj2.reason;\r\n            }\r\n            else {\r\n                return obj2;\r\n            }\r\n        }\r\n        else if (typeof (obj) === 'string') {\r\n            // Might be a fucking JSON object error.\r\n            try {\r\n                const obj2 = JSON.parse(obj);\r\n                if (obj2['error'] && obj2['error']['reason'] && obj2['error']['reason']['.tag']) {\r\n                    return obj2.error.reason;\r\n                }\r\n            }\r\n            catch (e) {\r\n                // Nope. Give up.\r\n            }\r\n        }\r\n        return obj;\r\n    }\r\n    /**\r\n     * Returns a user-facing error message given an error.\r\n     *\r\n     * HACK: Dropbox error messages sometimes lack a `user_message` field.\r\n     * Sometimes, they are even strings. Ugh.\r\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\r\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/145\r\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/144\r\n     * @param err An error.\r\n     */\r\n    function GetErrorMessage(err) {\r\n        if (err['user_message']) {\r\n            return err.user_message.text;\r\n        }\r\n        else if (err['error_summary']) {\r\n            return err.error_summary;\r\n        }\r\n        else if (typeof (err.error) === \"string\") {\r\n            return err.error;\r\n        }\r\n        else if (typeof (err.error) === \"object\") {\r\n            // DROPBOX BUG: Sometimes, error is a nested error.\r\n            return GetErrorMessage(err.error);\r\n        }\r\n        else {\r\n            throw new Error(`Dropbox's servers gave us a garbage error message: ${JSON.stringify(err)}`);\r\n        }\r\n    }\r\n    function LookupErrorToError(err, p, msg) {\r\n        switch (err['.tag']) {\r\n            case 'malformed_path':\r\n                return new FileError(ErrorCodes.EBADF, msg, p);\r\n            case 'not_found':\r\n                return FileError.ENOENT(p);\r\n            case 'not_file':\r\n                return FileError.EISDIR(p);\r\n            case 'not_folder':\r\n                return FileError.ENOTDIR(p);\r\n            case 'restricted_content':\r\n                return FileError.EPERM(p);\r\n            case 'other':\r\n            default:\r\n                return new FileError(ErrorCodes.EIO, msg, p);\r\n        }\r\n    }\r\n    function WriteErrorToError(err, p, msg) {\r\n        switch (err['.tag']) {\r\n            case 'malformed_path':\r\n            case 'disallowed_name':\r\n                return new FileError(ErrorCodes.EBADF, msg, p);\r\n            case 'conflict':\r\n            case 'no_write_permission':\r\n            case 'team_folder':\r\n                return FileError.EPERM(p);\r\n            case 'insufficient_space':\r\n                return new FileError(ErrorCodes.ENOSPC, msg);\r\n            case 'other':\r\n            default:\r\n                return new FileError(ErrorCodes.EIO, msg, p);\r\n        }\r\n    }\r\n    function FilesDeleteWrapped(client, p, cb) {\r\n        const arg = {\r\n            path: FixPath(p)\r\n        };\r\n        client.filesDeleteV2(arg)\r\n            .then(() => {\r\n            cb();\r\n        }).catch((e) => {\r\n            const err = ExtractTheFuckingError(e);\r\n            switch (err['.tag']) {\r\n                case 'path_lookup':\r\n                    cb(LookupErrorToError(err.path_lookup, p, GetErrorMessage(e)));\r\n                    break;\r\n                case 'path_write':\r\n                    cb(WriteErrorToError(err.path_write, p, GetErrorMessage(e)));\r\n                    break;\r\n                case 'too_many_write_operations':\r\n                    setTimeout(() => FilesDeleteWrapped(client, p, cb), 500 + (300 * (Math.random())));\r\n                    break;\r\n                case 'other':\r\n                default:\r\n                    cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * A read/write file system backed by Dropbox cloud storage.\r\n     *\r\n     * Uses the Dropbox V2 API, and the 2.x JS SDK.\r\n     */\r\n    class DropboxProvider extends BaseProvider {\r\n        constructor(client) {\r\n            super();\r\n            this._client = client;\r\n        }\r\n        /**\r\n         * Creates a new DropboxProvider instance with the given options.\r\n         * Must be given an *authenticated* Dropbox client from 2.x JS SDK.\r\n         */\r\n        static Create(opts, cb) {\r\n            cb(null, new DropboxProvider(opts.client));\r\n        }\r\n        static isAvailable() {\r\n            // Checks if the Dropbox library is loaded.\r\n            return typeof Dropbox !== 'undefined';\r\n        }\r\n        getName() {\r\n            return DropboxProvider.Name;\r\n        }\r\n        isReadOnly() {\r\n            return false;\r\n        }\r\n        // Dropbox doesn't support symlinks, properties, or synchronous calls\r\n        // TODO: does it???\r\n        supportsSymlinks() {\r\n            return false;\r\n        }\r\n        supportsProps() {\r\n            return false;\r\n        }\r\n        supportsSynch() {\r\n            return false;\r\n        }\r\n        /**\r\n         * Deletes *everything* in the file system. Mainly intended for unit testing!\r\n         * @param mainCb Called when operation completes.\r\n         */\r\n        empty(mainCb) {\r\n            this.readdir('/', (e, paths) => {\r\n                if (paths) {\r\n                    const next = (e) => {\r\n                        if (paths.length === 0) {\r\n                            mainCb();\r\n                        }\r\n                        else {\r\n                            FilesDeleteWrapped(this._client, paths.shift(), next);\r\n                        }\r\n                    };\r\n                    next();\r\n                }\r\n                else {\r\n                    mainCb(e);\r\n                }\r\n            });\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            // Dropbox doesn't let you rename things over existing things, but POSIX does.\r\n            // So, we need to see if newPath exists...\r\n            this.stat(newPath, false, (e, stats) => {\r\n                const rename = () => {\r\n                    const relocationArg = {\r\n                        from_path: FixPath(oldPath),\r\n                        to_path: FixPath(newPath)\r\n                    };\r\n                    this._client.filesMoveV2(relocationArg)\r\n                        .then(() => cb())\r\n                        .catch(function (e) {\r\n                        const err = ExtractTheFuckingError(e);\r\n                        switch (err['.tag']) {\r\n                            case 'from_lookup':\r\n                                cb(LookupErrorToError(err.from_lookup, oldPath, GetErrorMessage(e)));\r\n                                break;\r\n                            case 'from_write':\r\n                                cb(WriteErrorToError(err.from_write, oldPath, GetErrorMessage(e)));\r\n                                break;\r\n                            case 'to':\r\n                                cb(WriteErrorToError(err.to, newPath, GetErrorMessage(e)));\r\n                                break;\r\n                            case 'cant_copy_shared_folder':\r\n                            case 'cant_nest_shared_folder':\r\n                                cb(new FileError(ErrorCodes.EPERM, GetErrorMessage(e), oldPath));\r\n                                break;\r\n                            case 'cant_move_folder_into_itself':\r\n                            case 'duplicated_or_nested_paths':\r\n                                cb(new FileError(ErrorCodes.EBADF, GetErrorMessage(e), oldPath));\r\n                                break;\r\n                            case 'too_many_files':\r\n                                cb(new FileError(ErrorCodes.ENOSPC, GetErrorMessage(e), oldPath));\r\n                                break;\r\n                            case 'other':\r\n                            default:\r\n                                cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), oldPath));\r\n                                break;\r\n                        }\r\n                    });\r\n                };\r\n                if (e) {\r\n                    // Doesn't exist. Proceed!\r\n                    rename();\r\n                }\r\n                else if (oldPath === newPath) {\r\n                    // NOP if the path exists. Error if it doesn't exist.\r\n                    if (e) {\r\n                        cb(FileError.ENOENT(newPath));\r\n                    }\r\n                    else {\r\n                        cb();\r\n                    }\r\n                }\r\n                else if (stats && stats.isDirectory()) {\r\n                    // Exists, is a directory. Cannot rename over an existing directory.\r\n                    cb(FileError.EISDIR(newPath));\r\n                }\r\n                else {\r\n                    // Exists, is a file, and differs from oldPath. Delete and rename.\r\n                    this.unlink(newPath, (e) => {\r\n                        if (e) {\r\n                            cb(e);\r\n                        }\r\n                        else {\r\n                            rename();\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        stat(path, isLstat, cb) {\r\n            if (path === '/') {\r\n                // Dropbox doesn't support querying the root directory.\r\n                setImmediate(function () {\r\n                    cb(null, new Stats(FileType.DIRECTORY, 4096));\r\n                });\r\n                return;\r\n            }\r\n            const arg = {\r\n                path: FixPath(path)\r\n            };\r\n            this._client.filesGetMetadata(arg).then((ref) => {\r\n                switch (ref['.tag']) {\r\n                    case 'file':\r\n                        const fileMetadata = ref;\r\n                        // TODO: Parse time fields.\r\n                        cb(null, new Stats(FileType.FILE, fileMetadata.size));\r\n                        break;\r\n                    case 'folder':\r\n                        cb(null, new Stats(FileType.DIRECTORY, 4096));\r\n                        break;\r\n                    case 'deleted':\r\n                        cb(FileError.ENOENT(path));\r\n                        break;\r\n                    default:\r\n                        // Unknown.\r\n                        break;\r\n                }\r\n            }).catch((e) => {\r\n                const err = ExtractTheFuckingError(e);\r\n                switch (err['.tag']) {\r\n                    case 'path':\r\n                        cb(LookupErrorToError(err.path, path, GetErrorMessage(e)));\r\n                        break;\r\n                    default:\r\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\r\n                        break;\r\n                }\r\n            });\r\n        }\r\n        openFile(path, flags, cb) {\r\n            const downloadArg = {\r\n                path: FixPath(path)\r\n            };\r\n            this._client.filesDownload(downloadArg).then((res) => {\r\n                const b = res.fileBlob;\r\n                const fr = new FileReader();\r\n                fr.onload = () => {\r\n                    const ab = fr.result;\r\n                    cb(null, new DropboxFile(this, path, flags, new Stats(FileType.FILE, ab.byteLength), arrayBuffer2Buffer(ab)));\r\n                };\r\n                fr.readAsArrayBuffer(b);\r\n            }).catch((e) => {\r\n                const err = ExtractTheFuckingError(e);\r\n                switch (err['.tag']) {\r\n                    case 'path':\r\n                        const dpError = err;\r\n                        cb(LookupErrorToError(dpError.path, path, GetErrorMessage(e)));\r\n                        break;\r\n                    case 'other':\r\n                    default:\r\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\r\n                        break;\r\n                }\r\n            });\r\n        }\r\n        createFile(p, flags, mode, cb) {\r\n            const fileData = Buffer.alloc(0);\r\n            const blob = new Blob([buffer2ArrayBuffer(fileData)], { type: \"octet/stream\" });\r\n            const commitInfo = {\r\n                contents: blob,\r\n                path: FixPath(p)\r\n            };\r\n            this._client.filesUpload(commitInfo).then((metadata) => {\r\n                cb(null, new DropboxFile(this, p, flags, new Stats(FileType.FILE, 0), fileData));\r\n            }).catch((e) => {\r\n                const err = ExtractTheFuckingError(e);\r\n                // HACK: Casting to 'any' since tag can be 'too_many_write_operations'.\r\n                switch (err['.tag']) {\r\n                    case 'path':\r\n                        const upError = err;\r\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\r\n                        break;\r\n                    case 'too_many_write_operations':\r\n                        // Retry in (500, 800) ms.\r\n                        setTimeout(() => this.createFile(p, flags, mode, cb), 500 + (300 * (Math.random())));\r\n                        break;\r\n                    case 'other':\r\n                    default:\r\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\r\n                        break;\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Delete a file\r\n         */\r\n        unlink(path, cb) {\r\n            // Must be a file. Check first.\r\n            this.stat(path, false, (e, stat) => {\r\n                if (stat) {\r\n                    if (stat.isDirectory()) {\r\n                        cb(FileError.EISDIR(path));\r\n                    }\r\n                    else {\r\n                        FilesDeleteWrapped(this._client, path, cb);\r\n                    }\r\n                }\r\n                else {\r\n                    cb(e);\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Delete a directory\r\n         */\r\n        rmdir(path, cb) {\r\n            this.readdir(path, (e, paths) => {\r\n                if (paths) {\r\n                    if (paths.length > 0) {\r\n                        cb(FileError.ENOTEMPTY(path));\r\n                    }\r\n                    else {\r\n                        FilesDeleteWrapped(this._client, path, cb);\r\n                    }\r\n                }\r\n                else {\r\n                    cb(e);\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Create a directory\r\n         */\r\n        mkdir(p, mode, cb) {\r\n            // Dropbox's create_folder is recursive. Check if parent exists.\r\n            const parent = dirname(p);\r\n            this.stat(parent, false, (e, stats) => {\r\n                if (e) {\r\n                    cb(e);\r\n                }\r\n                else if (stats && !stats.isDirectory()) {\r\n                    cb(FileError.ENOTDIR(parent));\r\n                }\r\n                else {\r\n                    const arg = {\r\n                        path: FixPath(p)\r\n                    };\r\n                    this._client.filesCreateFolderV2(arg).then(() => cb()).catch((e) => {\r\n                        const err = ExtractTheFuckingError(e);\r\n                        if (err['.tag'] === \"too_many_write_operations\") {\r\n                            // Retry in a bit.\r\n                            setTimeout(() => this.mkdir(p, mode, cb), 500 + (300 * (Math.random())));\r\n                        }\r\n                        else {\r\n                            cb(WriteErrorToError(ExtractTheFuckingError(e).path, p, GetErrorMessage(e)));\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Get the names of the files in a directory\r\n         */\r\n        readdir(path, cb) {\r\n            const arg = {\r\n                path: FixPath(path)\r\n            };\r\n            this._client.filesListFolder(arg).then((res) => {\r\n                ContinueReadingDir(this._client, path, res, [], cb);\r\n            }).catch((e) => {\r\n                ProcessListFolderError(e, path, cb);\r\n            });\r\n        }\r\n        /**\r\n         * (Internal) Syncs file to Dropbox.\r\n         */\r\n        _syncFile(p, d, cb) {\r\n            const blob = new Blob([buffer2ArrayBuffer(d)], { type: \"octet/stream\" });\r\n            const arg = {\r\n                contents: blob,\r\n                path: FixPath(p),\r\n                mode: {\r\n                    '.tag': 'overwrite'\r\n                }\r\n            };\r\n            this._client.filesUpload(arg).then(() => {\r\n                cb();\r\n            }).catch((e) => {\r\n                const err = ExtractTheFuckingError(e);\r\n                switch (err['.tag']) {\r\n                    case 'path':\r\n                        const upError = err;\r\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\r\n                        break;\r\n                    case 'too_many_write_operations':\r\n                        setTimeout(() => this._syncFile(p, d, cb), 500 + (300 * (Math.random())));\r\n                        break;\r\n                    case 'other':\r\n                    default:\r\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\r\n                        break;\r\n                }\r\n            });\r\n        }\r\n    }\r\n    DropboxProvider.Name = \"DropboxV2\";\r\n    DropboxProvider.Options = {\r\n        client: {\r\n            type: \"object\",\r\n            description: \"An *authenticated* Dropbox client. Must be from the 2.5.x JS SDK.\"\r\n        }\r\n    };\r\n    function ProcessListFolderError(e, path, cb) {\r\n        const err = ExtractTheFuckingError(e);\r\n        switch (err['.tag']) {\r\n            case 'path':\r\n                const pathError = err;\r\n                cb(LookupErrorToError(pathError.path, path, GetErrorMessage(e)));\r\n                break;\r\n            case 'other':\r\n            default:\r\n                cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\r\n                break;\r\n        }\r\n    }\r\n    function ContinueReadingDir(client, path, res, previousEntries, cb) {\r\n        const newEntries = res.entries.map((e) => e.path_display).filter((p) => !!p);\r\n        const entries = previousEntries.concat(newEntries);\r\n        if (!res.has_more) {\r\n            cb(null, entries);\r\n        }\r\n        else {\r\n            const arg = {\r\n                cursor: res.cursor\r\n            };\r\n            client.filesListFolderContinue(arg).then((res) => {\r\n                ContinueReadingDir(client, path, res, entries, cb);\r\n            }).catch((e) => {\r\n                ProcessListFolderError(e, path, cb);\r\n            });\r\n        }\r\n    }\r\n\r\n    DropboxProvider.DropboxFile = DropboxFile;\r\n\r\n    registry.add(\"dropbox\",DropboxProvider);\r\n\r\n    return  files.providers.DropboxProvider= DropboxProvider;\r\n    \r\n});\ndefine('skylark-io-files/providers/html5/html5-lfs-file',[\r\n    \"../../utils\",\r\n    '../../preload-file'\r\n], function (utils,PreloadFile) {\r\n    'use strict';\r\n\r\n    const { buffer2ArrayBuffer, arrayBuffer2Buffer } = utils;\r\n\r\n    // A note about getFile and getDirectory options:\r\n    // These methods are called at numerous places in this file, and are passed\r\n    // some combination of these two options:\r\n    //   - create: If true, the entry will be created if it doesn't exist.\r\n    //             If false, an error will be thrown if it doesn't exist.\r\n    //   - exclusive: If true, only create the entry if it doesn't already exist,\r\n    //                and throw an error if it does.\r\n    class Html5LfsFile extends PreloadFile {\r\n        constructor(fs, entry, path, flag, stat, contents) {\r\n            super(fs, path, flag, stat, contents);\r\n            this._entry = entry;\r\n        }\r\n        sync(cb) {\r\n            if (!this.isDirty()) {\r\n                return cb();\r\n            }\r\n            this._entry.createWriter((writer) => {\r\n                const buffer = this.getBuffer();\r\n                const blob = new Blob([buffer2ArrayBuffer(buffer)]);\r\n                const length = blob.size;\r\n                writer.onwriteend = (err) => {\r\n                    writer.onwriteend = null;\r\n                    writer.onerror = null;\r\n                    writer.truncate(length);\r\n                    this.resetDirty();\r\n                    cb();\r\n                };\r\n                writer.onerror = (err) => {\r\n                    cb(convertError(err, this.getPath(), false));\r\n                };\r\n                writer.write(blob);\r\n            });\r\n        }\r\n        close(cb) {\r\n            this.sync(cb);\r\n        }\r\n    }\r\n\r\n\r\n    return Html5LfsFile;\r\n});\ndefine('skylark-io-files/providers/html5/html5-lfs-provider',[\r\n    \"skylark-langx-async\",\r\n    \"skylark-langx-paths\",\r\n    \"../../files\",\r\n    \"../registry\",\r\n    '../../preload-file',\r\n    \"../base-provider\",\r\n    '../../error-codes',\r\n    '../../file-error',\r\n    '../../action-type',\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../../utils',\r\n    \"./html5-lfs-file\"\r\n], function (async,paths, files,registry, PreloadFile, BaseProvider, ErrorCodes, FileError,ActionType, Stats,FileType, utils,Html5LfsFile) {\r\n    'use strict';\r\n\r\n    const asyncEach = async.each;\r\n\r\n    const { buffer2ArrayBuffer, arrayBuffer2Buffer } = utils;\r\n\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    function isDirectoryEntry(entry) {\r\n        return entry.isDirectory;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    const _getFS = window.webkitRequestProvider || window.requestProvider || null;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    function _requestQuota(type, size, success, errorCallback) {\r\n        // We cast navigator and window to '<any>' because everything here is\r\n        // nonstandard functionality, despite the fact that Chrome has the only\r\n        // implementation of the HTML5FS and is likely driving the standardization\r\n        // process. Thus, these objects defined off of navigator and window are not\r\n        // present in the DefinitelyTyped TypeScript typings for Provider.\r\n        if (typeof navigator['webkitPersistentStorage'] !== 'undefined') {\r\n            switch (type) {\r\n                case window.PERSISTENT:\r\n                    navigator.webkitPersistentStorage.requestQuota(size, success, errorCallback);\r\n                    break;\r\n                case window.TEMPORARY:\r\n                    navigator.webkitTemporaryStorage.requestQuota(size, success, errorCallback);\r\n                    break;\r\n                default:\r\n                    errorCallback(new TypeError(`Invalid storage type: ${type}`));\r\n                    break;\r\n            }\r\n        }\r\n        else {\r\n            window.webkitStorageInfo.requestQuota(type, size, success, errorCallback);\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function _toArray(list) {\r\n        return Array.prototype.slice.call(list || [], 0);\r\n    }\r\n    /**\r\n     * Converts the given DOMError into an appropriate FileError.\r\n     * @url https://developer.mozilla.org/en-US/docs/Web/API/DOMError\r\n     * @hidden\r\n     */\r\n    function convertError(err, p, expectedDir) {\r\n        switch (err.name) {\r\n            /* The user agent failed to create a file or directory due to the existence of a file or\r\n                directory with the same path.  */\r\n            case \"PathExistsError\":\r\n                return FileError.EEXIST(p);\r\n            /* The operation failed because it would cause the application to exceed its storage quota.  */\r\n            case 'QuotaExceededError':\r\n                return FileError.FileError(ErrorCodes.ENOSPC, p);\r\n            /*  A required file or directory could not be found at the time an operation was processed.   */\r\n            case 'NotFoundError':\r\n                return FileError.ENOENT(p);\r\n            /* This is a security error code to be used in situations not covered by any other error codes.\r\n                - A required file was unsafe for access within a Web application\r\n                - Too many calls are being made on filesystem resources */\r\n            case 'SecurityError':\r\n                return FileError.FileError(ErrorCodes.EACCES, p);\r\n            /* The modification requested was illegal. Examples of invalid modifications include moving a\r\n                directory into its own child, moving a file into its parent directory without changing its name,\r\n                or copying a directory to a path occupied by a file.  */\r\n            case 'InvalidModificationError':\r\n                return FileError.FileError(ErrorCodes.EPERM, p);\r\n            /* The user has attempted to look up a file or directory, but the Entry found is of the wrong type\r\n                [e.g. is a DirectoryEntry when the user requested a FileEntry].  */\r\n            case 'TypeMismatchError':\r\n                return FileError.FileError(expectedDir ? ErrorCodes.ENOTDIR : ErrorCodes.EISDIR, p);\r\n            /* A path or URL supplied to the API was malformed.  */\r\n            case \"EncodingError\":\r\n            /* An operation depended on state cached in an interface object, but that state that has changed\r\n                since it was read from disk.  */\r\n            case \"InvalidStateError\":\r\n            /* The user attempted to write to a file or directory which could not be modified due to the state\r\n                of the underlying filesystem.  */\r\n            case \"NoModificationAllowedError\":\r\n            default:\r\n                return FileError.FileError(ErrorCodes.EINVAL, p);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A read-write filesystem backed by the HTML5 Provider API.\r\n     *\r\n     * As the HTML5 Provider is only implemented in Blink, this interface is\r\n     * only available in Chrome.\r\n     */\r\n    class Html5LfsProvider extends BaseProvider {\r\n\r\n        /**\r\n         * @param size storage quota to request, in megabytes. Allocated value may be less.\r\n         * @param type window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT.\r\n         */\r\n        constructor(size = 5, type = window.PERSISTENT) {\r\n            super();\r\n            // Convert MB to bytes.\r\n            this.size = 1024 * 1024 * size;\r\n            this.type = type;\r\n        }\r\n\r\n        /**\r\n         * Creates an Html5LfsProvider instance with the given options.\r\n         */\r\n        static Create(opts, cb) {\r\n            const fs = new Html5LfsProvider(opts.size, opts.type);\r\n            fs._allocate((e) => e ? cb(e) : cb(null, fs));\r\n        }\r\n\r\n        static isAvailable() {\r\n            return !!_getFS;\r\n        }\r\n\r\n        getName() {\r\n            return Html5LfsProvider.Name;\r\n        }\r\n\r\n        isReadOnly() {\r\n            return false;\r\n        }\r\n\r\n        supportsSymlinks() {\r\n            return false;\r\n        }\r\n\r\n        supportsProps() {\r\n            return false;\r\n        }\r\n\r\n        supportsSynch() {\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Deletes everything in the FS. Used for testing.\r\n         * Karma clears the storage after you quit it but not between runs of the test\r\n         * suite, and the tests expect an empty FS every time.\r\n         */\r\n        empty(mainCb) {\r\n            // Get a list of all entries in the root directory to delete them\r\n            this._readdir('/', (err, entries) => {\r\n                if (err) {\r\n                    mainCb(err);\r\n                }\r\n                else {\r\n                    // Called when every entry has been operated on\r\n                    const finished = (er) => {\r\n                        if (err) {\r\n                            mainCb(err);\r\n                        }\r\n                        else {\r\n                            mainCb();\r\n                        }\r\n                    };\r\n                    // Removes files and recursively removes directories\r\n                    const deleteEntry = (entry, cb) => {\r\n                        const succ = () => {\r\n                            cb();\r\n                        };\r\n                        const error = (err) => {\r\n                            cb(convertError(err, entry.fullPath, !entry.isDirectory));\r\n                        };\r\n                        if (isDirectoryEntry(entry)) {\r\n                            entry.removeRecursively(succ, error);\r\n                        }\r\n                        else {\r\n                            entry.remove(succ, error);\r\n                        }\r\n                    };\r\n                    // Loop through the entries and remove them, then call the callback\r\n                    // when they're all finished.\r\n                    asyncEach(entries, deleteEntry, finished);\r\n                }\r\n            });\r\n        }\r\n\r\n        rename(oldPath, newPath, cb) {\r\n            let semaphore = 2;\r\n            let successCount = 0;\r\n            const root = this.fs.root;\r\n            let currentPath = oldPath;\r\n            const error = (err) => {\r\n                if (--semaphore <= 0) {\r\n                    cb(convertError(err, currentPath, false));\r\n                }\r\n            };\r\n            const success = (file) => {\r\n                if (++successCount === 2) {\r\n                    return cb(new FileError(ErrorCodes.EINVAL, \"Something was identified as both a file and a directory. This should never happen.\"));\r\n                }\r\n                // SPECIAL CASE: If newPath === oldPath, and the path exists, then\r\n                // this operation trivially succeeds.\r\n                if (oldPath === newPath) {\r\n                    return cb();\r\n                }\r\n                // Get the new parent directory.\r\n                currentPath = paths.dirname(newPath);\r\n                root.getDirectory(currentPath, {}, (parentDir) => {\r\n                    currentPath = paths.basename(newPath);\r\n                    file.moveTo(parentDir, currentPath, (entry) => { cb(); }, (err) => {\r\n                        // SPECIAL CASE: If oldPath is a directory, and newPath is a\r\n                        // file, rename should delete the file and perform the move.\r\n                        if (file.isDirectory) {\r\n                            currentPath = newPath;\r\n                            // Unlink only works on files. Try to delete newPath.\r\n                            this.unlink(newPath, (e) => {\r\n                                if (e) {\r\n                                    // newPath is probably a directory.\r\n                                    error(err);\r\n                                }\r\n                                else {\r\n                                    // Recur, now that newPath doesn't exist.\r\n                                    this.rename(oldPath, newPath, cb);\r\n                                }\r\n                            });\r\n                        }\r\n                        else {\r\n                            error(err);\r\n                        }\r\n                    });\r\n                }, error);\r\n            };\r\n            // We don't know if oldPath is a *file* or a *directory*, and there's no\r\n            // way to stat items. So launch both requests, see which one succeeds.\r\n            root.getFile(oldPath, {}, success, error);\r\n            root.getDirectory(oldPath, {}, success, error);\r\n        }\r\n\r\n        stat(path, isLstat, cb) {\r\n            // Throw an error if the entry doesn't exist, because then there's nothing\r\n            // to stat.\r\n            const opts = {\r\n                create: false\r\n            };\r\n            // Called when the path has been successfully loaded as a file.\r\n            const loadAsFile = (entry) => {\r\n                const fileFromEntry = (file) => {\r\n                    const stat = new Stats(FileType.FILE, file.size);\r\n                    cb(null, stat);\r\n                };\r\n                entry.file(fileFromEntry, failedToLoad);\r\n            };\r\n            // Called when the path has been successfully loaded as a directory.\r\n            const loadAsDir = (dir) => {\r\n                // Directory entry size can't be determined from the HTML5 FS API, and is\r\n                // implementation-dependant anyway, so a dummy value is used.\r\n                const size = 4096;\r\n                const stat = new Stats(FileType.DIRECTORY, size);\r\n                cb(null, stat);\r\n            };\r\n            // Called when the path couldn't be opened as a directory or a file.\r\n            const failedToLoad = (err) => {\r\n                cb(convertError(err, path, false /* Unknown / irrelevant */));\r\n            };\r\n            // Called when the path couldn't be opened as a file, but might still be a\r\n            // directory.\r\n            const failedToLoadAsFile = () => {\r\n                this.fs.root.getDirectory(path, opts, loadAsDir, failedToLoad);\r\n            };\r\n            // No method currently exists to determine whether a path refers to a\r\n            // directory or a file, so this implementation tries both and uses the first\r\n            // one that succeeds.\r\n            this.fs.root.getFile(path, opts, loadAsFile, failedToLoadAsFile);\r\n        }\r\n        open(p, flags, mode, cb) {\r\n            // XXX: err is a DOMError\r\n            const error = (err) => {\r\n                if (err.name === 'InvalidModificationError' && flags.isExclusive()) {\r\n                    cb(FileError.EEXIST(p));\r\n                }\r\n                else {\r\n                    cb(convertError(err, p, false));\r\n                }\r\n            };\r\n            this.fs.root.getFile(p, {\r\n                create: flags.pathNotExistsAction() === ActionType.CREATE_FILE,\r\n                exclusive: flags.isExclusive()\r\n            }, (entry) => {\r\n                // Try to fetch corresponding file.\r\n                entry.file((file) => {\r\n                    const reader = new FileReader();\r\n                    reader.onloadend = (event) => {\r\n                        const bfsFile = this._makeFile(p, entry, flags, file, reader.result);\r\n                        cb(null, bfsFile);\r\n                    };\r\n                    reader.onerror = (ev) => {\r\n                        error(reader.error);\r\n                    };\r\n                    reader.readAsArrayBuffer(file);\r\n                }, error);\r\n            }, error);\r\n        }\r\n        unlink(path, cb) {\r\n            this._remove(path, cb, true);\r\n        }\r\n        rmdir(path, cb) {\r\n            // Check if directory is non-empty, first.\r\n            this.readdir(path, (e, files) => {\r\n                if (e) {\r\n                    cb(e);\r\n                }\r\n                else if (files.length > 0) {\r\n                    cb(FileError.ENOTEMPTY(path));\r\n                }\r\n                else {\r\n                    this._remove(path, cb, false);\r\n                }\r\n            });\r\n        }\r\n        mkdir(path, mode, cb) {\r\n            // Create the directory, but throw an error if it already exists, as per\r\n            // mkdir(1)\r\n            const opts = {\r\n                create: true,\r\n                exclusive: true\r\n            };\r\n            const success = (dir) => {\r\n                cb();\r\n            };\r\n            const error = (err) => {\r\n                cb(convertError(err, path, true));\r\n            };\r\n            this.fs.root.getDirectory(path, opts, success, error);\r\n        }\r\n        /**\r\n         * Map _readdir's list of `FileEntry`s to their names and return that.\r\n         */\r\n        readdir(path, cb) {\r\n            this._readdir(path, (e, entries) => {\r\n                if (entries) {\r\n                    const rv = [];\r\n                    for (const entry of entries) {\r\n                        rv.push(entry.name);\r\n                    }\r\n                    cb(null, rv);\r\n                }\r\n                else {\r\n                    return cb(e);\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Returns a BrowserFS object representing a File.\r\n         */\r\n        _makeFile(path, entry, flag, stat, data = new ArrayBuffer(0)) {\r\n            const stats = new Stats(FileType.FILE, stat.size);\r\n            const buffer = arrayBuffer2Buffer(data);\r\n            return new Html5LfsFile(this, entry, path, flag, stats, buffer);\r\n        }\r\n        /**\r\n         * Returns an array of `FileEntry`s. Used internally by empty and readdir.\r\n         */\r\n        _readdir(path, cb) {\r\n            const error = (err) => {\r\n                cb(convertError(err, path, true));\r\n            };\r\n            // Grab the requested directory.\r\n            this.fs.root.getDirectory(path, { create: false }, (dirEntry) => {\r\n                const reader = dirEntry.createReader();\r\n                let entries = [];\r\n                // Call the reader.readEntries() until no more results are returned.\r\n                const readEntries = () => {\r\n                    reader.readEntries(((results) => {\r\n                        if (results.length) {\r\n                            entries = entries.concat(_toArray(results));\r\n                            readEntries();\r\n                        }\r\n                        else {\r\n                            cb(null, entries);\r\n                        }\r\n                    }), error);\r\n                };\r\n                readEntries();\r\n            }, error);\r\n        }\r\n        \r\n        /**\r\n         * Requests a storage quota from the browser to back this FS.\r\n         */\r\n        _allocate(cb) {\r\n            const success = (fs) => {\r\n                this.fs = fs;\r\n                cb();\r\n            };\r\n            const error = (err) => {\r\n                cb(convertError(err, \"/\", true));\r\n            };\r\n            if (this.type === window.PERSISTENT) {\r\n                _requestQuota(this.type, this.size, (granted) => {\r\n                    _getFS(this.type, granted, success, error);\r\n                }, error);\r\n            }\r\n            else {\r\n                _getFS(this.type, this.size, success, error);\r\n            }\r\n        }\r\n        /**\r\n         * Delete a file or directory from the file system\r\n         * isFile should reflect which call was made to remove the it (`unlink` or\r\n         * `rmdir`). If this doesn't match what's actually at `path`, an error will be\r\n         * returned\r\n         */\r\n        _remove(path, cb, isFile) {\r\n            const success = (entry) => {\r\n                const succ = () => {\r\n                    cb();\r\n                };\r\n                const err = (err) => {\r\n                    cb(convertError(err, path, !isFile));\r\n                };\r\n                entry.remove(succ, err);\r\n            };\r\n            const error = (err) => {\r\n                cb(convertError(err, path, !isFile));\r\n            };\r\n            // Deleting the entry, so don't create it\r\n            const opts = {\r\n                create: false\r\n            };\r\n            if (isFile) {\r\n                this.fs.root.getFile(path, opts, success, error);\r\n            }\r\n            else {\r\n                this.fs.root.getDirectory(path, opts, success, error);\r\n            }\r\n        }\r\n    }\r\n    Html5LfsProvider.Name = \"Html5LfsProvider\";\r\n    Html5LfsProvider.Options = {\r\n        size: {\r\n            type: \"number\",\r\n            optional: true,\r\n            description: \"Storage quota to request, in megabytes. Allocated value may be less. Defaults to 5.\"\r\n        },\r\n        type: {\r\n            type: \"number\",\r\n            optional: true,\r\n            description: \"window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT.\"\r\n        }\r\n    };\r\n\r\n    Html5LfsProvider.Html5LfsFile = Html5LfsFile;\r\n\r\n    registry.add(\"html5Lfs\",Html5LfsProvider);\r\n\r\n\r\n    return Html5LfsProvider;\r\n});\ndefine('skylark-io-files/providers/http/xhr',[\r\n    \"skylark-langx-binary/buffer\",\r\n    '../../error-codes',\r\n    '../../file-error',\r\n    \"../../utils\"\r\n], function (Buffer,ErrorCodes,FileError,utils) {\r\n    'use strict';\r\n    /**\r\n     * Contains utility methods for performing a variety of tasks with\r\n     * XmlHttpRequest across browsers.\r\n     */\r\n    const { isIE, emptyBuffer } = utils;\r\n\r\n\r\n    const xhrIsAvailable = (typeof (XMLHttpRequest) !== \"undefined\" && XMLHttpRequest !== null);\r\n    function asyncDownloadFileModern(p, type, cb) {\r\n        const req = new XMLHttpRequest();\r\n        req.open('GET', p, true);\r\n        let jsonSupported = true;\r\n        switch (type) {\r\n            case 'buffer':\r\n                req.responseType = 'arraybuffer';\r\n                break;\r\n            case 'json':\r\n                // Some browsers don't support the JSON response type.\r\n                // They either reset responseType, or throw an exception.\r\n                // @see https://github.com/Modernizr/Modernizr/blob/master/src/testXhrType.js\r\n                try {\r\n                    req.responseType = 'json';\r\n                    jsonSupported = req.responseType === 'json';\r\n                }\r\n                catch (e) {\r\n                    jsonSupported = false;\r\n                }\r\n                break;\r\n            default:\r\n                return cb(new FileError(ErrorCodes.EINVAL, \"Invalid download type: \" + type));\r\n        }\r\n        req.onreadystatechange = function (e) {\r\n            if (req.readyState === 4) {\r\n                if (req.status === 200) {\r\n                    switch (type) {\r\n                        case 'buffer':\r\n                            // XXX: WebKit-based browsers return *null* when XHRing an empty file.\r\n                            return cb(null, req.response ? Buffer.from(req.response) : emptyBuffer());\r\n                        case 'json':\r\n                            if (jsonSupported) {\r\n                                return cb(null, req.response);\r\n                            }\r\n                            else {\r\n                                return cb(null, JSON.parse(req.responseText));\r\n                            }\r\n                    }\r\n                }\r\n                else {\r\n                    return cb(new FileError(ErrorCodes.EIO, `XHR error: response returned code ${req.status}`));\r\n                }\r\n            }\r\n        };\r\n        req.send();\r\n    }\r\n    function syncDownloadFileModern(p, type) {\r\n        const req = new XMLHttpRequest();\r\n        req.open('GET', p, false);\r\n        // On most platforms, we cannot set the responseType of synchronous downloads.\r\n        // @todo Test for this; IE10 allows this, as do older versions of Chrome/FF.\r\n        let data = null;\r\n        let err = null;\r\n        // Classic hack to download binary data as a string.\r\n        req.overrideMimeType('text/plain; charset=x-user-defined');\r\n        req.onreadystatechange = function (e) {\r\n            if (req.readyState === 4) {\r\n                if (req.status === 200) {\r\n                    switch (type) {\r\n                        case 'buffer':\r\n                            // Convert the text into a buffer.\r\n                            const text = req.responseText;\r\n                            data = Buffer.alloc(text.length);\r\n                            // Throw away the upper bits of each character.\r\n                            for (let i = 0; i < text.length; i++) {\r\n                                // This will automatically throw away the upper bit of each\r\n                                // character for us.\r\n                                data[i] = text.charCodeAt(i);\r\n                            }\r\n                            return;\r\n                        case 'json':\r\n                            data = JSON.parse(req.responseText);\r\n                            return;\r\n                    }\r\n                }\r\n                else {\r\n                    err = new FileError(ErrorCodes.EIO, `XHR error: response returned code ${req.status}`);\r\n                    return;\r\n                }\r\n            }\r\n        };\r\n        req.send();\r\n        if (err) {\r\n            throw err;\r\n        }\r\n        return data;\r\n    }\r\n    function syncDownloadFileIE10(p, type) {\r\n        const req = new XMLHttpRequest();\r\n        req.open('GET', p, false);\r\n        switch (type) {\r\n            case 'buffer':\r\n                req.responseType = 'arraybuffer';\r\n                break;\r\n            case 'json':\r\n                // IE10 does not support the JSON type.\r\n                break;\r\n            default:\r\n                throw new FileError(ErrorCodes.EINVAL, \"Invalid download type: \" + type);\r\n        }\r\n        let data;\r\n        let err;\r\n        req.onreadystatechange = function (e) {\r\n            if (req.readyState === 4) {\r\n                if (req.status === 200) {\r\n                    switch (type) {\r\n                        case 'buffer':\r\n                            data = Buffer.from(req.response);\r\n                            break;\r\n                        case 'json':\r\n                            data = JSON.parse(req.response);\r\n                            break;\r\n                    }\r\n                }\r\n                else {\r\n                    err = new FileError(ErrorCodes.EIO, `XHR error: response returned code ${req.status}`);\r\n                }\r\n            }\r\n        };\r\n        req.send();\r\n        if (err) {\r\n            throw err;\r\n        }\r\n        return data;\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function getFileSize(async, p, cb) {\r\n        const req = new XMLHttpRequest();\r\n        req.open('HEAD', p, async);\r\n        req.onreadystatechange = function (e) {\r\n            if (req.readyState === 4) {\r\n                if (req.status === 200) {\r\n                    try {\r\n                        return cb(null, parseInt(req.getResponseHeader('Content-Length') || '-1', 10));\r\n                    }\r\n                    catch (e) {\r\n                        // In the event that the header isn't present or there is an error...\r\n                        return cb(new FileError(ErrorCodes.EIO, \"XHR HEAD error: Could not read content-length.\"));\r\n                    }\r\n                }\r\n                else {\r\n                    return cb(new FileError(ErrorCodes.EIO, `XHR HEAD error: response returned code ${req.status}`));\r\n                }\r\n            }\r\n        };\r\n        req.send();\r\n    }\r\n    /**\r\n     * Asynchronously download a file as a buffer or a JSON object.\r\n     * Note that the third function signature with a non-specialized type is\r\n     * invalid, but TypeScript requires it when you specialize string arguments to\r\n     * constants.\r\n     * @hidden\r\n     */\r\n    let asyncDownloadFile = asyncDownloadFileModern;\r\n    /**\r\n     * Synchronously download a file as a buffer or a JSON object.\r\n     * Note that the third function signature with a non-specialized type is\r\n     * invalid, but TypeScript requires it when you specialize string arguments to\r\n     * constants.\r\n     * @hidden\r\n     */\r\n    let syncDownloadFile = (isIE && typeof Blob !== 'undefined') ? syncDownloadFileIE10 : syncDownloadFileModern;\r\n    /**\r\n     * Synchronously retrieves the size of the given file in bytes.\r\n     * @hidden\r\n     */\r\n    function getFileSizeSync(p) {\r\n        let rv = -1;\r\n        getFileSize(false, p, function (err, size) {\r\n            if (err) {\r\n                throw err;\r\n            }\r\n            rv = size;\r\n        });\r\n        return rv;\r\n    }\r\n    /**\r\n     * Asynchronously retrieves the size of the given file in bytes.\r\n     * @hidden\r\n     */\r\n    function getFileSizeAsync(p, cb) {\r\n        getFileSize(true, p, cb);\r\n    }\r\n\r\n\r\n\r\n    return {\r\n        xhrIsAvailable: xhrIsAvailable,\r\n        asyncDownloadFile: asyncDownloadFile,\r\n        syncDownloadFile: syncDownloadFile,\r\n        getFileSizeSync: getFileSizeSync,\r\n        getFileSizeAsync: getFileSizeAsync\r\n    };\r\n});\ndefine('skylark-io-files/providers/http/fetch',[\r\n    \"skylark-langx-binary/buffer\",\r\n    '../../error-codes',\r\n    '../../file-error'\r\n], function (Buffer,ErrorCodes,FileError) {\r\n    'use strict';\r\n\r\n\r\n    const fetchIsAvailable = (typeof (fetch) !== \"undefined\" && fetch !== null);\r\n\r\n    function fetchFileAsync(p, type, cb) {\r\n        let request;\r\n        try {\r\n            request = fetch(p);\r\n        }\r\n        catch (e) {\r\n            // XXX: fetch will throw a TypeError if the URL has credentials in it\r\n            return cb(new FileError(ErrorCodes.EINVAL, e.message));\r\n        }\r\n        request\r\n            .then((res) => {\r\n            if (!res.ok) {\r\n                return cb(new FileError(ErrorCodes.EIO, `fetch error: response returned code ${res.status}`));\r\n            }\r\n            else {\r\n                switch (type) {\r\n                    case 'buffer':\r\n                        res.arrayBuffer()\r\n                            .then((buf) => cb(null, Buffer.from(buf)))\r\n                            .catch((err) => cb(new FileError(ErrorCodes.EIO, err.message)));\r\n                        break;\r\n                    case 'json':\r\n                        res.json()\r\n                            .then((json) => cb(null, json))\r\n                            .catch((err) => cb(new FileError(ErrorCodes.EIO, err.message)));\r\n                        break;\r\n                    default:\r\n                        cb(new FileError(ErrorCodes.EINVAL, \"Invalid download type: \" + type));\r\n                }\r\n            }\r\n        })\r\n            .catch((err) => cb(new FileError(ErrorCodes.EIO, err.message)));\r\n    }\r\n\r\n    /**\r\n     * Asynchronously retrieves the size of the given file in bytes.\r\n     * @hidden\r\n     */\r\n\r\n    function fetchFileSizeAsync(p, cb) {\r\n        fetch(p, { method: 'HEAD' })\r\n            .then((res) => {\r\n            if (!res.ok) {\r\n                return cb(new FileError(ErrorCodes.EIO, `fetch HEAD error: response returned code ${res.status}`));\r\n            }\r\n            else {\r\n                return cb(null, parseInt(res.headers.get('Content-Length') || '-1', 10));\r\n            }\r\n        })\r\n            .catch((err) => cb(new FileError(ErrorCodes.EIO, err.message)));\r\n    }\r\n\r\n    return {\r\n        fetchIsAvailable: fetchIsAvailable,\r\n        fetchFileAsync: fetchFileAsync,\r\n        fetchFileSizeAsync: fetchFileSizeAsync\r\n    };\r\n});\ndefine('skylark-io-files/inodes/dir-inode',[\r\n    \"skylark-langx-paths\",\r\n    '../stats',\r\n    '../file-type'\r\n], function (paths, Stats,FileType) {\r\n    'use strict';\r\n\r\n    /**\r\n     * Inode for a directory. Currently only contains the directory listing.\r\n     */\r\n    class DirInode {\r\n        /**\r\n         * Constructs an inode for a directory.\r\n         */\r\n        constructor(data = null) {\r\n            this.data = data;\r\n            this._ls = {};\r\n        }\r\n        isFile() {\r\n            return false;\r\n        }\r\n        isDir() {\r\n            return true;\r\n        }\r\n        getData() { return this.data; }\r\n        /**\r\n         * Return a Stats object for this inode.\r\n         * @todo Should probably remove this at some point. This isn't the\r\n         *       responsibility of the FileIndex.\r\n         */\r\n        getStats() {\r\n            return new Stats(FileType.DIRECTORY, 4096, 0x16D);\r\n        }\r\n        /**\r\n         * Returns the directory listing for this directory. Paths in the directory are\r\n         * relative to the directory's path.\r\n         * @return The directory listing for this directory.\r\n         */\r\n        getListing() {\r\n            return Object.keys(this._ls);\r\n        }\r\n        /**\r\n         * Returns the inode for the indicated item, or null if it does not exist.\r\n         * @param p Name of item in this directory.\r\n         */\r\n        getItem(p) {\r\n            const item = this._ls[p];\r\n            return item ? item : null;\r\n        }\r\n        /**\r\n         * Add the given item to the directory listing. Note that the given inode is\r\n         * not copied, and will be mutated by the DirInode if it is a DirInode.\r\n         * @param p Item name to add to the directory listing.\r\n         * @param inode The inode for the\r\n         *   item to add to the directory inode.\r\n         * @return True if it was added, false if it already existed.\r\n         */\r\n        addItem(p, inode) {\r\n            if (p in this._ls) {\r\n                return false;\r\n            }\r\n            this._ls[p] = inode;\r\n            return true;\r\n        }\r\n        /**\r\n         * Removes the given item from the directory listing.\r\n         * @param p Name of item to remove from the directory listing.\r\n         * @return Returns the item\r\n         *   removed, or null if the item did not exist.\r\n         */\r\n        remItem(p) {\r\n            const item = this._ls[p];\r\n            if (item === undefined) {\r\n                return null;\r\n            }\r\n            delete this._ls[p];\r\n            return item;\r\n        }\r\n    }\r\n\r\n    /**\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    DirInode.isDirInode =  function isDirInode(inode) {\r\n        return !!inode && inode.isDir();\r\n    }\r\n\r\n\r\n    return DirInode;\r\n});\ndefine('skylark-io-files/inodes/file-inode',[\r\n], function () {\r\n    'use strict';\r\n\r\n    /**\r\n     * Inode for a file. Stores an arbitrary (filesystem-specific) data payload.\r\n     */\r\n    class FileInode {\r\n        constructor(data) {\r\n            this.data = data;\r\n        }\r\n        isFile() { return true; }\r\n        isDir() { return false; }\r\n        getData() { return this.data; }\r\n        setData(data) { this.data = data; }\r\n    }\r\n    /**\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    FileInode.isFileInode = function isFileInode(inode) {\r\n        return !!inode && inode.isFile();\r\n    };\r\n\r\n\r\n    return FileInode;\r\n\r\n});\ndefine('skylark-io-files/inodes/file-index',[\r\n    \"skylark-langx-paths\",\r\n    '../stats',\r\n    '../file-type',\r\n    \"./dir-inode\",\r\n    \"./file-inode\"\r\n], function (paths, Stats,FileType,DirInode,FileInode) {\r\n    'use strict';\r\n\r\n    /**\r\n     * A simple class for storing a filesystem index. Assumes that all paths passed\r\n     * to it are *absolute* paths.\r\n     *\r\n     * Can be used as a partial or a full index, although care must be taken if used\r\n     * for the former purpose, especially when directories are concerned.\r\n     */\r\n    class FileIndex {\r\n        /**\r\n         * Constructs a new FileIndex.\r\n         */\r\n        constructor() {\r\n            // _index is a single-level key,value store that maps *directory* paths to\r\n            // DirInodes. File information is only contained in DirInodes themselves.\r\n            this._index = {};\r\n            // Create the root directory.\r\n            this.addPath('/', new DirInode());\r\n        }\r\n        /**\r\n         * Static method for constructing indices from a JSON listing.\r\n         * @param listing Directory listing generated by tools/XHRIndexer.coffee\r\n         * @return A new FileIndex object.\r\n         */\r\n        static fromListing(listing) {\r\n            const idx = new FileIndex();\r\n            // Add a root DirNode.\r\n            const rootInode = new DirInode();\r\n            idx._index['/'] = rootInode;\r\n            const queue = [['', listing, rootInode]];\r\n            while (queue.length > 0) {\r\n                let inode;\r\n                const next = queue.pop();\r\n                const pwd = next[0];\r\n                const tree = next[1];\r\n                const parent = next[2];\r\n                for (const node in tree) {\r\n                    if (tree.hasOwnProperty(node)) {\r\n                        const children = tree[node];\r\n                        const name = `${pwd}/${node}`;\r\n                        if (children) {\r\n                            idx._index[name] = inode = new DirInode();\r\n                            queue.push([name, children, inode]);\r\n                        }\r\n                        else {\r\n                            // This inode doesn't have correct size information, noted with -1.\r\n                            inode = new FileInode(new Stats(FileType.FILE, -1, 0x16D));\r\n                        }\r\n                        if (parent) {\r\n                            parent._ls[node] = inode;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return idx;\r\n        }\r\n        /**\r\n         * Runs the given function over all files in the index.\r\n         */\r\n        fileIterator(cb) {\r\n            for (const path in this._index) {\r\n                if (this._index.hasOwnProperty(path)) {\r\n                    const dir = this._index[path];\r\n                    const files = dir.getListing();\r\n                    for (const file of files) {\r\n                        const item = dir.getItem(file);\r\n                        if (FileInode.isFileInode(item)) {\r\n                            cb(item.getData());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Adds the given absolute path to the index if it is not already in the index.\r\n         * Creates any needed parent directories.\r\n         * @param path The path to add to the index.\r\n         * @param inode The inode for the\r\n         *   path to add.\r\n         * @return 'True' if it was added or already exists, 'false' if there\r\n         *   was an issue adding it (e.g. item in path is a file, item exists but is\r\n         *   different).\r\n         * @todo If adding fails and implicitly creates directories, we do not clean up\r\n         *   the new empty directories.\r\n         */\r\n        addPath(path, inode) {\r\n            if (!inode) {\r\n                throw new Error('Inode must be specified');\r\n            }\r\n            if (path[0] !== '/') {\r\n                throw new Error('Path must be absolute, got: ' + path);\r\n            }\r\n            // Check if it already exists.\r\n            if (this._index.hasOwnProperty(path)) {\r\n                return this._index[path] === inode;\r\n            }\r\n            const splitPath = this._split_path(path);\r\n            const dirpath = splitPath[0];\r\n            const itemname = splitPath[1];\r\n            // Try to add to its parent directory first.\r\n            let parent = this._index[dirpath];\r\n            if (parent === undefined && path !== '/') {\r\n                // Create parent.\r\n                parent = new DirInode();\r\n                if (!this.addPath(dirpath, parent)) {\r\n                    return false;\r\n                }\r\n            }\r\n            // Add myself to my parent.\r\n            if (path !== '/') {\r\n                if (!parent.addItem(itemname, inode)) {\r\n                    return false;\r\n                }\r\n            }\r\n            // If I'm a directory, add myself to the index.\r\n            if (DirInode.isDirInode(inode)) {\r\n                this._index[path] = inode;\r\n            }\r\n            return true;\r\n        }\r\n        /**\r\n         * Adds the given absolute path to the index if it is not already in the index.\r\n         * The path is added without special treatment (no joining of adjacent separators, etc).\r\n         * Creates any needed parent directories.\r\n         * @param path The path to add to the index.\r\n         * @param inode The inode for the\r\n         *   path to add.\r\n         * @return 'True' if it was added or already exists, 'false' if there\r\n         *   was an issue adding it (e.g. item in path is a file, item exists but is\r\n         *   different).\r\n         * @todo If adding fails and implicitly creates directories, we do not clean up\r\n         *   the new empty directories.\r\n         */\r\n        addPathFast(path, inode) {\r\n            const itemNameMark = path.lastIndexOf('/');\r\n            const parentPath = itemNameMark === 0 ? \"/\" : path.substring(0, itemNameMark);\r\n            const itemName = path.substring(itemNameMark + 1);\r\n            // Try to add to its parent directory first.\r\n            let parent = this._index[parentPath];\r\n            if (parent === undefined) {\r\n                // Create parent.\r\n                parent = new DirInode();\r\n                this.addPathFast(parentPath, parent);\r\n            }\r\n            if (!parent.addItem(itemName, inode)) {\r\n                return false;\r\n            }\r\n            // If adding a directory, add to the index as well.\r\n            if (inode.isDir()) {\r\n                this._index[path] = inode;\r\n            }\r\n            return true;\r\n        }\r\n        /**\r\n         * Removes the given path. Can be a file or a directory.\r\n         * @return The removed item,\r\n         *   or null if it did not exist.\r\n         */\r\n        removePath(path) {\r\n            const splitPath = this._split_path(path);\r\n            const dirpath = splitPath[0];\r\n            const itemname = splitPath[1];\r\n            // Try to remove it from its parent directory first.\r\n            const parent = this._index[dirpath];\r\n            if (parent === undefined) {\r\n                return null;\r\n            }\r\n            // Remove myself from my parent.\r\n            const inode = parent.remItem(itemname);\r\n            if (inode === null) {\r\n                return null;\r\n            }\r\n            // If I'm a directory, remove myself from the index, and remove my children.\r\n            if (DirInode.isDirInode(inode)) {\r\n                const children = inode.getListing();\r\n                for (const child of children) {\r\n                    this.removePath(path + '/' + child);\r\n                }\r\n                // Remove the directory from the index, unless it's the root.\r\n                if (path !== '/') {\r\n                    delete this._index[path];\r\n                }\r\n            }\r\n            return inode;\r\n        }\r\n        /**\r\n         * Retrieves the directory listing of the given path.\r\n         * @return An array of files in the given path, or 'null' if it does not exist.\r\n         */\r\n        ls(path) {\r\n            const item = this._index[path];\r\n            if (item === undefined) {\r\n                return null;\r\n            }\r\n            return item.getListing();\r\n        }\r\n        /**\r\n         * Returns the inode of the given item.\r\n         * @return Returns null if the item does not exist.\r\n         */\r\n        getInode(path) {\r\n            const splitPath = this._split_path(path);\r\n            const dirpath = splitPath[0];\r\n            const itemname = splitPath[1];\r\n            // Retrieve from its parent directory.\r\n            const parent = this._index[dirpath];\r\n            if (parent === undefined) {\r\n                return null;\r\n            }\r\n            // Root case\r\n            if (dirpath === path) {\r\n                return parent;\r\n            }\r\n            return parent.getItem(itemname);\r\n        }\r\n        /**\r\n         * Split into a (directory path, item name) pair\r\n         */\r\n        _split_path(p) {\r\n            const dirpath = paths.dirname(p);\r\n            const itemname = p.substr(dirpath.length + (dirpath === \"/\" ? 0 : 1));\r\n            return [dirpath, itemname];\r\n        }\r\n    }\r\n    \r\n\r\n    return FileIndex;\r\n});\ndefine('skylark-io-files/providers/http/http-provider',[\r\n    \"skylark-langx-async\",\r\n    \"skylark-langx-paths\",\r\n    \"../../files\",\r\n    \"../registry\",\r\n    '../../no-sync-file',\r\n    \"../base-provider\",\r\n    '../../error-codes',\r\n    '../../file-error',\r\n    '../../action-type',\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../../utils',\r\n    './xhr',\r\n    './fetch',\r\n    '../../inodes/dir-inode',\r\n    '../../inodes/file-index',\r\n    '../../inodes/file-inode',\r\n\r\n], function (async,paths,files,registry,NoSyncFile, BaseProvider, ErrorCodes, FileError,ActionType, Stats,FileType,  utils,xhr, fetch, DirInode,FileIndex,FileInode) {\r\n\r\n\r\n    'use strict';\r\n\r\n    const { copyingSlice }  = utils;\r\n\r\n    const { xhrIsAvailable, asyncDownloadFile, syncDownloadFile, getFileSizeAsync, getFileSizeSync }  = xhr;\r\n    const { fetchIsAvailable, fetchFileAsync, fetchFileSizeAsync }  = fetch;\r\n\r\n    const isFileInode = FileInode.isFileInode,\r\n          isDirInode = DirInode.isDirInode;\r\n    /**\r\n     * Try to convert the given buffer into a string, and pass it to the callback.\r\n     * Optimization that removes the needed try/catch into a helper function, as\r\n     * this is an uncommon case.\r\n     * @hidden\r\n     */\r\n    function tryToString(buff, encoding, cb) {\r\n        try {\r\n            cb(null, buff.toString(encoding));\r\n        }\r\n        catch (e) {\r\n            cb(e);\r\n        }\r\n    }\r\n    function syncNotAvailableError() {\r\n        throw new FileError(ErrorCodes.ENOTSUP, `Synchronous HTTP download methods are not available in this environment.`);\r\n    }\r\n    /**\r\n     * A simple filesystem backed by HTTP downloads. You must create a directory listing using the\r\n     * `make_http_index` tool provided by BrowserFS.\r\n     *\r\n     * If you install BrowserFS globally with `npm i -g browserfs`, you can generate a listing by\r\n     * running `make_http_index` in your terminal in the directory you would like to index:\r\n     *\r\n     * ```\r\n     * make_http_index > index.json\r\n     * ```\r\n     *\r\n     * Listings objects look like the following:\r\n     *\r\n     * ```json\r\n     * {\r\n     *   \"home\": {\r\n     *     \"jvilk\": {\r\n     *       \"someFile.txt\": null,\r\n     *       \"someDir\": {\r\n     *         // Empty directory\r\n     *       }\r\n     *     }\r\n     *   }\r\n     * }\r\n     * ```\r\n     *\r\n     * *This example has the folder `/home/jvilk` with subfile `someFile.txt` and subfolder `someDir`.*\r\n     */\r\n    class HttpProvider extends BaseProvider {\r\n        constructor(index, prefixUrl = '', preferXHR = false) {\r\n            super();\r\n            // prefix_url must end in a directory separator.\r\n            if (prefixUrl.length > 0 && prefixUrl.charAt(prefixUrl.length - 1) !== '/') {\r\n                prefixUrl = prefixUrl + '/';\r\n            }\r\n            this.prefixUrl = prefixUrl;\r\n            this._index = FileIndex.fromListing(index);\r\n            if (fetchIsAvailable && (!preferXHR || !xhrIsAvailable)) {\r\n                this._requestFileAsyncInternal = fetchFileAsync;\r\n                this._requestFileSizeAsyncInternal = fetchFileSizeAsync;\r\n            }\r\n            else {\r\n                this._requestFileAsyncInternal = asyncDownloadFile;\r\n                this._requestFileSizeAsyncInternal = getFileSizeAsync;\r\n            }\r\n            if (xhrIsAvailable) {\r\n                this._requestFileSyncInternal = syncDownloadFile;\r\n                this._requestFileSizeSyncInternal = getFileSizeSync;\r\n            }\r\n            else {\r\n                this._requestFileSyncInternal = syncNotAvailableError;\r\n                this._requestFileSizeSyncInternal = syncNotAvailableError;\r\n            }\r\n        }\r\n        /**\r\n         * Construct an HttpProvider file system backend with the given options.\r\n         */\r\n        static Create(opts, cb) {\r\n            if (opts.index === undefined) {\r\n                opts.index = `index.json`;\r\n            }\r\n            if (typeof (opts.index) === \"string\") {\r\n                asyncDownloadFile(opts.index, \"json\", (e, data) => {\r\n                    if (e) {\r\n                        cb(e);\r\n                    }\r\n                    else {\r\n                        cb(null, new HttpProvider(data, opts.baseUrl));\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                cb(null, new HttpProvider(opts.index, opts.baseUrl));\r\n            }\r\n        }\r\n        static isAvailable() {\r\n            return xhrIsAvailable || fetchIsAvailable;\r\n        }\r\n        empty() {\r\n            this._index.fileIterator(function (file) {\r\n                file.fileData = null;\r\n            });\r\n        }\r\n        getName() {\r\n            return HttpProvider.Name;\r\n        }\r\n        diskSpace(path, cb) {\r\n            // Read-only file system. We could calculate the total space, but that's not\r\n            // important right now.\r\n            cb(0, 0);\r\n        }\r\n        isReadOnly() {\r\n            return true;\r\n        }\r\n        supportsLinks() {\r\n            return false;\r\n        }\r\n        supportsProps() {\r\n            return false;\r\n        }\r\n        supportsSynch() {\r\n            // Synchronous operations are only available via the XHR interface for now.\r\n            return xhrIsAvailable;\r\n        }\r\n        /**\r\n         * Special HTTPFS function: Preload the given file into the index.\r\n         * @param [String] path\r\n         * @param [BrowserFS.Buffer] buffer\r\n         */\r\n        preloadFile(path, buffer) {\r\n            const inode = this._index.getInode(path);\r\n            if (isFileInode(inode)) {\r\n                if (inode === null) {\r\n                    throw FileError.ENOENT(path);\r\n                }\r\n                const stats = inode.getData();\r\n                stats.size = buffer.length;\r\n                stats.fileData = buffer;\r\n            }\r\n            else {\r\n                throw FileError.EISDIR(path);\r\n            }\r\n        }\r\n        stat(path, isLstat, cb) {\r\n            const inode = this._index.getInode(path);\r\n            if (inode === null) {\r\n                return cb(FileError.ENOENT(path));\r\n            }\r\n            let stats;\r\n            if (isFileInode(inode)) {\r\n                stats = inode.getData();\r\n                // At this point, a non-opened file will still have default stats from the listing.\r\n                if (stats.size < 0) {\r\n                    this._requestFileSizeAsync(path, function (e, size) {\r\n                        if (e) {\r\n                            return cb(e);\r\n                        }\r\n                        stats.size = size;\r\n                        cb(null, Stats.clone(stats));\r\n                    });\r\n                }\r\n                else {\r\n                    cb(null, Stats.clone(stats));\r\n                }\r\n            }\r\n            else if (isDirInode(inode)) {\r\n                stats = inode.getStats();\r\n                cb(null, stats);\r\n            }\r\n            else {\r\n                cb(FileError.FileError(ErrorCodes.EINVAL, path));\r\n            }\r\n        }\r\n        statSync(path, isLstat) {\r\n            const inode = this._index.getInode(path);\r\n            if (inode === null) {\r\n                throw FileError.ENOENT(path);\r\n            }\r\n            let stats;\r\n            if (isFileInode(inode)) {\r\n                stats = inode.getData();\r\n                // At this point, a non-opened file will still have default stats from the listing.\r\n                if (stats.size < 0) {\r\n                    stats.size = this._requestFileSizeSync(path);\r\n                }\r\n            }\r\n            else if (isDirInode(inode)) {\r\n                stats = inode.getStats();\r\n            }\r\n            else {\r\n                throw FileError.FileError(ErrorCodes.EINVAL, path);\r\n            }\r\n            return stats;\r\n        }\r\n        open(path, flags, mode, cb) {\r\n            // INVARIANT: You can't write to files on this file system.\r\n            if (flags.isWriteable()) {\r\n                return cb(new FileError(ErrorCodes.EPERM, path));\r\n            }\r\n            const self = this;\r\n            // Check if the path exists, and is a file.\r\n            const inode = this._index.getInode(path);\r\n            if (inode === null) {\r\n                return cb(FileError.ENOENT(path));\r\n            }\r\n            if (isFileInode(inode)) {\r\n                const stats = inode.getData();\r\n                switch (flags.pathExistsAction()) {\r\n                    case ActionType.THROW_EXCEPTION:\r\n                    case ActionType.TRUNCATE_FILE:\r\n                        return cb(FileError.EEXIST(path));\r\n                    case ActionType.NOP:\r\n                        // Use existing file contents.\r\n                        // XXX: Uh, this maintains the previously-used flag.\r\n                        if (stats.fileData) {\r\n                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), stats.fileData));\r\n                        }\r\n                        // @todo be lazier about actually requesting the file\r\n                        this._requestFileAsync(path, 'buffer', function (err, buffer) {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            // we don't initially have file sizes\r\n                            stats.size = buffer.length;\r\n                            stats.fileData = buffer;\r\n                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), buffer));\r\n                        });\r\n                        break;\r\n                    default:\r\n                        return cb(new FileError(ErrorCodes.EINVAL, 'Invalid FileMode object.'));\r\n                }\r\n            }\r\n            else {\r\n                return cb(FileError.EISDIR(path));\r\n            }\r\n        }\r\n        openSync(path, flags, mode) {\r\n            // INVARIANT: You can't write to files on this file system.\r\n            if (flags.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, path);\r\n            }\r\n            // Check if the path exists, and is a file.\r\n            const inode = this._index.getInode(path);\r\n            if (inode === null) {\r\n                throw FileError.ENOENT(path);\r\n            }\r\n            if (isFileInode(inode)) {\r\n                const stats = inode.getData();\r\n                switch (flags.pathExistsAction()) {\r\n                    case ActionType.THROW_EXCEPTION:\r\n                    case ActionType.TRUNCATE_FILE:\r\n                        throw FileError.EEXIST(path);\r\n                    case ActionType.NOP:\r\n                        // Use existing file contents.\r\n                        // XXX: Uh, this maintains the previously-used flag.\r\n                        if (stats.fileData) {\r\n                            return new NoSyncFile(this, path, flags, Stats.clone(stats), stats.fileData);\r\n                        }\r\n                        // @todo be lazier about actually requesting the file\r\n                        const buffer = this._requestFileSync(path, 'buffer');\r\n                        // we don't initially have file sizes\r\n                        stats.size = buffer.length;\r\n                        stats.fileData = buffer;\r\n                        return new NoSyncFile(this, path, flags, Stats.clone(stats), buffer);\r\n                    default:\r\n                        throw new FileError(ErrorCodes.EINVAL, 'Invalid FileMode object.');\r\n                }\r\n            }\r\n            else {\r\n                throw FileError.EISDIR(path);\r\n            }\r\n        }\r\n        readdir(path, cb) {\r\n            try {\r\n                cb(null, this.readdirSync(path));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        readdirSync(path) {\r\n            // Check if it exists.\r\n            const inode = this._index.getInode(path);\r\n            if (inode === null) {\r\n                throw FileError.ENOENT(path);\r\n            }\r\n            else if (isDirInode(inode)) {\r\n                return inode.getListing();\r\n            }\r\n            else {\r\n                throw FileError.ENOTDIR(path);\r\n            }\r\n        }\r\n        /**\r\n         * We have the entire file as a buffer; optimize readFile.\r\n         */\r\n        readFile(fname, encoding, flag, cb) {\r\n            // Wrap cb in file closing code.\r\n            const oldCb = cb;\r\n            // Get file.\r\n            this.open(fname, flag, 0x1a4, function (err, fd) {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                cb = function (err, arg) {\r\n                    fd.close(function (err2) {\r\n                        if (!err) {\r\n                            err = err2;\r\n                        }\r\n                        return oldCb(err, arg);\r\n                    });\r\n                };\r\n                const fdCast = fd;\r\n                const fdBuff = fdCast.getBuffer();\r\n                if (encoding === null) {\r\n                    cb(err, copyingSlice(fdBuff));\r\n                }\r\n                else {\r\n                    tryToString(fdBuff, encoding, cb);\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Specially-optimized readfile.\r\n         */\r\n        readFileSync(fname, encoding, flag) {\r\n            // Get file.\r\n            const fd = this.openSync(fname, flag, 0x1a4);\r\n            try {\r\n                const fdCast = fd;\r\n                const fdBuff = fdCast.getBuffer();\r\n                if (encoding === null) {\r\n                    return copyingSlice(fdBuff);\r\n                }\r\n                return fdBuff.toString(encoding);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        _getHTTPPath(filePath) {\r\n            if (filePath.charAt(0) === '/') {\r\n                filePath = filePath.slice(1);\r\n            }\r\n            return this.prefixUrl + filePath;\r\n        }\r\n        _requestFileAsync(p, type, cb) {\r\n            this._requestFileAsyncInternal(this._getHTTPPath(p), type, cb);\r\n        }\r\n        _requestFileSync(p, type) {\r\n            return this._requestFileSyncInternal(this._getHTTPPath(p), type);\r\n        }\r\n        /**\r\n         * Only requests the HEAD content, for the file size.\r\n         */\r\n        _requestFileSizeAsync(path, cb) {\r\n            this._requestFileSizeAsyncInternal(this._getHTTPPath(path), cb);\r\n        }\r\n        _requestFileSizeSync(path) {\r\n            return this._requestFileSizeSyncInternal(this._getHTTPPath(path));\r\n        }\r\n    }\r\n    HttpProvider.Name = \"http\";\r\n    HttpProvider.Options = {\r\n        index: {\r\n            type: [\"string\", \"object\"],\r\n            optional: true,\r\n            description: \"URL to a file index as a JSON file or the file index object itself, generated with the make_http_index script. Defaults to `index.json`.\"\r\n        },\r\n        baseUrl: {\r\n            type: \"string\",\r\n            optional: true,\r\n            description: \"Used as the URL prefix for fetched files. Default: Fetch files relative to the index.\"\r\n        },\r\n        preferXHR: {\r\n            type: \"boolean\",\r\n            optional: true,\r\n            description: \"Whether to prefer XmlHttpRequest or fetch for async operations if both are available. Default: false\"\r\n        }\r\n    };\r\n\r\n    registry.add(\"http\",HttpProvider);\r\n\r\n    return files.providers.HttpProvider = HttpProvider;\r\n});\ndefine('skylark-io-files/inodes/inode',[\r\n    \"skylark-langx-binary/buffer\",\r\n    '../stats',\r\n    '../file-type'\r\n], function (Buffer,Stats,FileType) {\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * Generic inode definition that can easily be serialized.\r\n     */\r\n    class Inode {\r\n        constructor(id, size, mode, atime, mtime, ctime) {\r\n            this.id = id;\r\n            this.size = size;\r\n            this.mode = mode;\r\n            this.atime = atime;\r\n            this.mtime = mtime;\r\n            this.ctime = ctime;\r\n        }\r\n\r\n        /**\r\n         * Converts the buffer into an Inode.\r\n         */\r\n        static fromBuffer(buffer) {\r\n            if (buffer === undefined) {\r\n                throw new Error(\"NO\");\r\n            }\r\n            return new Inode(buffer.toString('ascii', 30), buffer.readUInt32LE(0), buffer.readUInt16LE(4), buffer.readDoubleLE(6), buffer.readDoubleLE(14), buffer.readDoubleLE(22));\r\n        }\r\n\r\n        /**\r\n         * Handy function that converts the Inode to a Node Stats object.\r\n         */\r\n        toStats() {\r\n            return new Stats((this.mode & 0xF000) === FileType.DIRECTORY ? FileType.DIRECTORY : FileType.FILE, this.size, this.mode, this.atime, this.mtime, this.ctime);\r\n        }\r\n\r\n        /**\r\n         * Get the size of this Inode, in bytes.\r\n         */\r\n        getSize() {\r\n            // ASSUMPTION: ID is ASCII (1 byte per char).\r\n            return 30 + this.id.length;\r\n        }\r\n\r\n        /**\r\n         * Writes the inode into the start of the buffer.\r\n         */\r\n        toBuffer(buff = Buffer.alloc(this.getSize())) {\r\n            buff.writeUInt32LE(this.size, 0);\r\n            buff.writeUInt16LE(this.mode, 4);\r\n            buff.writeDoubleLE(this.atime, 6);\r\n            buff.writeDoubleLE(this.mtime, 14);\r\n            buff.writeDoubleLE(this.ctime, 22);\r\n            buff.write(this.id, 30, this.id.length, 'ascii');\r\n            return buff;\r\n        }\r\n        \r\n        /**\r\n         * Updates the Inode using information from the stats object. Used by file\r\n         * systems at sync time, e.g.:\r\n         * - Program opens file and gets a File object.\r\n         * - Program mutates file. File object is responsible for maintaining\r\n         *   metadata changes locally -- typically in a Stats object.\r\n         * - Program closes file. File object's metadata changes are synced with the\r\n         *   file system.\r\n         * @return True if any changes have occurred.\r\n         */\r\n        update(stats) {\r\n            let hasChanged = false;\r\n            if (this.size !== stats.size) {\r\n                this.size = stats.size;\r\n                hasChanged = true;\r\n            }\r\n            if (this.mode !== stats.mode) {\r\n                this.mode = stats.mode;\r\n                hasChanged = true;\r\n            }\r\n            const atimeMs = stats.atime.getTime();\r\n            if (this.atime !== atimeMs) {\r\n                this.atime = atimeMs;\r\n                hasChanged = true;\r\n            }\r\n            const mtimeMs = stats.mtime.getTime();\r\n            if (this.mtime !== mtimeMs) {\r\n                this.mtime = mtimeMs;\r\n                hasChanged = true;\r\n            }\r\n            const ctimeMs = stats.ctime.getTime();\r\n            if (this.ctime !== ctimeMs) {\r\n                this.ctime = ctimeMs;\r\n                hasChanged = true;\r\n            }\r\n            return hasChanged;\r\n        }\r\n        // XXX: Copied from Stats. Should reconcile these two into something more\r\n        //      compact.\r\n        /**\r\n         * @return [Boolean] True if this item is a file.\r\n         */\r\n        isFile() {\r\n            return (this.mode & 0xF000) === FileType.FILE;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a directory.\r\n         */\r\n        isDirectory() {\r\n            return (this.mode & 0xF000) === FileType.DIRECTORY;\r\n        }\r\n    }\r\n\r\n\r\n    return Inode;\r\n});\ndefine('skylark-io-files/providers/async-key-value-file',[\r\n    \"../files\",\r\n    '../preload-file'\r\n], function (files, PreloadFile) {\r\n    'use strict';\r\n\r\n    class AsyncKeyValueFile extends PreloadFile {\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super(_fs, _path, _flag, _stat, contents);\r\n        }\r\n        sync(cb) {\r\n            if (this.isDirty()) {\r\n                this._fs._sync(this.getPath(), this.getBuffer(), this.getStats(), (e) => {\r\n                    if (!e) {\r\n                        this.resetDirty();\r\n                    }\r\n                    cb(e);\r\n                });\r\n            }\r\n            else {\r\n                cb();\r\n            }\r\n        }\r\n        close(cb) {\r\n            this.sync(cb);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    return files.providers.AsyncKeyValueFile = AsyncKeyValueFile;\r\n    \r\n});\ndefine('skylark-io-files/providers/async-key-value-provider',[\r\n    \"skylark-langx-strings/generate-uuid\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"skylark-data-collections/lru-cache\",\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error',\r\n    \"../file-type\",\r\n    '../utils',\r\n    \"../inodes/inode\",\r\n    \"./base-provider\",\r\n    \"./async-key-value-file\"\r\n ], function (GenerateRandomID,Buffer,paths,LRUCache, files, ErrorCodes, FileError, FileType, utils, Inode,BaseProvider,AsyncKeyValueFile) {\r\n    'use strict';\r\n\r\n    const { emptyBuffer } = utils;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    const ROOT_NODE_ID = \"/\";\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    let emptyDirNode = null;\r\n\r\n    /**\r\n     * Returns an empty directory node.\r\n     * @hidden\r\n     */\r\n    function getEmptyDirNode() {\r\n        if (emptyDirNode) {\r\n            return emptyDirNode;\r\n        }\r\n        return emptyDirNode = Buffer.from(\"{}\");\r\n    }\r\n\r\n    /**\r\n     * Helper function. Checks if 'e' is defined. If so, it triggers the callback\r\n     * with 'e' and returns false. Otherwise, returns true.\r\n     * @hidden\r\n     */\r\n    function noError(e, cb) {\r\n        if (e) {\r\n            cb(e);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Helper function. Checks if 'e' is defined. If so, it aborts the transaction,\r\n     * triggers the callback with 'e', and returns false. Otherwise, returns true.\r\n     * @hidden\r\n     */\r\n    function noErrorTx(e, tx, cb) {\r\n        if (e) {\r\n            tx.abort(() => {\r\n                cb(e);\r\n            });\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * An \"Asynchronous key-value file system\". Stores data to/retrieves data from\r\n     * an underlying asynchronous key-value store.\r\n     */\r\n    class AsyncKeyValueProvider extends BaseProvider {\r\n        constructor(cacheSize) {\r\n            super();\r\n            this._cache = null;\r\n            if (cacheSize > 0) {\r\n                this._cache = new LRUCache(cacheSize);\r\n            }\r\n        }\r\n\r\n        static isAvailable() { return true; }\r\n        /**\r\n         * Initializes the file system. Typically called by subclasses' async\r\n         * constructors.\r\n         */\r\n        init(store, cb) {\r\n            this.store = store;\r\n            // INVARIANT: Ensure that the root exists.\r\n            this.makeRootDirectory(cb);\r\n        }\r\n\r\n        getName() { return this.store.name(); }\r\n        \r\n        isReadOnly() { return false; }\r\n        \r\n        supportsSymlinks() { return false; }\r\n        \r\n        supportsProps() { return false; }\r\n        \r\n        supportsSynch() { return false; }\r\n        \r\n        /**\r\n         * Delete all contents stored in the file system.\r\n         */\r\n        empty(cb) {\r\n            if (this._cache) {\r\n                this._cache.removeAll();\r\n            }\r\n            this.store.clear((e) => {\r\n                if (noError(e, cb)) {\r\n                    // INVARIANT: Root always exists.\r\n                    this.makeRootDirectory(cb);\r\n                }\r\n            });\r\n        }\r\n        \r\n        rename(oldPath, newPath, cb) {\r\n            // TODO: Make rename compatible with the cache.\r\n            if (this._cache) {\r\n                // Clear and disable cache during renaming process.\r\n                const c = this._cache;\r\n                this._cache = null;\r\n                c.removeAll();\r\n                const oldCb = cb;\r\n                cb = (e) => {\r\n                    // Restore empty cache.\r\n                    this._cache = c;\r\n                    oldCb(e);\r\n                };\r\n            }\r\n            const tx = this.store.beginTransaction('readwrite');\r\n            const oldParent = paths.dirname(oldPath), oldName = paths.basename(oldPath);\r\n            const newParent = paths.dirname(newPath), newName = paths.basename(newPath);\r\n            const inodes = {};\r\n            const lists = {};\r\n            let errorOccurred = false;\r\n            // Invariant: Can't move a folder inside itself.\r\n            // This funny little hack ensures that the check passes only if oldPath\r\n            // is a subpath of newParent. We append '/' to avoid matching folders that\r\n            // are a substring of the bottom-most folder in the path.\r\n            if ((newParent + '/').indexOf(oldPath + '/') === 0) {\r\n                return cb(new FileError(ErrorCodes.EBUSY, oldParent));\r\n            }\r\n            /**\r\n             * Responsible for Phase 2 of the rename operation: Modifying and\r\n             * committing the directory listings. Called once we have successfully\r\n             * retrieved both the old and new parent's inodes and listings.\r\n             */\r\n            const theOleSwitcharoo = () => {\r\n                // Sanity check: Ensure both paths are present, and no error has occurred.\r\n                if (errorOccurred || !lists.hasOwnProperty(oldParent) || !lists.hasOwnProperty(newParent)) {\r\n                    return;\r\n                }\r\n                const oldParentList = lists[oldParent], oldParentINode = inodes[oldParent], newParentList = lists[newParent], newParentINode = inodes[newParent];\r\n                // Delete file from old parent.\r\n                if (!oldParentList[oldName]) {\r\n                    cb(FileError.ENOENT(oldPath));\r\n                }\r\n                else {\r\n                    const fileId = oldParentList[oldName];\r\n                    delete oldParentList[oldName];\r\n                    // Finishes off the renaming process by adding the file to the new\r\n                    // parent.\r\n                    const completeRename = () => {\r\n                        newParentList[newName] = fileId;\r\n                        // Commit old parent's list.\r\n                        tx.put(oldParentINode.id, Buffer.from(JSON.stringify(oldParentList)), true, (e) => {\r\n                            if (noErrorTx(e, tx, cb)) {\r\n                                if (oldParent === newParent) {\r\n                                    // DONE!\r\n                                    tx.commit(cb);\r\n                                }\r\n                                else {\r\n                                    // Commit new parent's list.\r\n                                    tx.put(newParentINode.id, Buffer.from(JSON.stringify(newParentList)), true, (e) => {\r\n                                        if (noErrorTx(e, tx, cb)) {\r\n                                            tx.commit(cb);\r\n                                        }\r\n                                    });\r\n                                }\r\n                            }\r\n                        });\r\n                    };\r\n                    if (newParentList[newName]) {\r\n                        // 'newPath' already exists. Check if it's a file or a directory, and\r\n                        // act accordingly.\r\n                        this.getINode(tx, newPath, newParentList[newName], (e, inode) => {\r\n                            if (noErrorTx(e, tx, cb)) {\r\n                                if (inode.isFile()) {\r\n                                    // Delete the file and continue.\r\n                                    tx.del(inode.id, (e) => {\r\n                                        if (noErrorTx(e, tx, cb)) {\r\n                                            tx.del(newParentList[newName], (e) => {\r\n                                                if (noErrorTx(e, tx, cb)) {\r\n                                                    completeRename();\r\n                                                }\r\n                                            });\r\n                                        }\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    // Can't overwrite a directory using rename.\r\n                                    tx.abort((e) => {\r\n                                        cb(FileError.EPERM(newPath));\r\n                                    });\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                    else {\r\n                        completeRename();\r\n                    }\r\n                }\r\n            };\r\n            /**\r\n             * Grabs a path's inode and directory listing, and shoves it into the\r\n             * inodes and lists hashes.\r\n             */\r\n            const processInodeAndListings = (p) => {\r\n                this.findINodeAndDirListing(tx, p, (e, node, dirList) => {\r\n                    if (e) {\r\n                        if (!errorOccurred) {\r\n                            errorOccurred = true;\r\n                            tx.abort(() => {\r\n                                cb(e);\r\n                            });\r\n                        }\r\n                        // If error has occurred already, just stop here.\r\n                    }\r\n                    else {\r\n                        inodes[p] = node;\r\n                        lists[p] = dirList;\r\n                        theOleSwitcharoo();\r\n                    }\r\n                });\r\n            };\r\n            processInodeAndListings(oldParent);\r\n            if (oldParent !== newParent) {\r\n                processInodeAndListings(newParent);\r\n            }\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            const tx = this.store.beginTransaction('readonly');\r\n            this.findINode(tx, p, (e, inode) => {\r\n                if (noError(e, cb)) {\r\n                    cb(null, inode.toStats());\r\n                }\r\n            });\r\n        }\r\n        createFile(p, flag, mode, cb) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = emptyBuffer();\r\n            this.commitNewFile(tx, p, FileType.FILE, mode, data, (e, newFile) => {\r\n                if (noError(e, cb)) {\r\n                    cb(null, new AsyncKeyValueFile(this, p, flag, newFile.toStats(), data));\r\n                }\r\n            });\r\n        }\r\n\r\n        openFile(p, flag, cb) {\r\n            const tx = this.store.beginTransaction('readonly');\r\n            // Step 1: Grab the file's inode.\r\n            this.findINode(tx, p, (e, inode) => {\r\n                if (noError(e, cb)) {\r\n                    // Step 2: Grab the file's data.\r\n                    tx.get(inode.id, (e, data) => {\r\n                        if (noError(e, cb)) {\r\n                            if (data === undefined) {\r\n                                cb(FileError.ENOENT(p));\r\n                            }\r\n                            else {\r\n                                cb(null, new AsyncKeyValueFile(this, p, flag, inode.toStats(), data));\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        unlink(p, cb) {\r\n            this.removeEntry(p, false, cb);\r\n        }\r\n        \r\n        rmdir(p, cb) {\r\n            // Check first if directory is empty.\r\n            this.readdir(p, (err, files) => {\r\n                if (err) {\r\n                    cb(err);\r\n                }\r\n                else if (files.length > 0) {\r\n                    cb(FileError.ENOTEMPTY(p));\r\n                }\r\n                else {\r\n                    this.removeEntry(p, true, cb);\r\n                }\r\n            });\r\n        }\r\n        \r\n        mkdir(p, mode, cb) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');\r\n            this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data, cb);\r\n        }\r\n        \r\n        readdir(p, cb) {\r\n            const tx = this.store.beginTransaction('readonly');\r\n            this.findINode(tx, p, (e, inode) => {\r\n                if (noError(e, cb)) {\r\n                    this.getDirListing(tx, p, inode, (e, dirListing) => {\r\n                        if (noError(e, cb)) {\r\n                            cb(null, Object.keys(dirListing));\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        \r\n        _sync(p, data, stats, cb) {\r\n            // @todo Ensure mtime updates properly, and use that to determine if a data\r\n            //       update is required.\r\n            const tx = this.store.beginTransaction('readwrite');\r\n            // Step 1: Get the file node's ID.\r\n            this._findINode(tx, paths.dirname(p), paths.basename(p), (e, fileInodeId) => {\r\n                if (noErrorTx(e, tx, cb)) {\r\n                    // Step 2: Get the file inode.\r\n                    this.getINode(tx, p, fileInodeId, (e, fileInode) => {\r\n                        if (noErrorTx(e, tx, cb)) {\r\n                            const inodeChanged = fileInode.update(stats);\r\n                            // Step 3: Sync the data.\r\n                            tx.put(fileInode.id, data, true, (e) => {\r\n                                if (noErrorTx(e, tx, cb)) {\r\n                                    // Step 4: Sync the metadata (if it changed)!\r\n                                    if (inodeChanged) {\r\n                                        tx.put(fileInodeId, fileInode.toBuffer(), true, (e) => {\r\n                                            if (noErrorTx(e, tx, cb)) {\r\n                                                tx.commit(cb);\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                    else {\r\n                                        // No need to sync metadata; return.\r\n                                        tx.commit(cb);\r\n                                    }\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Checks if the root directory exists. Creates it if it doesn't.\r\n         */\r\n        makeRootDirectory(cb) {\r\n            const tx = this.store.beginTransaction('readwrite');\r\n            tx.get(ROOT_NODE_ID, (e, data) => {\r\n                if (e || data === undefined) {\r\n                    // Create new inode.\r\n                    const currTime = (new Date()).getTime(), \r\n                    // Mode 0666\r\n                    dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);\r\n                    // If the root doesn't exist, the first random ID shouldn't exist,\r\n                    // either.\r\n                    tx.put(dirInode.id, getEmptyDirNode(), false, (e) => {\r\n                        if (noErrorTx(e, tx, cb)) {\r\n                            tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false, (e) => {\r\n                                if (e) {\r\n                                    tx.abort(() => { cb(e); });\r\n                                }\r\n                                else {\r\n                                    tx.commit(cb);\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    // We're good.\r\n                    tx.commit(cb);\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Helper function for findINode.\r\n         * @param parent The parent directory of the file we are attempting to find.\r\n         * @param filename The filename of the inode we are attempting to find, minus\r\n         *   the parent.\r\n         * @param cb Passed an error or the ID of the file's inode in the file system.\r\n         */\r\n        _findINode(tx, parent, filename, cb) {\r\n            if (this._cache) {\r\n                const id = this._cache.get(paths.join(parent, filename));\r\n                if (id) {\r\n                    return cb(null, id);\r\n                }\r\n            }\r\n            const handleDirectoryListings = (e, inode, dirList) => {\r\n                if (e) {\r\n                    cb(e);\r\n                }\r\n                else if (dirList[filename]) {\r\n                    const id = dirList[filename];\r\n                    if (this._cache) {\r\n                        this._cache.set(paths.join(parent, filename), id);\r\n                    }\r\n                    cb(null, id);\r\n                }\r\n                else {\r\n                    cb(FileError.ENOENT(paths.resolve(parent, filename)));\r\n                }\r\n            };\r\n            if (parent === '/') {\r\n                if (filename === '') {\r\n                    // BASE CASE #1: Return the root's ID.\r\n                    if (this._cache) {\r\n                        this._cache.set(paths.join(parent, filename), ROOT_NODE_ID);\r\n                    }\r\n                    cb(null, ROOT_NODE_ID);\r\n                }\r\n                else {\r\n                    // BASE CASE #2: Find the item in the root node.\r\n                    this.getINode(tx, parent, ROOT_NODE_ID, (e, inode) => {\r\n                        if (noError(e, cb)) {\r\n                            this.getDirListing(tx, parent, inode, (e, dirList) => {\r\n                                // handle_directory_listings will handle e for us.\r\n                                handleDirectoryListings(e, inode, dirList);\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                // Get the parent directory's INode, and find the file in its directory\r\n                // listing.\r\n                this.findINodeAndDirListing(tx, parent, handleDirectoryListings);\r\n            }\r\n        }\r\n        /**\r\n         * Finds the Inode of the given path.\r\n         * @param p The path to look up.\r\n         * @param cb Passed an error or the Inode of the path p.\r\n         * @todo memoize/cache\r\n         */\r\n        findINode(tx, p, cb) {\r\n            this._findINode(tx, paths.dirname(p), paths.basename(p), (e, id) => {\r\n                if (noError(e, cb)) {\r\n                    this.getINode(tx, p, id, cb);\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Given the ID of a node, retrieves the corresponding Inode.\r\n         * @param tx The transaction to use.\r\n         * @param p The corresponding path to the file (used for error messages).\r\n         * @param id The ID to look up.\r\n         * @param cb Passed an error or the inode under the given id.\r\n         */\r\n        getINode(tx, p, id, cb) {\r\n            tx.get(id, (e, data) => {\r\n                if (noError(e, cb)) {\r\n                    if (data === undefined) {\r\n                        cb(FileError.ENOENT(p));\r\n                    }\r\n                    else {\r\n                        cb(null, Inode.fromBuffer(data));\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Given the Inode of a directory, retrieves the corresponding directory\r\n         * listing.\r\n         */\r\n        getDirListing(tx, p, inode, cb) {\r\n            if (!inode.isDirectory()) {\r\n                cb(FileError.ENOTDIR(p));\r\n            }\r\n            else {\r\n                tx.get(inode.id, (e, data) => {\r\n                    if (noError(e, cb)) {\r\n                        try {\r\n                            cb(null, JSON.parse(data.toString()));\r\n                        }\r\n                        catch (e) {\r\n                            // Occurs when data is undefined, or corresponds to something other\r\n                            // than a directory listing. The latter should never occur unless\r\n                            // the file system is corrupted.\r\n                            cb(FileError.ENOENT(p));\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        /**\r\n         * Given a path to a directory, retrieves the corresponding INode and\r\n         * directory listing.\r\n         */\r\n        findINodeAndDirListing(tx, p, cb) {\r\n            this.findINode(tx, p, (e, inode) => {\r\n                if (noError(e, cb)) {\r\n                    this.getDirListing(tx, p, inode, (e, listing) => {\r\n                        if (noError(e, cb)) {\r\n                            cb(null, inode, listing);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Adds a new node under a random ID. Retries 5 times before giving up in\r\n         * the exceedingly unlikely chance that we try to reuse a random GUID.\r\n         * @param cb Passed an error or the GUID that the data was stored under.\r\n         */\r\n        addNewNode(tx, data, cb) {\r\n            let retries = 0, currId;\r\n            const reroll = () => {\r\n                if (++retries === 5) {\r\n                    // Max retries hit. Return with an error.\r\n                    cb(new FileError(ErrorCodes.EIO, 'Unable to commit data to key-value store.'));\r\n                }\r\n                else {\r\n                    // Try again.\r\n                    currId = GenerateRandomID();\r\n                    tx.put(currId, data, false, (e, committed) => {\r\n                        if (e || !committed) {\r\n                            reroll();\r\n                        }\r\n                        else {\r\n                            // Successfully stored under 'currId'.\r\n                            cb(null, currId);\r\n                        }\r\n                    });\r\n                }\r\n            };\r\n            reroll();\r\n        }\r\n        /**\r\n         * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\r\n         * the given mode.\r\n         * Note: This will commit the transaction.\r\n         * @param p The path to the new file.\r\n         * @param type The type of the new file.\r\n         * @param mode The mode to create the new file with.\r\n         * @param data The data to store at the file's data node.\r\n         * @param cb Passed an error or the Inode for the new file.\r\n         */\r\n        commitNewFile(tx, p, type, mode, data, cb) {\r\n            const parentDir = paths.dirname(p), fname = paths.basename(p), currTime = (new Date()).getTime();\r\n            // Invariant: The root always exists.\r\n            // If we don't check this prior to taking steps below, we will create a\r\n            // file with name '' in root should p == '/'.\r\n            if (p === '/') {\r\n                return cb(FileError.EEXIST(p));\r\n            }\r\n            // Let's build a pyramid of code!\r\n            // Step 1: Get the parent directory's inode and directory listing\r\n            this.findINodeAndDirListing(tx, parentDir, (e, parentNode, dirListing) => {\r\n                if (noErrorTx(e, tx, cb)) {\r\n                    if (dirListing[fname]) {\r\n                        // File already exists.\r\n                        tx.abort(() => {\r\n                            cb(FileError.EEXIST(p));\r\n                        });\r\n                    }\r\n                    else {\r\n                        // Step 2: Commit data to store.\r\n                        this.addNewNode(tx, data, (e, dataId) => {\r\n                            if (noErrorTx(e, tx, cb)) {\r\n                                // Step 3: Commit the file's inode to the store.\r\n                                const fileInode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\r\n                                this.addNewNode(tx, fileInode.toBuffer(), (e, fileInodeId) => {\r\n                                    if (noErrorTx(e, tx, cb)) {\r\n                                        // Step 4: Update parent directory's listing.\r\n                                        dirListing[fname] = fileInodeId;\r\n                                        tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true, (e) => {\r\n                                            if (noErrorTx(e, tx, cb)) {\r\n                                                // Step 5: Commit and return the new inode.\r\n                                                tx.commit((e) => {\r\n                                                    if (noErrorTx(e, tx, cb)) {\r\n                                                        cb(null, fileInode);\r\n                                                    }\r\n                                                });\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Remove all traces of the given path from the file system.\r\n         * @param p The path to remove from the file system.\r\n         * @param isDir Does the path belong to a directory, or a file?\r\n         * @todo Update mtime.\r\n         */\r\n        removeEntry(p, isDir, cb) {\r\n            // Eagerly delete from cache (harmless even if removal fails)\r\n            if (this._cache) {\r\n                this._cache.remove(p);\r\n            }\r\n            const tx = this.store.beginTransaction('readwrite'), parent = paths.dirname(p), fileName = paths.basename(p);\r\n            // Step 1: Get parent directory's node and directory listing.\r\n            this.findINodeAndDirListing(tx, parent, (e, parentNode, parentListing) => {\r\n                if (noErrorTx(e, tx, cb)) {\r\n                    if (!parentListing[fileName]) {\r\n                        tx.abort(() => {\r\n                            cb(FileError.ENOENT(p));\r\n                        });\r\n                    }\r\n                    else {\r\n                        // Remove from directory listing of parent.\r\n                        const fileNodeId = parentListing[fileName];\r\n                        delete parentListing[fileName];\r\n                        // Step 2: Get file inode.\r\n                        this.getINode(tx, p, fileNodeId, (e, fileNode) => {\r\n                            if (noErrorTx(e, tx, cb)) {\r\n                                if (!isDir && fileNode.isDirectory()) {\r\n                                    tx.abort(() => {\r\n                                        cb(FileError.EISDIR(p));\r\n                                    });\r\n                                }\r\n                                else if (isDir && !fileNode.isDirectory()) {\r\n                                    tx.abort(() => {\r\n                                        cb(FileError.ENOTDIR(p));\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    // Step 3: Delete data.\r\n                                    tx.del(fileNode.id, (e) => {\r\n                                        if (noErrorTx(e, tx, cb)) {\r\n                                            // Step 4: Delete node.\r\n                                            tx.del(fileNodeId, (e) => {\r\n                                                if (noErrorTx(e, tx, cb)) {\r\n                                                    // Step 5: Update directory listing.\r\n                                                    tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true, (e) => {\r\n                                                        if (noErrorTx(e, tx, cb)) {\r\n                                                            tx.commit(cb);\r\n                                                        }\r\n                                                    });\r\n                                                }\r\n                                            });\r\n                                        }\r\n                                    });\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    return  files.providers.AsyncKeyValueProvider = AsyncKeyValueProvider;\r\n});\ndefine('skylark-io-files/providers/indexeddb/indexed-db-ro-transaction',[\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    '../async-key-value-provider',\r\n    '../../utils'\r\n], function (FileError,ErrorCodes, AsyncKeyValueProvider,  utils) {\r\n    'use strict';\r\n\r\n\r\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer }  = utils;\r\n\r\n    /**\r\n     * Converts a DOMException or a DOMError from an IndexedDB event into a\r\n     * standardized BrowserFS API error.\r\n     * @hidden\r\n     */\r\n    function convertError(e, message = e.toString()) {\r\n        switch (e.name) {\r\n            case \"NotFoundError\":\r\n                return new FileError(ErrorCodes.ENOENT, message);\r\n            case \"QuotaExceededError\":\r\n                return new FileError(ErrorCodes.ENOSPC, message);\r\n            default:\r\n                // The rest do not seem to map cleanly to standard error codes.\r\n                return new FileError(ErrorCodes.EIO, message);\r\n        }\r\n    }\r\n    /**\r\n     * Produces a new onerror handler for IDB. Our errors are always fatal, so we\r\n     * handle them generically: Call the user-supplied callback with a translated\r\n     * version of the error, and let the error bubble up.\r\n     * @hidden\r\n     */\r\n    function onErrorHandler(cb, code = ErrorCodes.EIO, message = null) {\r\n        return function (e) {\r\n            // Prevent the error from canceling the transaction.\r\n            e.preventDefault();\r\n            cb(new FileError(code, message !== null ? message : undefined));\r\n        };\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    class IndexedDBROTransaction {\r\n        constructor(tx, store) {\r\n            this.tx = tx;\r\n            this.store = store;\r\n        }\r\n        get(key, cb) {\r\n            try {\r\n                const r = this.store.get(key);\r\n                r.onerror = onErrorHandler(cb);\r\n                r.onsuccess = (event) => {\r\n                    // IDB returns the value 'undefined' when you try to get keys that\r\n                    // don't exist. The caller expects this behavior.\r\n                    const result = event.target.result;\r\n                    if (result === undefined) {\r\n                        cb(null, result);\r\n                    }\r\n                    else {\r\n                        // IDB data is stored as an ArrayBuffer\r\n                        cb(null, arrayBuffer2Buffer(result));\r\n                    }\r\n                };\r\n            }\r\n            catch (e) {\r\n                cb(convertError(e));\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    return IndexedDBROTransaction;\r\n});\ndefine('skylark-io-files/providers/indexeddb/indexed-db-rw-transaction',[\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    '../async-key-value-provider',\r\n    '../../utils',\r\n    \"./indexed-db-ro-transaction\"\r\n], function (FileError,ErrorCodes, AsyncKeyValueProvider,  utils,IndexedDBROTransaction) {\r\n    'use strict';\r\n\r\n\r\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer }  = utils;\r\n\r\n    /**\r\n     * Get the indexedDB constructor for the current browser.\r\n     * @hidden\r\n     */\r\n    const indexedDB = window.indexedDB ||\r\n        window.mozIndexedDB ||\r\n        window.webkitIndexedDB ||\r\n        window.msIndexedDB;\r\n    /**\r\n     * Converts a DOMException or a DOMError from an IndexedDB event into a\r\n     * standardized BrowserFS API error.\r\n     * @hidden\r\n     */\r\n    function convertError(e, message = e.toString()) {\r\n        switch (e.name) {\r\n            case \"NotFoundError\":\r\n                return new FileError(ErrorCodes.ENOENT, message);\r\n            case \"QuotaExceededError\":\r\n                return new FileError(ErrorCodes.ENOSPC, message);\r\n            default:\r\n                // The rest do not seem to map cleanly to standard error codes.\r\n                return new FileError(ErrorCodes.EIO, message);\r\n        }\r\n    }\r\n    /**\r\n     * Produces a new onerror handler for IDB. Our errors are always fatal, so we\r\n     * handle them generically: Call the user-supplied callback with a translated\r\n     * version of the error, and let the error bubble up.\r\n     * @hidden\r\n     */\r\n    function onErrorHandler(cb, code = ErrorCodes.EIO, message = null) {\r\n        return function (e) {\r\n            // Prevent the error from canceling the transaction.\r\n            e.preventDefault();\r\n            cb(new FileError(code, message !== null ? message : undefined));\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    class IndexedDBRWTransaction extends IndexedDBROTransaction {\r\n        constructor(tx, store) {\r\n            super(tx, store);\r\n        }\r\n        put(key, data, overwrite, cb) {\r\n            try {\r\n                const arraybuffer = buffer2ArrayBuffer(data);\r\n                let r;\r\n                // Note: 'add' will never overwrite an existing key.\r\n                r = overwrite ? this.store.put(arraybuffer, key) : this.store.add(arraybuffer, key);\r\n                // XXX: NEED TO RETURN FALSE WHEN ADD HAS A KEY CONFLICT. NO ERROR.\r\n                r.onerror = onErrorHandler(cb);\r\n                r.onsuccess = (event) => {\r\n                    cb(null, true);\r\n                };\r\n            }\r\n            catch (e) {\r\n                cb(convertError(e));\r\n            }\r\n        }\r\n        del(key, cb) {\r\n            try {\r\n                // NOTE: IE8 has a bug with identifiers named 'delete' unless used as a string\r\n                // like this.\r\n                // http://stackoverflow.com/a/26479152\r\n                const r = this.store['delete'](key);\r\n                r.onerror = onErrorHandler(cb);\r\n                r.onsuccess = (event) => {\r\n                    cb();\r\n                };\r\n            }\r\n            catch (e) {\r\n                cb(convertError(e));\r\n            }\r\n        }\r\n        commit(cb) {\r\n            // Return to the event loop to commit the transaction.\r\n            setTimeout(cb, 0);\r\n        }\r\n        abort(cb) {\r\n            let _e = null;\r\n            try {\r\n                this.tx.abort();\r\n            }\r\n            catch (e) {\r\n                _e = convertError(e);\r\n            }\r\n            finally {\r\n                cb(_e);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return IndexedDBRWTransaction;\r\n});\ndefine('skylark-io-files/providers/indexeddb/indexed-db-store',[\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    \"./indexed-db-ro-transaction\",\r\n    \"./indexed-db-rw-transaction\"\r\n], function (FileError,ErrorCodes,IndexedDBROTransaction,IndexedDBRWTransaction) {\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * Converts a DOMException or a DOMError from an IndexedDB event into a\r\n     * standardized BrowserFS API error.\r\n     * @hidden\r\n     */\r\n    function convertError(e, message = e.toString()) {\r\n        switch (e.name) {\r\n            case \"NotFoundError\":\r\n                return new FileError(ErrorCodes.ENOENT, message);\r\n            case \"QuotaExceededError\":\r\n                return new FileError(ErrorCodes.ENOSPC, message);\r\n            default:\r\n                // The rest do not seem to map cleanly to standard error codes.\r\n                return new FileError(ErrorCodes.EIO, message);\r\n        }\r\n    }\r\n    /**\r\n     * Produces a new onerror handler for IDB. Our errors are always fatal, so we\r\n     * handle them generically: Call the user-supplied callback with a translated\r\n     * version of the error, and let the error bubble up.\r\n     * @hidden\r\n     */\r\n    function onErrorHandler(cb, code = ErrorCodes.EIO, message = null) {\r\n        return function (e) {\r\n            // Prevent the error from canceling the transaction.\r\n            e.preventDefault();\r\n            cb(new FileError(code, message !== null ? message : undefined));\r\n        };\r\n    }\r\n\r\n    class IndexedDBStore {\r\n        constructor(db, storeName) {\r\n            this.db = db;\r\n            this.storeName = storeName;\r\n        }\r\n        static Create(storeName, cb) {\r\n            const openReq = indexedDB.open(storeName, 1);\r\n            openReq.onupgradeneeded = (event) => {\r\n                const db = event.target.result;\r\n                // Huh. This should never happen; we're at version 1. Why does another\r\n                // database exist?\r\n                if (db.objectStoreNames.contains(storeName)) {\r\n                    db.deleteObjectStore(storeName);\r\n                }\r\n                db.createObjectStore(storeName);\r\n            };\r\n            openReq.onsuccess = (event) => {\r\n                cb(null, new IndexedDBStore(event.target.result, storeName));\r\n            };\r\n            openReq.onerror = onErrorHandler(cb, ErrorCodes.EACCES);\r\n        }\r\n        name() {\r\n            return IndexedDBProvider.Name + \" - \" + this.storeName;\r\n        }\r\n        clear(cb) {\r\n            try {\r\n                const tx = this.db.transaction(this.storeName, 'readwrite'), objectStore = tx.objectStore(this.storeName), r = objectStore.clear();\r\n                r.onsuccess = (event) => {\r\n                    // Use setTimeout to commit transaction.\r\n                    setTimeout(cb, 0);\r\n                };\r\n                r.onerror = onErrorHandler(cb);\r\n            }\r\n            catch (e) {\r\n                cb(convertError(e));\r\n            }\r\n        }\r\n        beginTransaction(type = 'readonly') {\r\n            const tx = this.db.transaction(this.storeName, type), objectStore = tx.objectStore(this.storeName);\r\n            if (type === 'readwrite') {\r\n                return new IndexedDBRWTransaction(tx, objectStore);\r\n            }\r\n            else if (type === 'readonly') {\r\n                return new IndexedDBROTransaction(tx, objectStore);\r\n            }\r\n            else {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Invalid transaction type.');\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return IndexedDBStore;\r\n});\ndefine('skylark-io-files/providers/indexeddb/indexed-db-provider',[\r\n    \"../../files\",\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    '../async-key-value-provider',\r\n    \"../registry\",\r\n    '../../utils',\r\n    \"./indexed-db-store\",\r\n    \"./indexed-db-ro-transaction\",\r\n    \"./indexed-db-rw-transaction\"\r\n], function (files,FileError,ErrorCodes, AsyncKeyValueProvider,  registry,utils,IndexedDBStore,IndexedDBROTransaction,IndexedDBRWTransaction) {\r\n    'use strict';\r\n\r\n    /**\r\n     * Get the indexedDB constructor for the current browser.\r\n     * @hidden\r\n     */\r\n    const indexedDB = window.indexedDB ||\r\n        window.mozIndexedDB ||\r\n        window.webkitIndexedDB ||\r\n        window.msIndexedDB;\r\n    /**\r\n     * A file system that uses the IndexedDB key value file system.\r\n     */\r\n    class IndexedDBProvider extends AsyncKeyValueProvider {\r\n        constructor(cacheSize) {\r\n            super(cacheSize);\r\n        }\r\n        /**\r\n         * Constructs an IndexedDB file system with the given options.\r\n         */\r\n        static Create(opts = {}, cb) {\r\n            IndexedDBStore.Create(opts.storeName ? opts.storeName : 'browserfs', (e, store) => {\r\n                if (store) {\r\n                    const idbfs = new IndexedDBProvider(typeof (opts.cacheSize) === 'number' ? opts.cacheSize : 100);\r\n                    idbfs.init(store, (e) => {\r\n                        if (e) {\r\n                            cb(e);\r\n                        }\r\n                        else {\r\n                            cb(null, idbfs);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    cb(e);\r\n                }\r\n            });\r\n        }\r\n        static isAvailable() {\r\n            // In Safari's private browsing mode, indexedDB.open returns NULL.\r\n            // In Firefox, it throws an exception.\r\n            // In Chrome, it \"just works\", and clears the database when you leave the page.\r\n            // Untested: Opera, IE.\r\n            try {\r\n                return typeof indexedDB !== 'undefined' && null !== indexedDB.open(\"__browserfs_test__\");\r\n            }\r\n            catch (e) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    IndexedDBProvider.Name = \"IndexedDB\";\r\n    IndexedDBProvider.Options = {\r\n        storeName: {\r\n            type: \"string\",\r\n            optional: true,\r\n            description: \"The name of this file system. You can have multiple IndexedDB file systems operating at once, but each must have a different name.\"\r\n        },\r\n        cacheSize: {\r\n            type: \"number\",\r\n            optional: true,\r\n            description: \"The size of the inode cache. Defaults to 100. A size of 0 or below disables caching.\"\r\n        }\r\n    };\r\n\r\n\r\n    IndexedDBProvider.IndexedDBROTransaction = IndexedDBROTransaction;\r\n    IndexedDBProvider.IndexedDBRWTransaction = IndexedDBRWTransaction;\r\n    IndexedDBProvider.IndexedDBStore = IndexedDBStore;\r\n\r\n    registry.add(\"indexedDB\",IndexedDBProvider);\r\n\r\n    return files.providers.IndexedDBProvider = IndexedDBProvider;\r\n});\ndefine('skylark-io-files/providers/synchronous-provider',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error',\r\n    '../action-type',\r\n    '../file-flag',\r\n    '../utils',\r\n    \"./base-provider\"\r\n], function (Buffer,paths, files,ErrorCodes, FileError, ActionType, FileFlag, utils,BaseProvider) {\r\n    'use strict';\r\n\r\n    const { fail } = utils;\r\n\r\n    /**\r\n     * Implements the asynchronous API in terms of the synchronous API.\r\n     * @class SynchronousProvider\r\n     */\r\n    class SynchronousProvider extends BaseProvider {\r\n        supportsSynch() {\r\n            return true;\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            try {\r\n                this.renameSync(oldPath, newPath);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            try {\r\n                cb(null, this.statSync(p, isLstat));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        open(p, flags, mode, cb) {\r\n            try {\r\n                cb(null, this.openSync(p, flags, mode));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        unlink(p, cb) {\r\n            try {\r\n                this.unlinkSync(p);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        rmdir(p, cb) {\r\n            try {\r\n                this.rmdirSync(p);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            try {\r\n                this.mkdirSync(p, mode);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        readdir(p, cb) {\r\n            try {\r\n                cb(null, this.readdirSync(p));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            try {\r\n                this.chmodSync(p, isLchmod, mode);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        chown(p, isLchown, uid, gid, cb) {\r\n            try {\r\n                this.chownSync(p, isLchown, uid, gid);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            try {\r\n                this.utimesSync(p, atime, mtime);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        link(srcpath, dstpath, cb) {\r\n            try {\r\n                this.linkSync(srcpath, dstpath);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        symlink(srcpath, dstpath, type, cb) {\r\n            try {\r\n                this.symlinkSync(srcpath, dstpath, type);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        readlink(p, cb) {\r\n            try {\r\n                cb(null, this.readlinkSync(p));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return files.providers.SynchronousProvider =  SynchronousProvider;\r\n});\ndefine('skylark-io-files/providers/sync-key-value-provider',[\r\n    \"skylark-langx-strings/generate-uuid\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error',\r\n    \"./base-provider\",\r\n    \"./synchronous-provider\",\r\n    '../utils'\r\n], function (GenerateRandomID, Buffer,paths,files,ErrorCodes, FileError,BaseProvider, SynchronousProvider,  utils) {\r\n    'use strict';\r\n\r\n    const { emptyBuffer } = utils;\r\n\r\n\r\n    /**\r\n     * A \"Synchronous key-value file system\". Stores data to/retrieves data from an\r\n     * underlying key-value store.\r\n     *\r\n     * We use a unique ID for each node in the file system. The root node has a\r\n     * fixed ID.\r\n     * @todo Introduce Node ID caching.\r\n     * @todo Check modes.\r\n     */\r\n    class SyncKeyValueProvider extends SynchronousProvider {\r\n        static isAvailable() { return true; }\r\n        constructor(options) {\r\n            super();\r\n            this.store = options.store;\r\n            // INVARIANT: Ensure that the root exists.\r\n            this.makeRootDirectory();\r\n        }\r\n        getName() { return this.store.name(); }\r\n        isReadOnly() { return false; }\r\n        supportsSymlinks() { return false; }\r\n        supportsProps() { return false; }\r\n        supportsSynch() { return true; }\r\n        /**\r\n         * Delete all contents stored in the file system.\r\n         */\r\n        empty() {\r\n            this.store.clear();\r\n            // INVARIANT: Root always exists.\r\n            this.makeRootDirectory();\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            const tx = this.store.beginTransaction('readwrite'), oldParent = paths.dirname(oldPath), oldName = paths.basename(oldPath), newParent = paths.dirname(newPath), newName = paths.basename(newPath), \r\n            // Remove oldPath from parent's directory listing.\r\n            oldDirNode = this.findINode(tx, oldParent), oldDirList = this.getDirListing(tx, oldParent, oldDirNode);\r\n            if (!oldDirList[oldName]) {\r\n                throw FileError.ENOENT(oldPath);\r\n            }\r\n            const nodeId = oldDirList[oldName];\r\n            delete oldDirList[oldName];\r\n            // Invariant: Can't move a folder inside itself.\r\n            // This funny little hack ensures that the check passes only if oldPath\r\n            // is a subpath of newParent. We append '/' to avoid matching folders that\r\n            // are a substring of the bottom-most folder in the path.\r\n            if ((newParent + '/').indexOf(oldPath + '/') === 0) {\r\n                throw new FileError(ErrorCodes.EBUSY, oldParent);\r\n            }\r\n            // Add newPath to parent's directory listing.\r\n            let newDirNode, newDirList;\r\n            if (newParent === oldParent) {\r\n                // Prevent us from re-grabbing the same directory listing, which still\r\n                // contains oldName.\r\n                newDirNode = oldDirNode;\r\n                newDirList = oldDirList;\r\n            }\r\n            else {\r\n                newDirNode = this.findINode(tx, newParent);\r\n                newDirList = this.getDirListing(tx, newParent, newDirNode);\r\n            }\r\n            if (newDirList[newName]) {\r\n                // If it's a file, delete it.\r\n                const newNameNode = this.getINode(tx, newPath, newDirList[newName]);\r\n                if (newNameNode.isFile()) {\r\n                    try {\r\n                        tx.del(newNameNode.id);\r\n                        tx.del(newDirList[newName]);\r\n                    }\r\n                    catch (e) {\r\n                        tx.abort();\r\n                        throw e;\r\n                    }\r\n                }\r\n                else {\r\n                    // If it's a directory, throw a permissions error.\r\n                    throw FileError.EPERM(newPath);\r\n                }\r\n            }\r\n            newDirList[newName] = nodeId;\r\n            // Commit the two changed directory listings.\r\n            try {\r\n                tx.put(oldDirNode.id, Buffer.from(JSON.stringify(oldDirList)), true);\r\n                tx.put(newDirNode.id, Buffer.from(JSON.stringify(newDirList)), true);\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            tx.commit();\r\n        }\r\n        statSync(p, isLstat) {\r\n            // Get the inode to the item, convert it into a Stats object.\r\n            return this.findINode(this.store.beginTransaction('readonly'), p).toStats();\r\n        }\r\n        createFileSync(p, flag, mode) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = emptyBuffer(), newFile = this.commitNewFile(tx, p, FileType.FILE, mode, data);\r\n            // Open the file.\r\n            return new SyncKeyValueFile(this, p, flag, newFile.toStats(), data);\r\n        }\r\n        openFileSync(p, flag) {\r\n            const tx = this.store.beginTransaction('readonly'), node = this.findINode(tx, p), data = tx.get(node.id);\r\n            if (data === undefined) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            return new SyncKeyValueFile(this, p, flag, node.toStats(), data);\r\n        }\r\n        unlinkSync(p) {\r\n            this.removeEntry(p, false);\r\n        }\r\n        rmdirSync(p) {\r\n            // Check first if directory is empty.\r\n            if (this.readdirSync(p).length > 0) {\r\n                throw FileError.ENOTEMPTY(p);\r\n            }\r\n            else {\r\n                this.removeEntry(p, true);\r\n            }\r\n        }\r\n        mkdirSync(p, mode) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');\r\n            this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data);\r\n        }\r\n        readdirSync(p) {\r\n            const tx = this.store.beginTransaction('readonly');\r\n            return Object.keys(this.getDirListing(tx, p, this.findINode(tx, p)));\r\n        }\r\n        _syncSync(p, data, stats) {\r\n            // @todo Ensure mtime updates properly, and use that to determine if a data\r\n            //       update is required.\r\n            const tx = this.store.beginTransaction('readwrite'), \r\n            // We use the _findInode helper because we actually need the INode id.\r\n            fileInodeId = this._findINode(tx, paths.dirname(p), paths.basename(p)), fileInode = this.getINode(tx, p, fileInodeId), inodeChanged = fileInode.update(stats);\r\n            try {\r\n                // Sync data.\r\n                tx.put(fileInode.id, data, true);\r\n                // Sync metadata.\r\n                if (inodeChanged) {\r\n                    tx.put(fileInodeId, fileInode.toBuffer(), true);\r\n                }\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            tx.commit();\r\n        }\r\n        /**\r\n         * Checks if the root directory exists. Creates it if it doesn't.\r\n         */\r\n        makeRootDirectory() {\r\n            const tx = this.store.beginTransaction('readwrite');\r\n            if (tx.get(ROOT_NODE_ID) === undefined) {\r\n                // Create new inode.\r\n                const currTime = (new Date()).getTime(), \r\n                // Mode 0666\r\n                dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);\r\n                // If the root doesn't exist, the first random ID shouldn't exist,\r\n                // either.\r\n                tx.put(dirInode.id, getEmptyDirNode(), false);\r\n                tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false);\r\n                tx.commit();\r\n            }\r\n        }\r\n        /**\r\n         * Helper function for findINode.\r\n         * @param parent The parent directory of the file we are attempting to find.\r\n         * @param filename The filename of the inode we are attempting to find, minus\r\n         *   the parent.\r\n         * @return string The ID of the file's inode in the file system.\r\n         */\r\n        _findINode(tx, parent, filename) {\r\n            const readDirectory = (inode) => {\r\n                // Get the root's directory listing.\r\n                const dirList = this.getDirListing(tx, parent, inode);\r\n                // Get the file's ID.\r\n                if (dirList[filename]) {\r\n                    return dirList[filename];\r\n                }\r\n                else {\r\n                    throw FileError.ENOENT(paths.resolve(parent, filename));\r\n                }\r\n            };\r\n            if (parent === '/') {\r\n                if (filename === '') {\r\n                    // BASE CASE #1: Return the root's ID.\r\n                    return ROOT_NODE_ID;\r\n                }\r\n                else {\r\n                    // BASE CASE #2: Find the item in the root ndoe.\r\n                    return readDirectory(this.getINode(tx, parent, ROOT_NODE_ID));\r\n                }\r\n            }\r\n            else {\r\n                return readDirectory(this.getINode(tx, parent + paths.sep + filename, this._findINode(tx, paths.dirname(parent), paths.basename(parent))));\r\n            }\r\n        }\r\n        /**\r\n         * Finds the Inode of the given path.\r\n         * @param p The path to look up.\r\n         * @return The Inode of the path p.\r\n         * @todo memoize/cache\r\n         */\r\n        findINode(tx, p) {\r\n            return this.getINode(tx, p, this._findINode(tx, paths.dirname(p), paths.basename(p)));\r\n        }\r\n        /**\r\n         * Given the ID of a node, retrieves the corresponding Inode.\r\n         * @param tx The transaction to use.\r\n         * @param p The corresponding path to the file (used for error messages).\r\n         * @param id The ID to look up.\r\n         */\r\n        getINode(tx, p, id) {\r\n            const inode = tx.get(id);\r\n            if (inode === undefined) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            return Inode.fromBuffer(inode);\r\n        }\r\n        /**\r\n         * Given the Inode of a directory, retrieves the corresponding directory\r\n         * listing.\r\n         */\r\n        getDirListing(tx, p, inode) {\r\n            if (!inode.isDirectory()) {\r\n                throw FileError.ENOTDIR(p);\r\n            }\r\n            const data = tx.get(inode.id);\r\n            if (data === undefined) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            return JSON.parse(data.toString());\r\n        }\r\n        /**\r\n         * Creates a new node under a random ID. Retries 5 times before giving up in\r\n         * the exceedingly unlikely chance that we try to reuse a random GUID.\r\n         * @return The GUID that the data was stored under.\r\n         */\r\n        addNewNode(tx, data) {\r\n            const retries = 0;\r\n            let currId;\r\n            while (retries < 5) {\r\n                try {\r\n                    currId = GenerateRandomID();\r\n                    tx.put(currId, data, false);\r\n                    return currId;\r\n                }\r\n                catch (e) {\r\n                    // Ignore and reroll.\r\n                }\r\n            }\r\n            throw new FileError(ErrorCodes.EIO, 'Unable to commit data to key-value store.');\r\n        }\r\n        /**\r\n         * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\r\n         * the given mode.\r\n         * Note: This will commit the transaction.\r\n         * @param p The path to the new file.\r\n         * @param type The type of the new file.\r\n         * @param mode The mode to create the new file with.\r\n         * @param data The data to store at the file's data node.\r\n         * @return The Inode for the new file.\r\n         */\r\n        commitNewFile(tx, p, type, mode, data) {\r\n            const parentDir = paths.dirname(p), fname = paths.basename(p), parentNode = this.findINode(tx, parentDir), dirListing = this.getDirListing(tx, parentDir, parentNode), currTime = (new Date()).getTime();\r\n            // Invariant: The root always exists.\r\n            // If we don't check this prior to taking steps below, we will create a\r\n            // file with name '' in root should p == '/'.\r\n            if (p === '/') {\r\n                throw FileError.EEXIST(p);\r\n            }\r\n            // Check if file already exists.\r\n            if (dirListing[fname]) {\r\n                throw FileError.EEXIST(p);\r\n            }\r\n            let fileNode;\r\n            try {\r\n                // Commit data.\r\n                const dataId = this.addNewNode(tx, data);\r\n                fileNode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\r\n                // Commit file node.\r\n                const fileNodeId = this.addNewNode(tx, fileNode.toBuffer());\r\n                // Update and commit parent directory listing.\r\n                dirListing[fname] = fileNodeId;\r\n                tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true);\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            tx.commit();\r\n            return fileNode;\r\n        }\r\n        /**\r\n         * Remove all traces of the given path from the file system.\r\n         * @param p The path to remove from the file system.\r\n         * @param isDir Does the path belong to a directory, or a file?\r\n         * @todo Update mtime.\r\n         */\r\n        removeEntry(p, isDir) {\r\n            const tx = this.store.beginTransaction('readwrite'), parent = paths.dirname(p), parentNode = this.findINode(tx, parent), parentListing = this.getDirListing(tx, parent, parentNode), fileName = paths.basename(p);\r\n            if (!parentListing[fileName]) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            // Remove from directory listing of parent.\r\n            const fileNodeId = parentListing[fileName];\r\n            delete parentListing[fileName];\r\n            // Get file inode.\r\n            const fileNode = this.getINode(tx, p, fileNodeId);\r\n            if (!isDir && fileNode.isDirectory()) {\r\n                throw FileError.EISDIR(p);\r\n            }\r\n            else if (isDir && !fileNode.isDirectory()) {\r\n                throw FileError.ENOTDIR(p);\r\n            }\r\n            try {\r\n                // Delete data.\r\n                tx.del(fileNode.id);\r\n                // Delete node.\r\n                tx.del(fileNodeId);\r\n                // Update directory listing.\r\n                tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true);\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            // Success.\r\n            tx.commit();\r\n        }\r\n    }\r\n\r\n\r\n    return files.providers.SyncKeyValueProvider = SyncKeyValueProvider;\r\n});\ndefine('skylark-io-files/providers/simple-sync-rw-transaction',[\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error'\r\n], function (files, ErrorCodes, FileError) {\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * A simple RW transaction for simple synchronous key-value stores.\r\n     */\r\n    class SimpleSyncRWTransaction {\r\n        constructor(store) {\r\n            this.store = store;\r\n            /**\r\n             * Stores data in the keys we modify prior to modifying them.\r\n             * Allows us to roll back commits.\r\n             */\r\n            this.originalData = {};\r\n            /**\r\n             * List of keys modified in this transaction, if any.\r\n             */\r\n            this.modifiedKeys = [];\r\n        }\r\n        get(key) {\r\n            const val = this.store.get(key);\r\n            this.stashOldValue(key, val);\r\n            return val;\r\n        }\r\n        put(key, data, overwrite) {\r\n            this.markModified(key);\r\n            return this.store.put(key, data, overwrite);\r\n        }\r\n        del(key) {\r\n            this.markModified(key);\r\n            this.store.del(key);\r\n        }\r\n        commit() { }\r\n        abort() {\r\n            // Rollback old values.\r\n            for (const key of this.modifiedKeys) {\r\n                const value = this.originalData[key];\r\n                if (!value) {\r\n                    // Key didn't exist.\r\n                    this.store.del(key);\r\n                }\r\n                else {\r\n                    // Key existed. Store old value.\r\n                    this.store.put(key, value, true);\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Stashes given key value pair into `originalData` if it doesn't already\r\n         * exist. Allows us to stash values the program is requesting anyway to\r\n         * prevent needless `get` requests if the program modifies the data later\r\n         * on during the transaction.\r\n         */\r\n        stashOldValue(key, value) {\r\n            // Keep only the earliest value in the transaction.\r\n            if (!this.originalData.hasOwnProperty(key)) {\r\n                this.originalData[key] = value;\r\n            }\r\n        }\r\n        /**\r\n         * Marks the given key as modified, and stashes its value if it has not been\r\n         * stashed already.\r\n         */\r\n        markModified(key) {\r\n            if (this.modifiedKeys.indexOf(key) === -1) {\r\n                this.modifiedKeys.push(key);\r\n                if (!this.originalData.hasOwnProperty(key)) {\r\n                    this.originalData[key] = this.store.get(key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return files.providers.SimpleSyncRWTransaction = SimpleSyncRWTransaction;\r\n});\ndefine('skylark-io-files/providers/inmemory/in-memory-store',[\r\n    '../simple-sync-rw-transaction'\r\n], function (SimpleSyncRWTransaction) {\r\n    'use strict';\r\n\r\n    /**\r\n     * A simple in-memory key-value store backed by a JavaScript object.\r\n     */\r\n    class InMemoryStore {\r\n        constructor() {\r\n            this.store = {};\r\n        }\r\n        clear() { this.store = {}; }\r\n        beginTransaction(type) {\r\n            return new SimpleSyncRWTransaction(this);\r\n        }\r\n        get(key) {\r\n            return this.store[key];\r\n        }\r\n        put(key, data, overwrite) {\r\n            if (!overwrite && this.store.hasOwnProperty(key)) {\r\n                return false;\r\n            }\r\n            this.store[key] = data;\r\n            return true;\r\n        }\r\n        del(key) {\r\n            delete this.store[key];\r\n        }\r\n    }\r\n\r\n\r\n    return InMemoryStore;\r\n});\ndefine('skylark-io-files/providers/inmemory/in-memory-provider',[\r\n    \"../../files\",\r\n    \"../registry\",\r\n    '../sync-key-value-provider',\r\n    \"./in-memory-store\"\r\n], function (files,registry,SyncKeyValueProvider,InMemoryStore) {\r\n    'use strict';\r\n\r\n    /**\r\n     * A simple in-memory file system backed by an InMemoryStore.\r\n     * Files are not persisted across page loads.\r\n     */\r\n    class InMemoryProvider extends SyncKeyValueProvider {\r\n        name() { return InMemoryProvider.Name; }\r\n        constructor() {\r\n            super({ store: new InMemoryStore() });\r\n        }\r\n        /**\r\n         * Creates an InMemoryProvider instance.\r\n         */\r\n        static Create(options, cb) {\r\n            cb(null, new InMemoryProvider());\r\n        }\r\n    }\r\n    InMemoryProvider.Name = \"InMemory\";\r\n    InMemoryProvider.Options = {};\r\n\r\n    InMemoryProvider.InMemoryStore = InMemoryStore;\r\n\r\n\r\n    registry.add(\"inMemory\",InMemoryProvider);\r\n\r\n\r\n    return files.providers.InMemoryProvider = InMemoryProvider;\r\n});\ndefine('skylark-io-files/providers/localstorage/local-storage-store',[\r\n    \"skylark-langx-binary/buffer\",\r\n    '../simple-sync-rw-transaction',\r\n    '../../error-codes',\r\n    '../../file-error',\r\n], function (Buffer,SimpleSyncRWTransaction, ErrorCodes,FileError) {\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * A synchronous key-value store backed by localStorage.\r\n     */\r\n    class LocalStorageStore {\r\n        name() {\r\n            return LocalStorageProvider.Name;\r\n        }\r\n        clear() {\r\n            window.localStorage.clear();\r\n        }\r\n        beginTransaction(type) {\r\n            // No need to differentiate.\r\n            return new SimpleSyncRWTransaction(this);\r\n        }\r\n        get(key) {\r\n            try {\r\n                const data = window.localStorage.getItem(key);\r\n                if (data !== null) {\r\n                    return Buffer.from(data, binaryEncoding);\r\n                }\r\n            }\r\n            catch (e) {\r\n                // Do nothing.\r\n            }\r\n            // Key doesn't exist, or a failure occurred.\r\n            return undefined;\r\n        }\r\n        put(key, data, overwrite) {\r\n            try {\r\n                if (!overwrite && window.localStorage.getItem(key) !== null) {\r\n                    // Don't want to overwrite the key!\r\n                    return false;\r\n                }\r\n                window.localStorage.setItem(key, data.toString(binaryEncoding));\r\n                return true;\r\n            }\r\n            catch (e) {\r\n                throw new FileError(ErrorCodes.ENOSPC, \"LocalStorage is full.\");\r\n            }\r\n        }\r\n        del(key) {\r\n            try {\r\n                window.localStorage.removeItem(key);\r\n            }\r\n            catch (e) {\r\n                throw new FileError(ErrorCodes.EIO, \"Unable to delete key \" + key + \": \" + e);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return LocalStorageStore;\r\n});\ndefine('skylark-io-files/providers/localstorage/local-storage-provider',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"../../files\",\r\n    \"../registry\",\r\n    '../sync-key-value-provider',\r\n    '../../error-codes',\r\n    '../../file-error',\r\n    \"./local-storage-store\"\r\n], function (Buffer,files,registry,SyncKeyValueProvider, ErrorCodes,FileError,LocalStorageStore) {\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * Some versions of FF and all versions of IE do not support the full range of\r\n     * 16-bit numbers encoded as characters, as they enforce UTF-16 restrictions.\r\n     * @url http://stackoverflow.com/questions/11170716/are-there-any-characters-that-are-not-allowed-in-localstorage/11173673#11173673\r\n     * @hidden\r\n     */\r\n    let supportsBinaryString = false, binaryEncoding;\r\n    try {\r\n        window.localStorage.setItem(\"__test__\", String.fromCharCode(0xD800));\r\n        supportsBinaryString = window.localStorage.getItem(\"__test__\") === String.fromCharCode(0xD800);\r\n    }\r\n    catch (e) {\r\n        // IE throws an exception.\r\n        supportsBinaryString = false;\r\n    }\r\n    \r\n    binaryEncoding = supportsBinaryString ? 'binary_string' : 'binary_string_ie';\r\n    if (!Buffer.isEncoding(binaryEncoding)) {\r\n        // Fallback for non BrowserFS implementations of buffer that lack a\r\n        // binary_string format.\r\n        binaryEncoding = \"base64\";\r\n    }\r\n\r\n    /**\r\n     * A synchronous file system backed by localStorage. Connects our\r\n     * LocalStorageStore to our SyncKeyValueProvider.\r\n     */\r\n    class LocalStorageProvider extends SyncKeyValueProvider {\r\n        /**\r\n         * Creates a new LocalStorage file system using the contents of `localStorage`.\r\n         */\r\n        constructor() { super({ store: new LocalStorageStore() }); }\r\n        /**\r\n         * Creates a LocalStorageProvider instance.\r\n         */\r\n        static Create(options, cb) {\r\n            cb(null, new LocalStorageProvider());\r\n        }\r\n        static isAvailable() {\r\n            return typeof window.localStorage !== 'undefined';\r\n        }\r\n    }\r\n\r\n    LocalStorageProvider.Name = \"LocalStorage\";\r\n    LocalStorageProvider.Options = {};\r\n    \r\n    LocalStorageProvider.LocalStorageStore = LocalStorageStore;\r\n\r\n    registry.add(\"localStorage\",LocalStorageProvider);\r\n\r\n\r\n    return files.providers.LocalStorageProvider = LocalStorageProvider;\r\n});\ndefine('skylark-io-files/providers/mutex',[\r\n    \"skylark-langx-funcs/defer\"\r\n], function (defer) {\r\n    'use strict';\r\n    /**\r\n     * Non-recursive mutex\r\n     * @hidden\r\n     */\r\n    class Mutex {\r\n        constructor() {\r\n            this._locked = false;\r\n            this._waiters = [];\r\n        }\r\n        lock(cb) {\r\n            if (this._locked) {\r\n                this._waiters.push(cb);\r\n                return;\r\n            }\r\n            this._locked = true;\r\n            cb();\r\n        }\r\n        unlock() {\r\n            if (!this._locked) {\r\n                throw new Error('unlock of a non-locked mutex');\r\n            }\r\n            const next = this._waiters.shift();\r\n            // don't unlock - we want to queue up next for the\r\n            // _end_ of the current task execution, but we don't\r\n            // want it to be called inline with whatever the\r\n            // current stack is.  This way we still get the nice\r\n            // behavior that an unlock immediately followed by a\r\n            // lock won't cause starvation.\r\n            if (next) {\r\n                defer(next);\r\n                return;\r\n            }\r\n            this._locked = false;\r\n        }\r\n        tryLock() {\r\n            if (this._locked) {\r\n                return false;\r\n            }\r\n            this._locked = true;\r\n            return true;\r\n        }\r\n        isLocked() {\r\n            return this._locked;\r\n        }\r\n    }\r\n\r\n    return Mutex;\r\n});\ndefine('skylark-io-files/providers/locked-provider',[\r\n    \"../files\",\r\n    './mutex'\r\n], function (files,Mutex) {\r\n    'use strict';\r\n    /**\r\n     * This class serializes access to an underlying async filesystem.\r\n     * For example, on an OverlayFS instance with an async lower\r\n     * directory operations like rename and rmdir may involve multiple\r\n     * requests involving both the upper and lower filesystems -- they\r\n     * are not executed in a single atomic step.  OverlayFS uses this\r\n     * LockedProvider to avoid having to reason about the correctness of\r\n     * multiple requests interleaving.\r\n     */\r\n    class LockedProvider {\r\n        constructor(fs) {\r\n            this._fs = fs;\r\n            this._mu = new Mutex();\r\n        }\r\n        getName() {\r\n            return 'LockedProvider<' + this._fs.getName() + '>';\r\n        }\r\n        getFSUnlocked() {\r\n            return this._fs;\r\n        }\r\n        diskSpace(p, cb) {\r\n            // FIXME: should this lock?\r\n            this._fs.diskSpace(p, cb);\r\n        }\r\n        isReadOnly() {\r\n            return this._fs.isReadOnly();\r\n        }\r\n        supportsLinks() {\r\n            return this._fs.supportsLinks();\r\n        }\r\n        supportsProps() {\r\n            return this._fs.supportsProps();\r\n        }\r\n        supportsSynch() {\r\n            return this._fs.supportsSynch();\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.rename(oldPath, newPath, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.renameSync(oldPath, newPath);\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.stat(p, isLstat, (err, stat) => {\r\n                    this._mu.unlock();\r\n                    cb(err, stat);\r\n                });\r\n            });\r\n        }\r\n        statSync(p, isLstat) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.statSync(p, isLstat);\r\n        }\r\n        open(p, flag, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.open(p, flag, mode, (err, fd) => {\r\n                    this._mu.unlock();\r\n                    cb(err, fd);\r\n                });\r\n            });\r\n        }\r\n        openSync(p, flag, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.openSync(p, flag, mode);\r\n        }\r\n        unlink(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.unlink(p, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        unlinkSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.unlinkSync(p);\r\n        }\r\n        rmdir(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.rmdir(p, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        rmdirSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.rmdirSync(p);\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.mkdir(p, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        mkdirSync(p, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.mkdirSync(p, mode);\r\n        }\r\n        readdir(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.readdir(p, (err, files) => {\r\n                    this._mu.unlock();\r\n                    cb(err, files);\r\n                });\r\n            });\r\n        }\r\n        readdirSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.readdirSync(p);\r\n        }\r\n        exists(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.exists(p, (exists) => {\r\n                    this._mu.unlock();\r\n                    cb(exists);\r\n                });\r\n            });\r\n        }\r\n        existsSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.existsSync(p);\r\n        }\r\n        realpath(p, cache, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.realpath(p, cache, (err, resolvedPath) => {\r\n                    this._mu.unlock();\r\n                    cb(err, resolvedPath);\r\n                });\r\n            });\r\n        }\r\n        realpathSync(p, cache) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.realpathSync(p, cache);\r\n        }\r\n        truncate(p, len, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.truncate(p, len, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        truncateSync(p, len) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.truncateSync(p, len);\r\n        }\r\n        readFile(fname, encoding, flag, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.readFile(fname, encoding, flag, (err, data) => {\r\n                    this._mu.unlock();\r\n                    cb(err, data);\r\n                });\r\n            });\r\n        }\r\n        readFileSync(fname, encoding, flag) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.readFileSync(fname, encoding, flag);\r\n        }\r\n        writeFile(fname, data, encoding, flag, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.writeFile(fname, data, encoding, flag, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        writeFileSync(fname, data, encoding, flag, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.writeFileSync(fname, data, encoding, flag, mode);\r\n        }\r\n        appendFile(fname, data, encoding, flag, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.appendFile(fname, data, encoding, flag, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        appendFileSync(fname, data, encoding, flag, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.appendFileSync(fname, data, encoding, flag, mode);\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.chmod(p, isLchmod, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        chmodSync(p, isLchmod, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.chmodSync(p, isLchmod, mode);\r\n        }\r\n        chown(p, isLchown, uid, gid, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.chown(p, isLchown, uid, gid, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        chownSync(p, isLchown, uid, gid) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.chownSync(p, isLchown, uid, gid);\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.utimes(p, atime, mtime, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        utimesSync(p, atime, mtime) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.utimesSync(p, atime, mtime);\r\n        }\r\n        link(srcpath, dstpath, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.link(srcpath, dstpath, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        linkSync(srcpath, dstpath) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.linkSync(srcpath, dstpath);\r\n        }\r\n        symlink(srcpath, dstpath, type, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.symlink(srcpath, dstpath, type, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.symlinkSync(srcpath, dstpath, type);\r\n        }\r\n        readlink(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.readlink(p, (err, linkString) => {\r\n                    this._mu.unlock();\r\n                    cb(err, linkString);\r\n                });\r\n            });\r\n        }\r\n        readlinkSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.readlinkSync(p);\r\n        }\r\n    }\r\n\r\n    return files.providers.LockedProvider = LockedProvider;\r\n});\ndefine('skylark-io-files/providers/overlay/overlay-file',[\r\n    '../../preload-file'\r\n], function (PreloadFile) {\r\n\r\n    /**\r\n     * Overlays a RO file to make it writable.\r\n     */\r\n    class OverlayFile extends PreloadFile {\r\n        constructor(fs, path, flag, stats, data) {\r\n            super(fs, path, flag, stats, data);\r\n        }\r\n        sync(cb) {\r\n            if (!this.isDirty()) {\r\n                cb(null);\r\n                return;\r\n            }\r\n            this._fs._syncAsync(this, (err) => {\r\n                this.resetDirty();\r\n                cb(err);\r\n            });\r\n        }\r\n        syncSync() {\r\n            if (this.isDirty()) {\r\n                this._fs._syncSync(this);\r\n                this.resetDirty();\r\n            }\r\n        }\r\n        close(cb) {\r\n            this.sync(cb);\r\n        }\r\n        closeSync() {\r\n            this.syncSync();\r\n        }\r\n    }\r\n\r\n\r\n    return OverlayFile;\r\n});\ndefine('skylark-io-files/providers/overlay/unlocked-overlay-provider',[\r\n    \"skylark-langx-paths\",\r\n    \"../base-provider\",\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    \"../../file-flag\",\r\n    \"../../action-type\",\r\n    \"./overlay-file\"\r\n], function (paths, BaseProvider, Stats,FileType,FileError, ErrorCodes, FileFlag,ActionType,OverlayFile) {\r\n    /**\r\n     * @hidden\r\n     */\r\n    const deletionLogPath = '/.deletedFiles.log';\r\n\r\n    /**\r\n     * Given a read-only mode, makes it writable.\r\n     * @hidden\r\n     */\r\n    function makeModeWritable(mode) {\r\n        return 0o222 | mode;\r\n    }\r\n\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    function getFlag(f) {\r\n        return FileFlag.getFileFlag(f);\r\n    }    \r\n     /**\r\n     * *INTERNAL, DO NOT USE DIRECTLY!*\r\n     *\r\n     * Core OverlayProviderclass that contains no locking whatsoever. We wrap these objects\r\n     * in a LockedFS to prevent races.\r\n     */\r\n    class UnlockedOverlayProvider extends BaseProvider {\r\n        constructor(writable, readable) {\r\n            super();\r\n            this._isInitialized = false;\r\n            this._initializeCallbacks = [];\r\n            this._deletedFiles = {};\r\n            this._deleteLog = '';\r\n            // If 'true', we have scheduled a delete log update.\r\n            this._deleteLogUpdatePending = false;\r\n            // If 'true', a delete log update is needed after the scheduled delete log\r\n            // update finishes.\r\n            this._deleteLogUpdateNeeded = false;\r\n            // If there was an error updating the delete log...\r\n            this._deleteLogError = null;\r\n            this._writable = writable;\r\n            this._readable = readable;\r\n            if (this._writable.isReadOnly()) {\r\n                throw new FileError(ErrorCodes.EINVAL, \"Writable file system must be writable.\");\r\n            }\r\n        }\r\n        static isAvailable() {\r\n            return true;\r\n        }\r\n        getOverlayedProviders() {\r\n            return {\r\n                readable: this._readable,\r\n                writable: this._writable\r\n            };\r\n        }\r\n        _syncAsync(file, cb) {\r\n            this.createParentDirectoriesAsync(file.getPath(), (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                this._writable.writeFile(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode, cb);\r\n            });\r\n        }\r\n        _syncSync(file) {\r\n            this.createParentDirectories(file.getPath());\r\n            this._writable.writeFileSync(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode);\r\n        }\r\n        getName() {\r\n            return OverlayFS.Name;\r\n        }\r\n        /**\r\n         * **INTERNAL METHOD**\r\n         *\r\n         * Called once to load up metadata stored on the writable file system.\r\n         */\r\n        _initialize(cb) {\r\n            const callbackArray = this._initializeCallbacks;\r\n            const end = (e) => {\r\n                this._isInitialized = !e;\r\n                this._initializeCallbacks = [];\r\n                callbackArray.forEach(((cb) => cb(e)));\r\n            };\r\n            // if we're already initialized, immediately invoke the callback\r\n            if (this._isInitialized) {\r\n                return cb();\r\n            }\r\n            callbackArray.push(cb);\r\n            // The first call to initialize initializes, the rest wait for it to complete.\r\n            if (callbackArray.length !== 1) {\r\n                return;\r\n            }\r\n            // Read deletion log, process into metadata.\r\n            this._writable.readFile(deletionLogPath, 'utf8', getFlag('r'), (err, data) => {\r\n                if (err) {\r\n                    // ENOENT === Newly-instantiated file system, and thus empty log.\r\n                    if (err.errno !== ErrorCodes.ENOENT) {\r\n                        return end(err);\r\n                    }\r\n                }\r\n                else {\r\n                    this._deleteLog = data;\r\n                }\r\n                this._reparseDeletionLog();\r\n                end();\r\n            });\r\n        }\r\n        isReadOnly() { return false; }\r\n        supportsSynch() { return this._readable.supportsSynch() && this._writable.supportsSynch(); }\r\n        supportsLinks() { return false; }\r\n        supportsProps() { return this._readable.supportsProps() && this._writable.supportsProps(); }\r\n        getDeletionLog() {\r\n            return this._deleteLog;\r\n        }\r\n        restoreDeletionLog(log) {\r\n            this._deleteLog = log;\r\n            this._reparseDeletionLog();\r\n            this.updateLog('');\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(oldPath, cb) || this.checkPathAsync(newPath, cb)) {\r\n                return;\r\n            }\r\n            if (oldPath === deletionLogPath || newPath === deletionLogPath) {\r\n                return cb(FileError.EPERM('Cannot rename deletion log.'));\r\n            }\r\n            // nothing to do if paths match\r\n            if (oldPath === newPath) {\r\n                return cb();\r\n            }\r\n            this.stat(oldPath, false, (oldErr, oldStats) => {\r\n                if (oldErr) {\r\n                    return cb(oldErr);\r\n                }\r\n                return this.stat(newPath, false, (newErr, newStats) => {\r\n                    const self = this;\r\n                    // precondition: both oldPath and newPath exist and are dirs.\r\n                    // decreases: |files|\r\n                    // Need to move *every file/folder* currently stored on\r\n                    // readable to its new location on writable.\r\n                    function copyDirContents(files) {\r\n                        const file = files.shift();\r\n                        if (!file) {\r\n                            return cb();\r\n                        }\r\n                        const oldFile = paths.resolve(oldPath, file);\r\n                        const newFile = paths.resolve(newPath, file);\r\n                        // Recursion! Should work for any nested files / folders.\r\n                        self.rename(oldFile, newFile, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            copyDirContents(files);\r\n                        });\r\n                    }\r\n                    let mode = 0o777;\r\n                    // from linux's rename(2) manpage: oldpath can specify a\r\n                    // directory.  In this case, newpath must either not exist, or\r\n                    // it must specify an empty directory.\r\n                    if (oldStats.isDirectory()) {\r\n                        if (newErr) {\r\n                            if (newErr.errno !== ErrorCodes.ENOENT) {\r\n                                return cb(newErr);\r\n                            }\r\n                            return this._writable.exists(oldPath, (exists) => {\r\n                                // simple case - both old and new are on the writable layer\r\n                                if (exists) {\r\n                                    return this._writable.rename(oldPath, newPath, cb);\r\n                                }\r\n                                this._writable.mkdir(newPath, mode, (mkdirErr) => {\r\n                                    if (mkdirErr) {\r\n                                        return cb(mkdirErr);\r\n                                    }\r\n                                    this._readable.readdir(oldPath, (err, files) => {\r\n                                        if (err) {\r\n                                            return cb();\r\n                                        }\r\n                                        copyDirContents(files);\r\n                                    });\r\n                                });\r\n                            });\r\n                        }\r\n                        mode = newStats.mode;\r\n                        if (!newStats.isDirectory()) {\r\n                            return cb(FileError.ENOTDIR(newPath));\r\n                        }\r\n                        this.readdir(newPath, (readdirErr, files) => {\r\n                            if (files && files.length) {\r\n                                return cb(FileError.ENOTEMPTY(newPath));\r\n                            }\r\n                            this._readable.readdir(oldPath, (err, files) => {\r\n                                if (err) {\r\n                                    return cb();\r\n                                }\r\n                                copyDirContents(files);\r\n                            });\r\n                        });\r\n                    }\r\n                    if (newStats && newStats.isDirectory()) {\r\n                        return cb(FileError.EISDIR(newPath));\r\n                    }\r\n                    this.readFile(oldPath, null, getFlag('r'), (err, data) => {\r\n                        if (err) {\r\n                            return cb(err);\r\n                        }\r\n                        return this.writeFile(newPath, data, null, getFlag('w'), oldStats.mode, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            return this.unlink(oldPath, cb);\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            this.checkInitialized();\r\n            this.checkPath(oldPath);\r\n            this.checkPath(newPath);\r\n            if (oldPath === deletionLogPath || newPath === deletionLogPath) {\r\n                throw FileError.EPERM('Cannot rename deletion log.');\r\n            }\r\n            // Write newPath using oldPath's contents, delete oldPath.\r\n            const oldStats = this.statSync(oldPath, false);\r\n            if (oldStats.isDirectory()) {\r\n                // Optimization: Don't bother moving if old === new.\r\n                if (oldPath === newPath) {\r\n                    return;\r\n                }\r\n                let mode = 0o777;\r\n                if (this.existsSync(newPath)) {\r\n                    const stats = this.statSync(newPath, false);\r\n                    mode = stats.mode;\r\n                    if (stats.isDirectory()) {\r\n                        if (this.readdirSync(newPath).length > 0) {\r\n                            throw FileError.ENOTEMPTY(newPath);\r\n                        }\r\n                    }\r\n                    else {\r\n                        throw FileError.ENOTDIR(newPath);\r\n                    }\r\n                }\r\n                // Take care of writable first. Move any files there, or create an empty directory\r\n                // if it doesn't exist.\r\n                if (this._writable.existsSync(oldPath)) {\r\n                    this._writable.renameSync(oldPath, newPath);\r\n                }\r\n                else if (!this._writable.existsSync(newPath)) {\r\n                    this._writable.mkdirSync(newPath, mode);\r\n                }\r\n                // Need to move *every file/folder* currently stored on readable to its new location\r\n                // on writable.\r\n                if (this._readable.existsSync(oldPath)) {\r\n                    this._readable.readdirSync(oldPath).forEach((name) => {\r\n                        // Recursion! Should work for any nested files / folders.\r\n                        this.renameSync(paths.resolve(oldPath, name), paths.resolve(newPath, name));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                if (this.existsSync(newPath) && this.statSync(newPath, false).isDirectory()) {\r\n                    throw FileError.EISDIR(newPath);\r\n                }\r\n                this.writeFileSync(newPath, this.readFileSync(oldPath, null, getFlag('r')), null, getFlag('w'), oldStats.mode);\r\n            }\r\n            if (oldPath !== newPath && this.existsSync(oldPath)) {\r\n                this.unlinkSync(oldPath);\r\n            }\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this._writable.stat(p, isLstat, (err, stat) => {\r\n                if (err && err.errno === ErrorCodes.ENOENT) {\r\n                    if (this._deletedFiles[p]) {\r\n                        cb(FileError.ENOENT(p));\r\n                    }\r\n                    this._readable.stat(p, isLstat, (err, stat) => {\r\n                        if (stat) {\r\n                            // Make the oldStat's mode writable. Preserve the topmost\r\n                            // part of the mode, which specifies if it is a file or a\r\n                            // directory.\r\n                            stat = Stats.clone(stat);\r\n                            stat.mode = makeModeWritable(stat.mode);\r\n                        }\r\n                        cb(err, stat);\r\n                    });\r\n                }\r\n                else {\r\n                    cb(err, stat);\r\n                }\r\n            });\r\n        }\r\n        statSync(p, isLstat) {\r\n            this.checkInitialized();\r\n            try {\r\n                return this._writable.statSync(p, isLstat);\r\n            }\r\n            catch (e) {\r\n                if (this._deletedFiles[p]) {\r\n                    throw FileError.ENOENT(p);\r\n                }\r\n                const oldStat = Stats.clone(this._readable.statSync(p, isLstat));\r\n                // Make the oldStat's mode writable. Preserve the topmost part of the\r\n                // mode, which specifies if it is a file or a directory.\r\n                oldStat.mode = makeModeWritable(oldStat.mode);\r\n                return oldStat;\r\n            }\r\n        }\r\n        open(p, flag, mode, cb) {\r\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\r\n                return;\r\n            }\r\n            this.stat(p, false, (err, stats) => {\r\n                if (stats) {\r\n                    switch (flag.pathExistsAction()) {\r\n                        case ActionType.TRUNCATE_FILE:\r\n                            return this.createParentDirectoriesAsync(p, (err) => {\r\n                                if (err) {\r\n                                    return cb(err);\r\n                                }\r\n                                this._writable.open(p, flag, mode, cb);\r\n                            });\r\n                        case ActionType.NOP:\r\n                            return this._writable.exists(p, (exists) => {\r\n                                if (exists) {\r\n                                    this._writable.open(p, flag, mode, cb);\r\n                                }\r\n                                else {\r\n                                    // at this point we know the stats object we got is from\r\n                                    // the readable FS.\r\n                                    stats = Stats.clone(stats);\r\n                                    stats.mode = mode;\r\n                                    this._readable.readFile(p, null, getFlag('r'), (readFileErr, data) => {\r\n                                        if (readFileErr) {\r\n                                            return cb(readFileErr);\r\n                                        }\r\n                                        if (stats.size === -1) {\r\n                                            stats.size = data.length;\r\n                                        }\r\n                                        const f = new OverlayFile(this, p, flag, stats, data);\r\n                                        cb(null, f);\r\n                                    });\r\n                                }\r\n                            });\r\n                        default:\r\n                            return cb(FileError.EEXIST(p));\r\n                    }\r\n                }\r\n                else {\r\n                    switch (flag.pathNotExistsAction()) {\r\n                        case ActionType.CREATE_FILE:\r\n                            return this.createParentDirectoriesAsync(p, (err) => {\r\n                                if (err) {\r\n                                    return cb(err);\r\n                                }\r\n                                return this._writable.open(p, flag, mode, cb);\r\n                            });\r\n                        default:\r\n                            return cb(FileError.ENOENT(p));\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        openSync(p, flag, mode) {\r\n            this.checkInitialized();\r\n            this.checkPath(p);\r\n            if (p === deletionLogPath) {\r\n                throw FileError.EPERM('Cannot open deletion log.');\r\n            }\r\n            if (this.existsSync(p)) {\r\n                switch (flag.pathExistsAction()) {\r\n                    case ActionType.TRUNCATE_FILE:\r\n                        this.createParentDirectories(p);\r\n                        return this._writable.openSync(p, flag, mode);\r\n                    case ActionType.NOP:\r\n                        if (this._writable.existsSync(p)) {\r\n                            return this._writable.openSync(p, flag, mode);\r\n                        }\r\n                        else {\r\n                            // Create an OverlayFile.\r\n                            const buf = this._readable.readFileSync(p, null, getFlag('r'));\r\n                            const stats = Stats.clone(this._readable.statSync(p, false));\r\n                            stats.mode = mode;\r\n                            return new OverlayFile(this, p, flag, stats, buf);\r\n                        }\r\n                    default:\r\n                        throw FileError.EEXIST(p);\r\n                }\r\n            }\r\n            else {\r\n                switch (flag.pathNotExistsAction()) {\r\n                    case ActionType.CREATE_FILE:\r\n                        this.createParentDirectories(p);\r\n                        return this._writable.openSync(p, flag, mode);\r\n                    default:\r\n                        throw FileError.ENOENT(p);\r\n                }\r\n            }\r\n        }\r\n        unlink(p, cb) {\r\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\r\n                return;\r\n            }\r\n            this.exists(p, (exists) => {\r\n                if (!exists) {\r\n                    return cb(FileError.ENOENT(p));\r\n                }\r\n                this._writable.exists(p, (writableExists) => {\r\n                    if (writableExists) {\r\n                        return this._writable.unlink(p, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            this.exists(p, (readableExists) => {\r\n                                if (readableExists) {\r\n                                    this.deletePath(p);\r\n                                }\r\n                                cb(null);\r\n                            });\r\n                        });\r\n                    }\r\n                    else {\r\n                        // if this only exists on the readable FS, add it to the\r\n                        // delete map.\r\n                        this.deletePath(p);\r\n                        cb(null);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        unlinkSync(p) {\r\n            this.checkInitialized();\r\n            this.checkPath(p);\r\n            if (this.existsSync(p)) {\r\n                if (this._writable.existsSync(p)) {\r\n                    this._writable.unlinkSync(p);\r\n                }\r\n                // if it still exists add to the delete log\r\n                if (this.existsSync(p)) {\r\n                    this.deletePath(p);\r\n                }\r\n            }\r\n            else {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n        }\r\n        rmdir(p, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            const rmdirLower = () => {\r\n                this.readdir(p, (err, files) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    if (files.length) {\r\n                        return cb(FileError.ENOTEMPTY(p));\r\n                    }\r\n                    this.deletePath(p);\r\n                    cb(null);\r\n                });\r\n            };\r\n            this.exists(p, (exists) => {\r\n                if (!exists) {\r\n                    return cb(FileError.ENOENT(p));\r\n                }\r\n                this._writable.exists(p, (writableExists) => {\r\n                    if (writableExists) {\r\n                        this._writable.rmdir(p, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            this._readable.exists(p, (readableExists) => {\r\n                                if (readableExists) {\r\n                                    rmdirLower();\r\n                                }\r\n                                else {\r\n                                    cb();\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                    else {\r\n                        rmdirLower();\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        rmdirSync(p) {\r\n            this.checkInitialized();\r\n            if (this.existsSync(p)) {\r\n                if (this._writable.existsSync(p)) {\r\n                    this._writable.rmdirSync(p);\r\n                }\r\n                if (this.existsSync(p)) {\r\n                    // Check if directory is empty.\r\n                    if (this.readdirSync(p).length > 0) {\r\n                        throw FileError.ENOTEMPTY(p);\r\n                    }\r\n                    else {\r\n                        this.deletePath(p);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.exists(p, (exists) => {\r\n                if (exists) {\r\n                    return cb(FileError.EEXIST(p));\r\n                }\r\n                // The below will throw should any of the parent directories\r\n                // fail to exist on _writable.\r\n                this.createParentDirectoriesAsync(p, (err) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    this._writable.mkdir(p, mode, cb);\r\n                });\r\n            });\r\n        }\r\n        mkdirSync(p, mode) {\r\n            this.checkInitialized();\r\n            if (this.existsSync(p)) {\r\n                throw FileError.EEXIST(p);\r\n            }\r\n            else {\r\n                // The below will throw should any of the parent directories fail to exist\r\n                // on _writable.\r\n                this.createParentDirectories(p);\r\n                this._writable.mkdirSync(p, mode);\r\n            }\r\n        }\r\n        readdir(p, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.stat(p, false, (err, dirStats) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                if (!dirStats.isDirectory()) {\r\n                    return cb(FileError.ENOTDIR(p));\r\n                }\r\n                this._writable.readdir(p, (err, wFiles) => {\r\n                    if (err && err.code !== 'ENOENT') {\r\n                        return cb(err);\r\n                    }\r\n                    else if (err || !wFiles) {\r\n                        wFiles = [];\r\n                    }\r\n                    this._readable.readdir(p, (err, rFiles) => {\r\n                        // if the directory doesn't exist on the lower FS set rFiles\r\n                        // here to simplify the following code.\r\n                        if (err || !rFiles) {\r\n                            rFiles = [];\r\n                        }\r\n                        // Readdir in both, check delete log on read-only file system's files, merge, return.\r\n                        const seenMap = {};\r\n                        const filtered = wFiles.concat(rFiles.filter((fPath) => !this._deletedFiles[`${p}/${fPath}`])).filter((fPath) => {\r\n                            // Remove duplicates.\r\n                            const result = !seenMap[fPath];\r\n                            seenMap[fPath] = true;\r\n                            return result;\r\n                        });\r\n                        cb(null, filtered);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        readdirSync(p) {\r\n            this.checkInitialized();\r\n            const dirStats = this.statSync(p, false);\r\n            if (!dirStats.isDirectory()) {\r\n                throw FileError.ENOTDIR(p);\r\n            }\r\n            // Readdir in both, check delete log on RO file system's listing, merge, return.\r\n            let contents = [];\r\n            try {\r\n                contents = contents.concat(this._writable.readdirSync(p));\r\n            }\r\n            catch (e) {\r\n                // NOP.\r\n            }\r\n            try {\r\n                contents = contents.concat(this._readable.readdirSync(p).filter((fPath) => !this._deletedFiles[`${p}/${fPath}`]));\r\n            }\r\n            catch (e) {\r\n                // NOP.\r\n            }\r\n            const seenMap = {};\r\n            return contents.filter((fileP) => {\r\n                const result = !seenMap[fileP];\r\n                seenMap[fileP] = true;\r\n                return result;\r\n            });\r\n        }\r\n        exists(p, cb) {\r\n            // Cannot pass an error back to callback, so throw an exception instead\r\n            // if not initialized.\r\n            this.checkInitialized();\r\n            this._writable.exists(p, (existsWritable) => {\r\n                if (existsWritable) {\r\n                    return cb(true);\r\n                }\r\n                this._readable.exists(p, (existsReadable) => {\r\n                    cb(existsReadable && this._deletedFiles[p] !== true);\r\n                });\r\n            });\r\n        }\r\n        existsSync(p) {\r\n            this.checkInitialized();\r\n            return this._writable.existsSync(p) || (this._readable.existsSync(p) && this._deletedFiles[p] !== true);\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.operateOnWritableAsync(p, (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                else {\r\n                    this._writable.chmod(p, isLchmod, mode, cb);\r\n                }\r\n            });\r\n        }\r\n        chmodSync(p, isLchmod, mode) {\r\n            this.checkInitialized();\r\n            this.operateOnWritable(p, () => {\r\n                this._writable.chmodSync(p, isLchmod, mode);\r\n            });\r\n        }\r\n        chown(p, isLchmod, uid, gid, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.operateOnWritableAsync(p, (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                else {\r\n                    this._writable.chown(p, isLchmod, uid, gid, cb);\r\n                }\r\n            });\r\n        }\r\n        chownSync(p, isLchown, uid, gid) {\r\n            this.checkInitialized();\r\n            this.operateOnWritable(p, () => {\r\n                this._writable.chownSync(p, isLchown, uid, gid);\r\n            });\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.operateOnWritableAsync(p, (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                else {\r\n                    this._writable.utimes(p, atime, mtime, cb);\r\n                }\r\n            });\r\n        }\r\n        utimesSync(p, atime, mtime) {\r\n            this.checkInitialized();\r\n            this.operateOnWritable(p, () => {\r\n                this._writable.utimesSync(p, atime, mtime);\r\n            });\r\n        }\r\n        deletePath(p) {\r\n            this._deletedFiles[p] = true;\r\n            this.updateLog(`d${p}\\n`);\r\n        }\r\n        updateLog(addition) {\r\n            this._deleteLog += addition;\r\n            if (this._deleteLogUpdatePending) {\r\n                this._deleteLogUpdateNeeded = true;\r\n            }\r\n            else {\r\n                this._deleteLogUpdatePending = true;\r\n                this._writable.writeFile(deletionLogPath, this._deleteLog, 'utf8', FileFlag.getFileFlag('w'), 0o644, (e) => {\r\n                    this._deleteLogUpdatePending = false;\r\n                    if (e) {\r\n                        this._deleteLogError = e;\r\n                    }\r\n                    else if (this._deleteLogUpdateNeeded) {\r\n                        this._deleteLogUpdateNeeded = false;\r\n                        this.updateLog('');\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        _reparseDeletionLog() {\r\n            this._deletedFiles = {};\r\n            this._deleteLog.split('\\n').forEach((path) => {\r\n                // If the log entry begins w/ 'd', it's a deletion.\r\n                this._deletedFiles[path.slice(1)] = path.slice(0, 1) === 'd';\r\n            });\r\n        }\r\n        checkInitialized() {\r\n            if (!this._isInitialized) {\r\n                throw new FileError(ErrorCodes.EPERM, \"OverlayProvideris not initialized. Please initialize OverlayProviderusing its initialize() method before using it.\");\r\n            }\r\n            else if (this._deleteLogError !== null) {\r\n                const e = this._deleteLogError;\r\n                this._deleteLogError = null;\r\n                throw e;\r\n            }\r\n        }\r\n        checkInitAsync(cb) {\r\n            if (!this._isInitialized) {\r\n                cb(new FileError(ErrorCodes.EPERM, \"OverlayProvideris not initialized. Please initialize OverlayProviderusing its initialize() method before using it.\"));\r\n                return false;\r\n            }\r\n            else if (this._deleteLogError !== null) {\r\n                const e = this._deleteLogError;\r\n                this._deleteLogError = null;\r\n                cb(e);\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        checkPath(p) {\r\n            if (p === deletionLogPath) {\r\n                throw FileError.EPERM(p);\r\n            }\r\n        }\r\n        checkPathAsync(p, cb) {\r\n            if (p === deletionLogPath) {\r\n                cb(FileError.EPERM(p));\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        createParentDirectoriesAsync(p, cb) {\r\n            let parent = paths.dirname(p);\r\n            const toCreate = [];\r\n            const self = this;\r\n            this._writable.stat(parent, false, statDone);\r\n            function statDone(err, stat) {\r\n                if (err) {\r\n                    if (parent === \"/\") {\r\n                        cb(new FileError(ErrorCodes.EBUSY, \"Invariant failed: root does not exist!\"));\r\n                    }\r\n                    else {\r\n                        toCreate.push(parent);\r\n                        parent = paths.dirname(parent);\r\n                        self._writable.stat(parent, false, statDone);\r\n                    }\r\n                }\r\n                else {\r\n                    createParents();\r\n                }\r\n            }\r\n            function createParents() {\r\n                if (!toCreate.length) {\r\n                    return cb();\r\n                }\r\n                const dir = toCreate.pop();\r\n                self._readable.stat(dir, false, (err, stats) => {\r\n                    // stop if we couldn't read the dir\r\n                    if (!stats) {\r\n                        return cb();\r\n                    }\r\n                    self._writable.mkdir(dir, stats.mode, (err) => {\r\n                        if (err) {\r\n                            return cb(err);\r\n                        }\r\n                        createParents();\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        /**\r\n         * With the given path, create the needed parent directories on the writable storage\r\n         * should they not exist. Use modes from the read-only storage.\r\n         */\r\n        createParentDirectories(p) {\r\n            let parent = paths.dirname(p), toCreate = [];\r\n            while (!this._writable.existsSync(parent)) {\r\n                toCreate.push(parent);\r\n                parent = paths.dirname(parent);\r\n            }\r\n            toCreate = toCreate.reverse();\r\n            toCreate.forEach((p) => {\r\n                this._writable.mkdirSync(p, this.statSync(p, false).mode);\r\n            });\r\n        }\r\n        /**\r\n         * Helper function:\r\n         * - Ensures p is on writable before proceeding. Throws an error if it doesn't exist.\r\n         * - Calls f to perform operation on writable.\r\n         */\r\n        operateOnWritable(p, f) {\r\n            if (this.existsSync(p)) {\r\n                if (!this._writable.existsSync(p)) {\r\n                    // File is on readable storage. Copy to writable storage before\r\n                    // changing its mode.\r\n                    this.copyToWritable(p);\r\n                }\r\n                f();\r\n            }\r\n            else {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n        }\r\n        operateOnWritableAsync(p, cb) {\r\n            this.exists(p, (exists) => {\r\n                if (!exists) {\r\n                    return cb(FileError.ENOENT(p));\r\n                }\r\n                this._writable.exists(p, (existsWritable) => {\r\n                    if (existsWritable) {\r\n                        cb();\r\n                    }\r\n                    else {\r\n                        return this.copyToWritableAsync(p, cb);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        /**\r\n         * Copy from readable to writable storage.\r\n         * PRECONDITION: File does not exist on writable storage.\r\n         */\r\n        copyToWritable(p) {\r\n            const pStats = this.statSync(p, false);\r\n            if (pStats.isDirectory()) {\r\n                this._writable.mkdirSync(p, pStats.mode);\r\n            }\r\n            else {\r\n                this.writeFileSync(p, this._readable.readFileSync(p, null, getFlag('r')), null, getFlag('w'), this.statSync(p, false).mode);\r\n            }\r\n        }\r\n        copyToWritableAsync(p, cb) {\r\n            this.stat(p, false, (err, pStats) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                if (pStats.isDirectory()) {\r\n                    return this._writable.mkdir(p, pStats.mode, cb);\r\n                }\r\n                // need to copy file.\r\n                this._readable.readFile(p, null, getFlag('r'), (err, data) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    this.writeFile(p, data, null, getFlag('w'), pStats.mode, cb);\r\n                });\r\n            });\r\n        }\r\n    }\r\n \r\n\r\n    return UnlockedOverlayProvider;\r\n});\ndefine('skylark-io-files/providers/overlay/overlay-provider',[\r\n    \"skylark-langx-paths\",\r\n    \"../../files\",\r\n    \"../registry\",\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    \"../../file-flag\",\r\n    \"../../action-type\",\r\n    \"../locked-provider\",\r\n    \"./unlocked-overlay-provider\"\r\n], function (paths,files,registry, Stats,FileType,FileError, ErrorCodes, FileFlag,ActionType,LockedProvider,UnlockedOverlayProvider) {\r\n\r\n\r\n    /**\r\n     * OverlayProvidermakes a read-only filesystem writable by storing writes on a second,\r\n     * writable file system. Deletes are persisted via metadata stored on the writable\r\n     * file system.\r\n     */\r\n    class OverlayProvider extends LockedProvider {\r\n        /**\r\n         * @param writable The file system to write modified files to.\r\n         * @param readable The file system that initially populates this file system.\r\n         */\r\n        constructor(writable, readable) {\r\n            super(new UnlockedOverlayProvider(writable, readable));\r\n        }\r\n        /**\r\n         * Constructs and initializes an OverlayProviderinstance with the given options.\r\n         */\r\n        static Create(opts, cb) {\r\n            try {\r\n                const fs = new OverlayProvider(opts.writable, opts.readable);\r\n                fs._initialize((e) => {\r\n                    cb(e, fs);\r\n                });\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        static isAvailable() {\r\n            return UnlockedOverlayProvider.isAvailable();\r\n        }\r\n        getOverlayedProviders() {\r\n            return super.getFSUnlocked().getOverlayedProviders();\r\n        }\r\n        unwrap() {\r\n            return super.getFSUnlocked();\r\n        }\r\n        _initialize(cb) {\r\n            super.getFSUnlocked()._initialize(cb);\r\n        }\r\n    }\r\n    OverlayProvider.Name = \"OverlayProvider\";\r\n    OverlayProvider.Options = {\r\n        writable: {\r\n            type: \"object\",\r\n            description: \"The file system to write modified files to.\"\r\n        },\r\n        readable: {\r\n            type: \"object\",\r\n            description: \"The file system that initially populates this file system.\"\r\n        }\r\n    };\r\n\r\n    registry.add(\"overlay\",OverlayProvider);\r\n\r\n\r\n    return files.providers.OverlayProvider = OverlayProvider;\r\n});\ndefine('skylark-io-files/main',[\r\n\t\"./files\",\r\n\t\"./action-type\",\r\n\t\"./base-file\",\r\n\t\"./error-codes\",\r\n\t\"./error-strings\",\r\n\t\"./file-error\",\r\n\t\"./file-flag\",\r\n\t\"./file-system\",\r\n\t\"./no-sync-file\",\r\n\t\"./preload-file\",\r\n\t\"./stats\",\r\n\t\"./configure\",\r\n\t\"./providers/dropbox/dropbox-provider\",\r\n\t\"./providers/html5/html5-lfs-provider\",\r\n\t\"./providers/http/http-provider\",\r\n\t\"./providers/indexeddb/indexed-db-provider\",\r\n\t\"./providers/inmemory/in-memory-provider\",\r\n\t\"./providers/localstorage/local-storage-provider\",\r\n\t\"./providers/overlay/overlay-provider\"\r\n\r\n],function(files){\r\n\treturn files;\r\n});\ndefine('skylark-io-files', ['skylark-io-files/main'], function (main) { return main; });\n\n"]}