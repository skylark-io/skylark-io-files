{"version":3,"sources":["file-system.js"],"names":["define","setImmediate","Buffer","paths","files","ErrorCodes","FileError","FileFlag","Stats","let","wrapCbHook","cb","numArgs","wrapCb","Error","hookedCb","arg1","arg2","arg3","assertRoot","fs","EIO","normalizeMode","mode","def","trueMode","parseInt","isNaN","normalizeTime","time","Date","EINVAL","normalizePath","p","indexOf","resolve","normalizeOptions","options","defEnc","defFlag","defMode","encoding","flag","TypeError","nopCb","FileSystem","constructor","this","F_OK","R_OK","W_OK","X_OK","root","fdMap","nextFd","initialize","rootFS","isAvailable","_toUnixTimestamp","getTime","getRootFS","rename","oldPath","newPath","newCb","e","renameSync","exists","path","existsSync","stat","statSync","lstat","lstatSync","truncate","len","truncateSync","unlink","unlinkSync","open","getFileFlag","file","getFdForFile","openSync","readFile","filename","isReadable","readFileSync","writeFile","data","isWriteable","writeFileSync","appendFile","isAppendable","appendFileSync","fstat","fd","fd2file","fstatSync","close","closeFd","closeSync","ftruncate","length","ftruncateSync","fsync","sync","fsyncSync","syncSync","fdatasync","datasync","fdatasyncSync","datasyncSync","write","arg4","arg5","buffer","offset","position","from","undefined","getPos","writeSync","read","alloc","err","bytesRead","buf","toString","readSync","shenanigans","rv","fchown","uid","gid","callback","chown","fchownSync","chownSync","fchmod","numMode","chmod","fchmodSync","chmodSync","futimes","atime","mtime","utimes","futimesSync","utimesSync","rmdir","rmdirSync","mkdir","mkdirSync","readdir","readdirSync","link","srcpath","dstpath","linkSync","symlink","type","symlinkSync","readlink","readlinkSync","lchown","lchownSync","lchmod","lchmodSync","realpath","cache","realpathSync","watchFile","listener","ENOTSUP","unwatchFile","watch","access","accessSync","createReadStream","createWriteStream","wrapCallbacks","cbWrapper","EBADF"],"mappings":"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","file":"../file-system.js","sourcesContent":["define([\r\n    \"skylark-langx-funcs/defer\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"./files\",\r\n    './error-codes',\r\n    \"./file-error\",\r\n    './file-flag',\r\n    './stats'\r\n], function (setImmediate,Buffer, paths, files,ErrorCodes,FileError, FileFlag,  Stats) {\r\n    'use strict';\r\n\r\n\r\n    /** Used for unit testing. Defaults to a NOP. */\r\n    let wrapCbHook = function (cb, numArgs) {\r\n        return cb;\r\n    };\r\n    /**\r\n     * Wraps a callback function, ensuring it is invoked through setImmediate.\r\n     * @hidden\r\n     */\r\n    function wrapCb(cb, numArgs) {\r\n        if (typeof cb !== 'function') {\r\n            throw new Error('Callback must be a function.');\r\n        }\r\n        const hookedCb = wrapCbHook(cb, numArgs);\r\n        // We could use `arguments`, but Function.call/apply is expensive. And we only\r\n        // need to handle 1-3 arguments\r\n        switch (numArgs) {\r\n            case 1:\r\n                return function (arg1) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1);\r\n                    });\r\n                };\r\n            case 2:\r\n                return function (arg1, arg2) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1, arg2);\r\n                    });\r\n                };\r\n            case 3:\r\n                return function (arg1, arg2, arg3) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1, arg2, arg3);\r\n                    });\r\n                };\r\n            default:\r\n                throw new Error('Invalid invocation of wrapCb.');\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function assertRoot(fs) {\r\n        if (fs) {\r\n            return fs;\r\n        }\r\n        throw new FileError(ErrorCodes.EIO, `Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)`);\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeMode(mode, def) {\r\n        switch (typeof mode) {\r\n            case 'number':\r\n                // (path, flag, mode, cb?)\r\n                return mode;\r\n            case 'string':\r\n                // (path, flag, modeString, cb?)\r\n                const trueMode = parseInt(mode, 8);\r\n                if (!isNaN(trueMode)) {\r\n                    return trueMode;\r\n                }\r\n                // Invalid string.\r\n                return def;\r\n            default:\r\n                return def;\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeTime(time) {\r\n        if (time instanceof Date) {\r\n            return time;\r\n        }\r\n        else if (typeof time === 'number') {\r\n            return new Date(time * 1000);\r\n        }\r\n        else {\r\n            throw new FileError(ErrorCodes.EINVAL, `Invalid time.`);\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizePath(p) {\r\n        // Node doesn't allow null characters in paths.\r\n        if (p.indexOf('\\u0000') >= 0) {\r\n            throw new FileError(ErrorCodes.EINVAL, 'Path must be a string without null bytes.');\r\n        }\r\n        else if (p === '') {\r\n            throw new FileError(ErrorCodes.EINVAL, 'Path must not be empty.');\r\n        }\r\n        return paths.resolve(p);\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeOptions(options, defEnc, defFlag, defMode) {\r\n        // typeof null === 'object' so special-case handing is needed.\r\n        switch (options === null ? 'null' : typeof options) {\r\n            case 'object':\r\n                return {\r\n                    encoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,\r\n                    flag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,\r\n                    mode: normalizeMode(options['mode'], defMode)\r\n                };\r\n            case 'string':\r\n                return {\r\n                    encoding: options,\r\n                    flag: defFlag,\r\n                    mode: defMode\r\n                };\r\n            case 'null':\r\n            case 'undefined':\r\n            case 'function':\r\n                return {\r\n                    encoding: defEnc,\r\n                    flag: defFlag,\r\n                    mode: defMode\r\n                };\r\n            default:\r\n                throw new TypeError(`\"options\" must be a string or an object, got ${typeof options} instead.`);\r\n        }\r\n    }\r\n    /**\r\n     * The default callback is a NOP.\r\n     * @hidden\r\n     * @private\r\n     */\r\n    function nopCb() {\r\n        // NOP.\r\n    }\r\n    /**\r\n     * The node frontend to all filesystems.\r\n     * This layer handles:\r\n     *\r\n     * * Sanity checking inputs.\r\n     * * Normalizing paths.\r\n     * * Resetting stack depth for asynchronous operations which may not go through\r\n     *   the browser by wrapping all input callbacks using `setImmediate`.\r\n     * * Performing the requested operation through the filesystem or the file\r\n     *   descriptor, as appropriate.\r\n     * * Handling optional arguments and setting default arguments.\r\n     * @see http://nodejs.org/api/fs.html\r\n     */\r\n    class FileSystem {\r\n        constructor() {\r\n            /* tslint:enable:variable-name */\r\n            this.F_OK = 0;\r\n            this.R_OK = 4;\r\n            this.W_OK = 2;\r\n            this.X_OK = 1;\r\n            this.root = null;\r\n            this.fdMap = {};\r\n            this.nextFd = 100;\r\n        }\r\n        initialize(rootFS) {\r\n            if (!rootFS.constructor.isAvailable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Tried to instantiate BrowserFS with an unavailable file system.');\r\n            }\r\n            return this.root = rootFS;\r\n        }\r\n        /**\r\n         * converts Date or number to a fractional UNIX timestamp\r\n         * Grabbed from NodeJS sources (lib/fs.js)\r\n         */\r\n        _toUnixTimestamp(time) {\r\n            if (typeof time === 'number') {\r\n                return time;\r\n            }\r\n            else if (time instanceof Date) {\r\n                return time.getTime() / 1000;\r\n            }\r\n            throw new Error(\"Cannot parse time: \" + time);\r\n        }\r\n        /**\r\n         * **NONSTANDARD**: Grab the FileSystem instance that backs this API.\r\n         * @return [BrowserFS.FileSystem | null] Returns null if the file system has\r\n         *   not been initialized.\r\n         */\r\n        getRootFS() {\r\n            if (this.root) {\r\n                return this.root;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        // FILE OR DIRECTORY METHODS\r\n        /**\r\n         * Asynchronous rename. No arguments other than a possible exception are given\r\n         * to the completion callback.\r\n         * @param oldPath\r\n         * @param newPath\r\n         * @param callback\r\n         */\r\n        rename(oldPath, newPath, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                assertRoot(this.root).rename(normalizePath(oldPath), normalizePath(newPath), newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous rename.\r\n         * @param oldPath\r\n         * @param newPath\r\n         */\r\n        renameSync(oldPath, newPath) {\r\n            assertRoot(this.root).renameSync(normalizePath(oldPath), normalizePath(newPath));\r\n        }\r\n        /**\r\n         * Test whether or not the given path exists by checking with the file system.\r\n         * Then call the callback argument with either true or false.\r\n         * @example Sample invocation\r\n         *   fs.exists('/etc/passwd', function (exists) {\r\n         *     util.debug(exists ? \"it's there\" : \"no passwd!\");\r\n         *   });\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        exists(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                return assertRoot(this.root).exists(normalizePath(path), newCb);\r\n            }\r\n            catch (e) {\r\n                // Doesn't return an error. If something bad happens, we assume it just\r\n                // doesn't exist.\r\n                return newCb(false);\r\n            }\r\n        }\r\n        /**\r\n         * Test whether or not the given path exists by checking with the file system.\r\n         * @param path\r\n         * @return [boolean]\r\n         */\r\n        existsSync(path) {\r\n            try {\r\n                return assertRoot(this.root).existsSync(normalizePath(path));\r\n            }\r\n            catch (e) {\r\n                // Doesn't return an error. If something bad happens, we assume it just\r\n                // doesn't exist.\r\n                return false;\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `stat`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        stat(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                return assertRoot(this.root).stat(normalizePath(path), false, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `stat`.\r\n         * @param path\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        statSync(path) {\r\n            return assertRoot(this.root).statSync(normalizePath(path), false);\r\n        }\r\n        /**\r\n         * Asynchronous `lstat`.\r\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\r\n         * then the link itself is stat-ed, not the file that it refers to.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        lstat(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                return assertRoot(this.root).stat(normalizePath(path), true, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lstat`.\r\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\r\n         * then the link itself is stat-ed, not the file that it refers to.\r\n         * @param path\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        lstatSync(path) {\r\n            return assertRoot(this.root).statSync(normalizePath(path), true);\r\n        }\r\n        truncate(path, arg2 = 0, cb = nopCb) {\r\n            let len = 0;\r\n            if (typeof arg2 === 'function') {\r\n                cb = arg2;\r\n            }\r\n            else if (typeof arg2 === 'number') {\r\n                len = arg2;\r\n            }\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                if (len < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL);\r\n                }\r\n                return assertRoot(this.root).truncate(normalizePath(path), len, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `truncate`.\r\n         * @param path\r\n         * @param len\r\n         */\r\n        truncateSync(path, len = 0) {\r\n            if (len < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL);\r\n            }\r\n            return assertRoot(this.root).truncateSync(normalizePath(path), len);\r\n        }\r\n        /**\r\n         * Asynchronous `unlink`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        unlink(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                return assertRoot(this.root).unlink(normalizePath(path), newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `unlink`.\r\n         * @param path\r\n         */\r\n        unlinkSync(path) {\r\n            return assertRoot(this.root).unlinkSync(normalizePath(path));\r\n        }\r\n        open(path, flag, arg2, cb = nopCb) {\r\n            const mode = normalizeMode(arg2, 0x1a4);\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                assertRoot(this.root).open(normalizePath(path), FileFlag.getFileFlag(flag), mode, (e, file) => {\r\n                    if (file) {\r\n                        newCb(e, this.getFdForFile(file));\r\n                    }\r\n                    else {\r\n                        newCb(e);\r\n                    }\r\n                });\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous file open.\r\n         * @see http://www.manpagez.com/man/2/open/\r\n         * @param path\r\n         * @param flags\r\n         * @param mode defaults to `0644`\r\n         * @return [BrowserFS.File]\r\n         */\r\n        openSync(path, flag, mode = 0x1a4) {\r\n            return this.getFdForFile(assertRoot(this.root).openSync(normalizePath(path), FileFlag.getFileFlag(flag), normalizeMode(mode, 0x1a4)));\r\n        }\r\n        readFile(filename, arg2 = {}, cb = nopCb) {\r\n            const options = normalizeOptions(arg2, null, 'r', null);\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options['flag']);\r\n                if (!flag.isReadable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to readFile must allow for reading.'));\r\n                }\r\n                return assertRoot(this.root).readFile(normalizePath(filename), options.encoding, flag, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        readFileSync(filename, arg2 = {}) {\r\n            const options = normalizeOptions(arg2, null, 'r', null);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isReadable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to readFile must allow for reading.');\r\n            }\r\n            return assertRoot(this.root).readFileSync(normalizePath(filename), options.encoding, flag);\r\n        }\r\n        writeFile(filename, data, arg3 = {}, cb = nopCb) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options.flag);\r\n                if (!flag.isWriteable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to writeFile must allow for writing.'));\r\n                }\r\n                return assertRoot(this.root).writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        writeFileSync(filename, data, arg3) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to writeFile must allow for writing.');\r\n            }\r\n            return assertRoot(this.root).writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\r\n        }\r\n        appendFile(filename, data, arg3, cb = nopCb) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options.flag);\r\n                if (!flag.isAppendable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to appendFile must allow for appending.'));\r\n                }\r\n                assertRoot(this.root).appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        appendFileSync(filename, data, arg3) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isAppendable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to appendFile must allow for appending.');\r\n            }\r\n            return assertRoot(this.root).appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\r\n        }\r\n        // FILE DESCRIPTOR METHODS\r\n        /**\r\n         * Asynchronous `fstat`.\r\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\n         * specified by the file descriptor `fd`.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fstat(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                file.stat(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fstat`.\r\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\n         * specified by the file descriptor `fd`.\r\n         * @param fd\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        fstatSync(fd) {\r\n            return this.fd2file(fd).statSync();\r\n        }\r\n        /**\r\n         * Asynchronous close.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        close(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).close((e) => {\r\n                    if (!e) {\r\n                        this.closeFd(fd);\r\n                    }\r\n                    newCb(e);\r\n                });\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous close.\r\n         * @param fd\r\n         */\r\n        closeSync(fd) {\r\n            this.fd2file(fd).closeSync();\r\n            this.closeFd(fd);\r\n        }\r\n        ftruncate(fd, arg2, cb = nopCb) {\r\n            const length = typeof arg2 === 'number' ? arg2 : 0;\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (length < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL);\r\n                }\r\n                file.truncate(length, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous ftruncate.\r\n         * @param fd\r\n         * @param len\r\n         */\r\n        ftruncateSync(fd, len = 0) {\r\n            const file = this.fd2file(fd);\r\n            if (len < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL);\r\n            }\r\n            file.truncateSync(len);\r\n        }\r\n        /**\r\n         * Asynchronous fsync.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fsync(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).sync(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous fsync.\r\n         * @param fd\r\n         */\r\n        fsyncSync(fd) {\r\n            this.fd2file(fd).syncSync();\r\n        }\r\n        /**\r\n         * Asynchronous fdatasync.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fdatasync(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).datasync(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous fdatasync.\r\n         * @param fd\r\n         */\r\n        fdatasyncSync(fd) {\r\n            this.fd2file(fd).datasyncSync();\r\n        }\r\n        write(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\r\n            let buffer, offset, length, position = null;\r\n            if (typeof arg2 === 'string') {\r\n                // Signature 1: (fd, string, [position?, [encoding?]], cb?)\r\n                let encoding = 'utf8';\r\n                switch (typeof arg3) {\r\n                    case 'function':\r\n                        // (fd, string, cb)\r\n                        cb = arg3;\r\n                        break;\r\n                    case 'number':\r\n                        // (fd, string, position, encoding?, cb?)\r\n                        position = arg3;\r\n                        encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\r\n                        cb = typeof arg5 === 'function' ? arg5 : cb;\r\n                        break;\r\n                    default:\r\n                        // ...try to find the callback and get out of here!\r\n                        cb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, 'Invalid arguments.'));\r\n                }\r\n                buffer = Buffer.from(arg2, encoding);\r\n                offset = 0;\r\n                length = buffer.length;\r\n            }\r\n            else {\r\n                // Signature 2: (fd, buffer, offset, length, position?, cb?)\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = typeof arg5 === 'number' ? arg5 : null;\r\n                cb = typeof arg5 === 'function' ? arg5 : cb;\r\n            }\r\n            const newCb = wrapCb(cb, 3);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (position === undefined || position === null) {\r\n                    position = file.getPos();\r\n                }\r\n                file.write(buffer, offset, length, position, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        writeSync(fd, arg2, arg3, arg4, arg5) {\r\n            let buffer, offset = 0, length, position;\r\n            if (typeof arg2 === 'string') {\r\n                // Signature 1: (fd, string, [position?, [encoding?]])\r\n                position = typeof arg3 === 'number' ? arg3 : null;\r\n                const encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\r\n                offset = 0;\r\n                buffer = Buffer.from(arg2, encoding);\r\n                length = buffer.length;\r\n            }\r\n            else {\r\n                // Signature 2: (fd, buffer, offset, length, position?)\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = typeof arg5 === 'number' ? arg5 : null;\r\n            }\r\n            const file = this.fd2file(fd);\r\n            if (position === undefined || position === null) {\r\n                position = file.getPos();\r\n            }\r\n            return file.writeSync(buffer, offset, length, position);\r\n        }\r\n        read(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\r\n            let position, offset, length, buffer, newCb;\r\n            if (typeof arg2 === 'number') {\r\n                // legacy interface\r\n                // (fd, length, position, encoding, callback)\r\n                length = arg2;\r\n                position = arg3;\r\n                const encoding = arg4;\r\n                cb = typeof arg5 === 'function' ? arg5 : cb;\r\n                offset = 0;\r\n                buffer = Buffer.alloc(length);\r\n                // XXX: Inefficient.\r\n                // Wrap the cb so we shelter upper layers of the API from these\r\n                // shenanigans.\r\n                newCb = wrapCb((err, bytesRead, buf) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    cb(err, buf.toString(encoding), bytesRead);\r\n                }, 3);\r\n            }\r\n            else {\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = arg5;\r\n                newCb = wrapCb(cb, 3);\r\n            }\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (position === undefined || position === null) {\r\n                    position = file.getPos();\r\n                }\r\n                file.read(buffer, offset, length, position, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        readSync(fd, arg2, arg3, arg4, arg5) {\r\n            let shenanigans = false;\r\n            let buffer, offset, length, position, encoding = 'utf8';\r\n            if (typeof arg2 === 'number') {\r\n                length = arg2;\r\n                position = arg3;\r\n                encoding = arg4;\r\n                offset = 0;\r\n                buffer = Buffer.alloc(length);\r\n                shenanigans = true;\r\n            }\r\n            else {\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = arg5;\r\n            }\r\n            const file = this.fd2file(fd);\r\n            if (position === undefined || position === null) {\r\n                position = file.getPos();\r\n            }\r\n            const rv = file.readSync(buffer, offset, length, position);\r\n            if (!shenanigans) {\r\n                return rv;\r\n            }\r\n            else {\r\n                return [buffer.toString(encoding), rv];\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `fchown`.\r\n         * @param fd\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        fchown(fd, uid, gid, callback = nopCb) {\r\n            const newCb = wrapCb(callback, 1);\r\n            try {\r\n                this.fd2file(fd).chown(uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fchown`.\r\n         * @param fd\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        fchownSync(fd, uid, gid) {\r\n            this.fd2file(fd).chownSync(uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param fd\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        fchmod(fd, mode, cb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\r\n                this.fd2file(fd).chmod(numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fchmod`.\r\n         * @param fd\r\n         * @param mode\r\n         */\r\n        fchmodSync(fd, mode) {\r\n            const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\r\n            this.fd2file(fd).chmodSync(numMode);\r\n        }\r\n        /**\r\n         * Change the file timestamps of a file referenced by the supplied file\r\n         * descriptor.\r\n         * @param fd\r\n         * @param atime\r\n         * @param mtime\r\n         * @param callback\r\n         */\r\n        futimes(fd, atime, mtime, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (typeof atime === 'number') {\r\n                    atime = new Date(atime * 1000);\r\n                }\r\n                if (typeof mtime === 'number') {\r\n                    mtime = new Date(mtime * 1000);\r\n                }\r\n                file.utimes(atime, mtime, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Change the file timestamps of a file referenced by the supplied file\r\n         * descriptor.\r\n         * @param fd\r\n         * @param atime\r\n         * @param mtime\r\n         */\r\n        futimesSync(fd, atime, mtime) {\r\n            this.fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));\r\n        }\r\n        // DIRECTORY-ONLY METHODS\r\n        /**\r\n         * Asynchronous `rmdir`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        rmdir(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).rmdir(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `rmdir`.\r\n         * @param path\r\n         */\r\n        rmdirSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).rmdirSync(path);\r\n        }\r\n        /**\r\n         * Asynchronous `mkdir`.\r\n         * @param path\r\n         * @param mode defaults to `0777`\r\n         * @param callback\r\n         */\r\n        mkdir(path, mode, cb = nopCb) {\r\n            if (typeof mode === 'function') {\r\n                cb = mode;\r\n                mode = 0x1ff;\r\n            }\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).mkdir(path, mode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `mkdir`.\r\n         * @param path\r\n         * @param mode defaults to `0777`\r\n         */\r\n        mkdirSync(path, mode) {\r\n            assertRoot(this.root).mkdirSync(normalizePath(path), normalizeMode(mode, 0x1ff));\r\n        }\r\n        /**\r\n         * Asynchronous `readdir`. Reads the contents of a directory.\r\n         * The callback gets two arguments `(err, files)` where `files` is an array of\r\n         * the names of the files in the directory excluding `'.'` and `'..'`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        readdir(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).readdir(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `readdir`. Reads the contents of a directory.\r\n         * @param path\r\n         * @return [String[]]\r\n         */\r\n        readdirSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).readdirSync(path);\r\n        }\r\n        // SYMLINK METHODS\r\n        /**\r\n         * Asynchronous `link`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         * @param callback\r\n         */\r\n        link(srcpath, dstpath, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                srcpath = normalizePath(srcpath);\r\n                dstpath = normalizePath(dstpath);\r\n                assertRoot(this.root).link(srcpath, dstpath, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `link`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         */\r\n        linkSync(srcpath, dstpath) {\r\n            srcpath = normalizePath(srcpath);\r\n            dstpath = normalizePath(dstpath);\r\n            return assertRoot(this.root).linkSync(srcpath, dstpath);\r\n        }\r\n        symlink(srcpath, dstpath, arg3, cb = nopCb) {\r\n            const type = typeof arg3 === 'string' ? arg3 : 'file';\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                if (type !== 'file' && type !== 'dir') {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, \"Invalid type: \" + type));\r\n                }\r\n                srcpath = normalizePath(srcpath);\r\n                dstpath = normalizePath(dstpath);\r\n                assertRoot(this.root).symlink(srcpath, dstpath, type, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `symlink`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         * @param type can be either `'dir'` or `'file'` (default is `'file'`)\r\n         */\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            if (!type) {\r\n                type = 'file';\r\n            }\r\n            else if (type !== 'file' && type !== 'dir') {\r\n                throw new FileError(ErrorCodes.EINVAL, \"Invalid type: \" + type);\r\n            }\r\n            srcpath = normalizePath(srcpath);\r\n            dstpath = normalizePath(dstpath);\r\n            return assertRoot(this.root).symlinkSync(srcpath, dstpath, type);\r\n        }\r\n        /**\r\n         * Asynchronous readlink.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        readlink(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).readlink(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous readlink.\r\n         * @param path\r\n         * @return [String]\r\n         */\r\n        readlinkSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).readlinkSync(path);\r\n        }\r\n        // PROPERTY OPERATIONS\r\n        /**\r\n         * Asynchronous `chown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        chown(path, uid, gid, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).chown(path, false, uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `chown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        chownSync(path, uid, gid) {\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chownSync(path, false, uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `lchown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        lchown(path, uid, gid, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).chown(path, true, uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lchown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        lchownSync(path, uid, gid) {\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chownSync(path, true, uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `chmod`.\r\n         * @param path\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        chmod(path, mode, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = normalizeMode(mode, -1);\r\n                if (numMode < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n                }\r\n                assertRoot(this.root).chmod(normalizePath(path), false, numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `chmod`.\r\n         * @param path\r\n         * @param mode\r\n         */\r\n        chmodSync(path, mode) {\r\n            const numMode = normalizeMode(mode, -1);\r\n            if (numMode < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n            }\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chmodSync(path, false, numMode);\r\n        }\r\n        /**\r\n         * Asynchronous `lchmod`.\r\n         * @param path\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        lchmod(path, mode, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = normalizeMode(mode, -1);\r\n                if (numMode < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n                }\r\n                assertRoot(this.root).chmod(normalizePath(path), true, numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lchmod`.\r\n         * @param path\r\n         * @param mode\r\n         */\r\n        lchmodSync(path, mode) {\r\n            const numMode = normalizeMode(mode, -1);\r\n            if (numMode < 1) {\r\n                throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n            }\r\n            assertRoot(this.root).chmodSync(normalizePath(path), true, numMode);\r\n        }\r\n        /**\r\n         * Change file timestamps of the file referenced by the supplied path.\r\n         * @param path\r\n         * @param atime\r\n         * @param mtime\r\n         * @param callback\r\n         */\r\n        utimes(path, atime, mtime, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                assertRoot(this.root).utimes(normalizePath(path), normalizeTime(atime), normalizeTime(mtime), newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Change file timestamps of the file referenced by the supplied path.\r\n         * @param path\r\n         * @param atime\r\n         * @param mtime\r\n         */\r\n        utimesSync(path, atime, mtime) {\r\n            assertRoot(this.root).utimesSync(normalizePath(path), normalizeTime(atime), normalizeTime(mtime));\r\n        }\r\n        realpath(path, arg2, cb = nopCb) {\r\n            const cache = typeof (arg2) === 'object' ? arg2 : {};\r\n            cb = typeof (arg2) === 'function' ? arg2 : nopCb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).realpath(path, cache, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `realpath`.\r\n         * @param path\r\n         * @param cache An object literal of mapped paths that can be used to\r\n         *   force a specific path resolution or avoid additional `fs.stat` calls for\r\n         *   known real paths.\r\n         * @return [String]\r\n         */\r\n        realpathSync(path, cache = {}) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).realpathSync(path, cache);\r\n        }\r\n        watchFile(filename, arg2, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        unwatchFile(filename, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        watch(filename, arg2, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        access(path, arg2, cb = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        accessSync(path, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        createReadStream(path, options) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        createWriteStream(path, options) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * For unit testing. Passes all incoming callbacks to cbWrapper for wrapping.\r\n         */\r\n        wrapCallbacks(cbWrapper) {\r\n            wrapCbHook = cbWrapper;\r\n        }\r\n        getFdForFile(file) {\r\n            const fd = this.nextFd++;\r\n            this.fdMap[fd] = file;\r\n            return fd;\r\n        }\r\n        fd2file(fd) {\r\n            const rv = this.fdMap[fd];\r\n            if (rv) {\r\n                return rv;\r\n            }\r\n            else {\r\n                throw new FileError(ErrorCodes.EBADF, 'Invalid file descriptor.');\r\n            }\r\n        }\r\n        closeFd(fd) {\r\n            delete this.fdMap[fd];\r\n        }\r\n    }\r\n    \r\n    return files.FileSystem = FileSystem;\r\n});"]}