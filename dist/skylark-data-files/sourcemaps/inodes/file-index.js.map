{"version":3,"sources":["inodes/file-index.js"],"names":["define","paths","Stats","FileType","DirInode","FileInode","FileIndex","constructor","this","_index","addPath","fromListing","listing","idx","rootInode","queue","length","let","inode","children","name","next","pop","pwd","tree","parent","node","hasOwnProperty","push","FILE","_ls","fileIterator","cb","path","dir","file","getListing","item","getItem","isFileInode","getData","Error","dirpath","splitPath","_split_path","itemname","undefined","addItem","isDirInode","addPathFast","parentPath","itemNameMark","lastIndexOf","substring","itemName","isDir","removePath","remItem","child","ls","getInode","p","dirname","substr"],"mappings":"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","file":"../../inodes/file-index.js","sourcesContent":["define([\r\n    \"skylark-langx-paths\",\r\n    '../stats',\r\n    '../file-type',\r\n    \"./dir-inode\",\r\n    \"./file-inode\"\r\n], function (paths, Stats,FileType,DirInode,FileInode) {\r\n    'use strict';\r\n\r\n    /**\r\n     * A simple class for storing a filesystem index. Assumes that all paths passed\r\n     * to it are *absolute* paths.\r\n     *\r\n     * Can be used as a partial or a full index, although care must be taken if used\r\n     * for the former purpose, especially when directories are concerned.\r\n     */\r\n    class FileIndex {\r\n        /**\r\n         * Constructs a new FileIndex.\r\n         */\r\n        constructor() {\r\n            // _index is a single-level key,value store that maps *directory* paths to\r\n            // DirInodes. File information is only contained in DirInodes themselves.\r\n            this._index = {};\r\n            // Create the root directory.\r\n            this.addPath('/', new DirInode());\r\n        }\r\n        /**\r\n         * Static method for constructing indices from a JSON listing.\r\n         * @param listing Directory listing generated by tools/XHRIndexer.coffee\r\n         * @return A new FileIndex object.\r\n         */\r\n        static fromListing(listing) {\r\n            const idx = new FileIndex();\r\n            // Add a root DirNode.\r\n            const rootInode = new DirInode();\r\n            idx._index['/'] = rootInode;\r\n            const queue = [['', listing, rootInode]];\r\n            while (queue.length > 0) {\r\n                let inode;\r\n                const next = queue.pop();\r\n                const pwd = next[0];\r\n                const tree = next[1];\r\n                const parent = next[2];\r\n                for (const node in tree) {\r\n                    if (tree.hasOwnProperty(node)) {\r\n                        const children = tree[node];\r\n                        const name = `${pwd}/${node}`;\r\n                        if (children) {\r\n                            idx._index[name] = inode = new DirInode();\r\n                            queue.push([name, children, inode]);\r\n                        }\r\n                        else {\r\n                            // This inode doesn't have correct size information, noted with -1.\r\n                            inode = new FileInode(new Stats(FileType.FILE, -1, 0x16D));\r\n                        }\r\n                        if (parent) {\r\n                            parent._ls[node] = inode;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return idx;\r\n        }\r\n        /**\r\n         * Runs the given function over all files in the index.\r\n         */\r\n        fileIterator(cb) {\r\n            for (const path in this._index) {\r\n                if (this._index.hasOwnProperty(path)) {\r\n                    const dir = this._index[path];\r\n                    const files = dir.getListing();\r\n                    for (const file of files) {\r\n                        const item = dir.getItem(file);\r\n                        if (FileInode.isFileInode(item)) {\r\n                            cb(item.getData());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Adds the given absolute path to the index if it is not already in the index.\r\n         * Creates any needed parent directories.\r\n         * @param path The path to add to the index.\r\n         * @param inode The inode for the\r\n         *   path to add.\r\n         * @return 'True' if it was added or already exists, 'false' if there\r\n         *   was an issue adding it (e.g. item in path is a file, item exists but is\r\n         *   different).\r\n         * @todo If adding fails and implicitly creates directories, we do not clean up\r\n         *   the new empty directories.\r\n         */\r\n        addPath(path, inode) {\r\n            if (!inode) {\r\n                throw new Error('Inode must be specified');\r\n            }\r\n            if (path[0] !== '/') {\r\n                throw new Error('Path must be absolute, got: ' + path);\r\n            }\r\n            // Check if it already exists.\r\n            if (this._index.hasOwnProperty(path)) {\r\n                return this._index[path] === inode;\r\n            }\r\n            const splitPath = this._split_path(path);\r\n            const dirpath = splitPath[0];\r\n            const itemname = splitPath[1];\r\n            // Try to add to its parent directory first.\r\n            let parent = this._index[dirpath];\r\n            if (parent === undefined && path !== '/') {\r\n                // Create parent.\r\n                parent = new DirInode();\r\n                if (!this.addPath(dirpath, parent)) {\r\n                    return false;\r\n                }\r\n            }\r\n            // Add myself to my parent.\r\n            if (path !== '/') {\r\n                if (!parent.addItem(itemname, inode)) {\r\n                    return false;\r\n                }\r\n            }\r\n            // If I'm a directory, add myself to the index.\r\n            if (DirInode.isDirInode(inode)) {\r\n                this._index[path] = inode;\r\n            }\r\n            return true;\r\n        }\r\n        /**\r\n         * Adds the given absolute path to the index if it is not already in the index.\r\n         * The path is added without special treatment (no joining of adjacent separators, etc).\r\n         * Creates any needed parent directories.\r\n         * @param path The path to add to the index.\r\n         * @param inode The inode for the\r\n         *   path to add.\r\n         * @return 'True' if it was added or already exists, 'false' if there\r\n         *   was an issue adding it (e.g. item in path is a file, item exists but is\r\n         *   different).\r\n         * @todo If adding fails and implicitly creates directories, we do not clean up\r\n         *   the new empty directories.\r\n         */\r\n        addPathFast(path, inode) {\r\n            const itemNameMark = path.lastIndexOf('/');\r\n            const parentPath = itemNameMark === 0 ? \"/\" : path.substring(0, itemNameMark);\r\n            const itemName = path.substring(itemNameMark + 1);\r\n            // Try to add to its parent directory first.\r\n            let parent = this._index[parentPath];\r\n            if (parent === undefined) {\r\n                // Create parent.\r\n                parent = new DirInode();\r\n                this.addPathFast(parentPath, parent);\r\n            }\r\n            if (!parent.addItem(itemName, inode)) {\r\n                return false;\r\n            }\r\n            // If adding a directory, add to the index as well.\r\n            if (inode.isDir()) {\r\n                this._index[path] = inode;\r\n            }\r\n            return true;\r\n        }\r\n        /**\r\n         * Removes the given path. Can be a file or a directory.\r\n         * @return The removed item,\r\n         *   or null if it did not exist.\r\n         */\r\n        removePath(path) {\r\n            const splitPath = this._split_path(path);\r\n            const dirpath = splitPath[0];\r\n            const itemname = splitPath[1];\r\n            // Try to remove it from its parent directory first.\r\n            const parent = this._index[dirpath];\r\n            if (parent === undefined) {\r\n                return null;\r\n            }\r\n            // Remove myself from my parent.\r\n            const inode = parent.remItem(itemname);\r\n            if (inode === null) {\r\n                return null;\r\n            }\r\n            // If I'm a directory, remove myself from the index, and remove my children.\r\n            if (DirInode.isDirInode(inode)) {\r\n                const children = inode.getListing();\r\n                for (const child of children) {\r\n                    this.removePath(path + '/' + child);\r\n                }\r\n                // Remove the directory from the index, unless it's the root.\r\n                if (path !== '/') {\r\n                    delete this._index[path];\r\n                }\r\n            }\r\n            return inode;\r\n        }\r\n        /**\r\n         * Retrieves the directory listing of the given path.\r\n         * @return An array of files in the given path, or 'null' if it does not exist.\r\n         */\r\n        ls(path) {\r\n            const item = this._index[path];\r\n            if (item === undefined) {\r\n                return null;\r\n            }\r\n            return item.getListing();\r\n        }\r\n        /**\r\n         * Returns the inode of the given item.\r\n         * @return Returns null if the item does not exist.\r\n         */\r\n        getInode(path) {\r\n            const splitPath = this._split_path(path);\r\n            const dirpath = splitPath[0];\r\n            const itemname = splitPath[1];\r\n            // Retrieve from its parent directory.\r\n            const parent = this._index[dirpath];\r\n            if (parent === undefined) {\r\n                return null;\r\n            }\r\n            // Root case\r\n            if (dirpath === path) {\r\n                return parent;\r\n            }\r\n            return parent.getItem(itemname);\r\n        }\r\n        /**\r\n         * Split into a (directory path, item name) pair\r\n         */\r\n        _split_path(p) {\r\n            const dirpath = paths.dirname(p);\r\n            const itemname = p.substr(dirpath.length + (dirpath === \"/\" ? 0 : 1));\r\n            return [dirpath, itemname];\r\n        }\r\n    }\r\n    \r\n\r\n    return FileIndex;\r\n});"]}