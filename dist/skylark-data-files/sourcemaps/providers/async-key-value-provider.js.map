{"version":3,"sources":["providers/async-key-value-provider.js"],"names":["define","GenerateRandomID","Buffer","paths","LRUCache","files","ErrorCodes","FileError","FileType","utils","Inode","BaseProvider","AsyncKeyValueFile","emptyBuffer","ROOT_NODE_ID","let","emptyDirNode","noError","e","cb","noErrorTx","tx","abort","AsyncKeyValueProvider","constructor","cacheSize","super","this","_cache","isAvailable","init","store","makeRootDirectory","getName","name","isReadOnly","supportsSymlinks","supportsProps","supportsSynch","empty","removeAll","clear","rename","oldPath","newPath","c","oldCb","beginTransaction","oldParent","dirname","oldName","basename","newParent","newName","inodes","lists","errorOccurred","indexOf","EBUSY","theOleSwitcharoo","hasOwnProperty","oldParentList","oldParentINode","newParentList","newParentINode","fileId","completeRename","put","id","from","JSON","stringify","commit","getINode","inode","isFile","del","EPERM","ENOENT","processInodeAndListings","findINodeAndDirListing","p","node","dirList","stat","isLstat","findINode","toStats","createFile","flag","mode","data","commitNewFile","FILE","newFile","openFile","get","undefined","unlink","removeEntry","rmdir","readdir","err","length","ENOTEMPTY","mkdir","DIRECTORY","getDirListing","dirListing","Object","keys","_sync","stats","_findINode","fileInodeId","fileInode","inodeChanged","update","toBuffer","currTime","Date","getTime","dirInode","parent","filename","join","handleDirectoryListings","set","resolve","fromBuffer","isDirectory","parse","toString","ENOTDIR","listing","addNewNode","retries","currId","reroll","EIO","committed","type","parentDir","fname","EEXIST","parentNode","dataId","isDir","remove","fileName","parentListing","fileNodeId","fileNode","EISDIR","providers"],"mappings":"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","file":"../../providers/async-key-value-provider.js","sourcesContent":["define([\r\n    \"skylark-langx-strings/generate-uuid\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"skylark-data-collections/lru-cache\",\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error',\r\n    \"../file-type\",\r\n    '../utils',\r\n    \"../inodes/inode\",\r\n    \"./base-provider\",\r\n    \"./async-key-value-file\"\r\n ], function (GenerateRandomID,Buffer,paths,LRUCache, files, ErrorCodes, FileError, FileType, utils, Inode,BaseProvider,AsyncKeyValueFile) {\r\n    'use strict';\r\n\r\n    const { emptyBuffer } = utils;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    const ROOT_NODE_ID = \"/\";\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    let emptyDirNode = null;\r\n\r\n    /**\r\n     * Returns an empty directory node.\r\n     * @hidden\r\n     */\r\n    function getEmptyDirNode() {\r\n        if (emptyDirNode) {\r\n            return emptyDirNode;\r\n        }\r\n        return emptyDirNode = Buffer.from(\"{}\");\r\n    }\r\n\r\n    /**\r\n     * Helper function. Checks if 'e' is defined. If so, it triggers the callback\r\n     * with 'e' and returns false. Otherwise, returns true.\r\n     * @hidden\r\n     */\r\n    function noError(e, cb) {\r\n        if (e) {\r\n            cb(e);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Helper function. Checks if 'e' is defined. If so, it aborts the transaction,\r\n     * triggers the callback with 'e', and returns false. Otherwise, returns true.\r\n     * @hidden\r\n     */\r\n    function noErrorTx(e, tx, cb) {\r\n        if (e) {\r\n            tx.abort(() => {\r\n                cb(e);\r\n            });\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * An \"Asynchronous key-value file system\". Stores data to/retrieves data from\r\n     * an underlying asynchronous key-value store.\r\n     */\r\n    class AsyncKeyValueProvider extends BaseProvider {\r\n        constructor(cacheSize) {\r\n            super();\r\n            this._cache = null;\r\n            if (cacheSize > 0) {\r\n                this._cache = new LRUCache(cacheSize);\r\n            }\r\n        }\r\n\r\n        static isAvailable() { return true; }\r\n        /**\r\n         * Initializes the file system. Typically called by subclasses' async\r\n         * constructors.\r\n         */\r\n        init(store, cb) {\r\n            this.store = store;\r\n            // INVARIANT: Ensure that the root exists.\r\n            this.makeRootDirectory(cb);\r\n        }\r\n\r\n        getName() { return this.store.name(); }\r\n        \r\n        isReadOnly() { return false; }\r\n        \r\n        supportsSymlinks() { return false; }\r\n        \r\n        supportsProps() { return false; }\r\n        \r\n        supportsSynch() { return false; }\r\n        \r\n        /**\r\n         * Delete all contents stored in the file system.\r\n         */\r\n        empty(cb) {\r\n            if (this._cache) {\r\n                this._cache.removeAll();\r\n            }\r\n            this.store.clear((e) => {\r\n                if (noError(e, cb)) {\r\n                    // INVARIANT: Root always exists.\r\n                    this.makeRootDirectory(cb);\r\n                }\r\n            });\r\n        }\r\n        \r\n        rename(oldPath, newPath, cb) {\r\n            // TODO: Make rename compatible with the cache.\r\n            if (this._cache) {\r\n                // Clear and disable cache during renaming process.\r\n                const c = this._cache;\r\n                this._cache = null;\r\n                c.removeAll();\r\n                const oldCb = cb;\r\n                cb = (e) => {\r\n                    // Restore empty cache.\r\n                    this._cache = c;\r\n                    oldCb(e);\r\n                };\r\n            }\r\n            const tx = this.store.beginTransaction('readwrite');\r\n            const oldParent = paths.dirname(oldPath), oldName = paths.basename(oldPath);\r\n            const newParent = paths.dirname(newPath), newName = paths.basename(newPath);\r\n            const inodes = {};\r\n            const lists = {};\r\n            let errorOccurred = false;\r\n            // Invariant: Can't move a folder inside itself.\r\n            // This funny little hack ensures that the check passes only if oldPath\r\n            // is a subpath of newParent. We append '/' to avoid matching folders that\r\n            // are a substring of the bottom-most folder in the path.\r\n            if ((newParent + '/').indexOf(oldPath + '/') === 0) {\r\n                return cb(new FileError(ErrorCodes.EBUSY, oldParent));\r\n            }\r\n            /**\r\n             * Responsible for Phase 2 of the rename operation: Modifying and\r\n             * committing the directory listings. Called once we have successfully\r\n             * retrieved both the old and new parent's inodes and listings.\r\n             */\r\n            const theOleSwitcharoo = () => {\r\n                // Sanity check: Ensure both paths are present, and no error has occurred.\r\n                if (errorOccurred || !lists.hasOwnProperty(oldParent) || !lists.hasOwnProperty(newParent)) {\r\n                    return;\r\n                }\r\n                const oldParentList = lists[oldParent], oldParentINode = inodes[oldParent], newParentList = lists[newParent], newParentINode = inodes[newParent];\r\n                // Delete file from old parent.\r\n                if (!oldParentList[oldName]) {\r\n                    cb(FileError.ENOENT(oldPath));\r\n                }\r\n                else {\r\n                    const fileId = oldParentList[oldName];\r\n                    delete oldParentList[oldName];\r\n                    // Finishes off the renaming process by adding the file to the new\r\n                    // parent.\r\n                    const completeRename = () => {\r\n                        newParentList[newName] = fileId;\r\n                        // Commit old parent's list.\r\n                        tx.put(oldParentINode.id, Buffer.from(JSON.stringify(oldParentList)), true, (e) => {\r\n                            if (noErrorTx(e, tx, cb)) {\r\n                                if (oldParent === newParent) {\r\n                                    // DONE!\r\n                                    tx.commit(cb);\r\n                                }\r\n                                else {\r\n                                    // Commit new parent's list.\r\n                                    tx.put(newParentINode.id, Buffer.from(JSON.stringify(newParentList)), true, (e) => {\r\n                                        if (noErrorTx(e, tx, cb)) {\r\n                                            tx.commit(cb);\r\n                                        }\r\n                                    });\r\n                                }\r\n                            }\r\n                        });\r\n                    };\r\n                    if (newParentList[newName]) {\r\n                        // 'newPath' already exists. Check if it's a file or a directory, and\r\n                        // act accordingly.\r\n                        this.getINode(tx, newPath, newParentList[newName], (e, inode) => {\r\n                            if (noErrorTx(e, tx, cb)) {\r\n                                if (inode.isFile()) {\r\n                                    // Delete the file and continue.\r\n                                    tx.del(inode.id, (e) => {\r\n                                        if (noErrorTx(e, tx, cb)) {\r\n                                            tx.del(newParentList[newName], (e) => {\r\n                                                if (noErrorTx(e, tx, cb)) {\r\n                                                    completeRename();\r\n                                                }\r\n                                            });\r\n                                        }\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    // Can't overwrite a directory using rename.\r\n                                    tx.abort((e) => {\r\n                                        cb(FileError.EPERM(newPath));\r\n                                    });\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                    else {\r\n                        completeRename();\r\n                    }\r\n                }\r\n            };\r\n            /**\r\n             * Grabs a path's inode and directory listing, and shoves it into the\r\n             * inodes and lists hashes.\r\n             */\r\n            const processInodeAndListings = (p) => {\r\n                this.findINodeAndDirListing(tx, p, (e, node, dirList) => {\r\n                    if (e) {\r\n                        if (!errorOccurred) {\r\n                            errorOccurred = true;\r\n                            tx.abort(() => {\r\n                                cb(e);\r\n                            });\r\n                        }\r\n                        // If error has occurred already, just stop here.\r\n                    }\r\n                    else {\r\n                        inodes[p] = node;\r\n                        lists[p] = dirList;\r\n                        theOleSwitcharoo();\r\n                    }\r\n                });\r\n            };\r\n            processInodeAndListings(oldParent);\r\n            if (oldParent !== newParent) {\r\n                processInodeAndListings(newParent);\r\n            }\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            const tx = this.store.beginTransaction('readonly');\r\n            this.findINode(tx, p, (e, inode) => {\r\n                if (noError(e, cb)) {\r\n                    cb(null, inode.toStats());\r\n                }\r\n            });\r\n        }\r\n        createFile(p, flag, mode, cb) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = emptyBuffer();\r\n            this.commitNewFile(tx, p, FileType.FILE, mode, data, (e, newFile) => {\r\n                if (noError(e, cb)) {\r\n                    cb(null, new AsyncKeyValueFile(this, p, flag, newFile.toStats(), data));\r\n                }\r\n            });\r\n        }\r\n\r\n        openFile(p, flag, cb) {\r\n            const tx = this.store.beginTransaction('readonly');\r\n            // Step 1: Grab the file's inode.\r\n            this.findINode(tx, p, (e, inode) => {\r\n                if (noError(e, cb)) {\r\n                    // Step 2: Grab the file's data.\r\n                    tx.get(inode.id, (e, data) => {\r\n                        if (noError(e, cb)) {\r\n                            if (data === undefined) {\r\n                                cb(FileError.ENOENT(p));\r\n                            }\r\n                            else {\r\n                                cb(null, new AsyncKeyValueFile(this, p, flag, inode.toStats(), data));\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        unlink(p, cb) {\r\n            this.removeEntry(p, false, cb);\r\n        }\r\n        \r\n        rmdir(p, cb) {\r\n            // Check first if directory is empty.\r\n            this.readdir(p, (err, files) => {\r\n                if (err) {\r\n                    cb(err);\r\n                }\r\n                else if (files.length > 0) {\r\n                    cb(FileError.ENOTEMPTY(p));\r\n                }\r\n                else {\r\n                    this.removeEntry(p, true, cb);\r\n                }\r\n            });\r\n        }\r\n        \r\n        mkdir(p, mode, cb) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');\r\n            this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data, cb);\r\n        }\r\n        \r\n        readdir(p, cb) {\r\n            const tx = this.store.beginTransaction('readonly');\r\n            this.findINode(tx, p, (e, inode) => {\r\n                if (noError(e, cb)) {\r\n                    this.getDirListing(tx, p, inode, (e, dirListing) => {\r\n                        if (noError(e, cb)) {\r\n                            cb(null, Object.keys(dirListing));\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        \r\n        _sync(p, data, stats, cb) {\r\n            // @todo Ensure mtime updates properly, and use that to determine if a data\r\n            //       update is required.\r\n            const tx = this.store.beginTransaction('readwrite');\r\n            // Step 1: Get the file node's ID.\r\n            this._findINode(tx, paths.dirname(p), paths.basename(p), (e, fileInodeId) => {\r\n                if (noErrorTx(e, tx, cb)) {\r\n                    // Step 2: Get the file inode.\r\n                    this.getINode(tx, p, fileInodeId, (e, fileInode) => {\r\n                        if (noErrorTx(e, tx, cb)) {\r\n                            const inodeChanged = fileInode.update(stats);\r\n                            // Step 3: Sync the data.\r\n                            tx.put(fileInode.id, data, true, (e) => {\r\n                                if (noErrorTx(e, tx, cb)) {\r\n                                    // Step 4: Sync the metadata (if it changed)!\r\n                                    if (inodeChanged) {\r\n                                        tx.put(fileInodeId, fileInode.toBuffer(), true, (e) => {\r\n                                            if (noErrorTx(e, tx, cb)) {\r\n                                                tx.commit(cb);\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                    else {\r\n                                        // No need to sync metadata; return.\r\n                                        tx.commit(cb);\r\n                                    }\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Checks if the root directory exists. Creates it if it doesn't.\r\n         */\r\n        makeRootDirectory(cb) {\r\n            const tx = this.store.beginTransaction('readwrite');\r\n            tx.get(ROOT_NODE_ID, (e, data) => {\r\n                if (e || data === undefined) {\r\n                    // Create new inode.\r\n                    const currTime = (new Date()).getTime(), \r\n                    // Mode 0666\r\n                    dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);\r\n                    // If the root doesn't exist, the first random ID shouldn't exist,\r\n                    // either.\r\n                    tx.put(dirInode.id, getEmptyDirNode(), false, (e) => {\r\n                        if (noErrorTx(e, tx, cb)) {\r\n                            tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false, (e) => {\r\n                                if (e) {\r\n                                    tx.abort(() => { cb(e); });\r\n                                }\r\n                                else {\r\n                                    tx.commit(cb);\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    // We're good.\r\n                    tx.commit(cb);\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Helper function for findINode.\r\n         * @param parent The parent directory of the file we are attempting to find.\r\n         * @param filename The filename of the inode we are attempting to find, minus\r\n         *   the parent.\r\n         * @param cb Passed an error or the ID of the file's inode in the file system.\r\n         */\r\n        _findINode(tx, parent, filename, cb) {\r\n            if (this._cache) {\r\n                const id = this._cache.get(paths.join(parent, filename));\r\n                if (id) {\r\n                    return cb(null, id);\r\n                }\r\n            }\r\n            const handleDirectoryListings = (e, inode, dirList) => {\r\n                if (e) {\r\n                    cb(e);\r\n                }\r\n                else if (dirList[filename]) {\r\n                    const id = dirList[filename];\r\n                    if (this._cache) {\r\n                        this._cache.set(paths.join(parent, filename), id);\r\n                    }\r\n                    cb(null, id);\r\n                }\r\n                else {\r\n                    cb(FileError.ENOENT(paths.resolve(parent, filename)));\r\n                }\r\n            };\r\n            if (parent === '/') {\r\n                if (filename === '') {\r\n                    // BASE CASE #1: Return the root's ID.\r\n                    if (this._cache) {\r\n                        this._cache.set(paths.join(parent, filename), ROOT_NODE_ID);\r\n                    }\r\n                    cb(null, ROOT_NODE_ID);\r\n                }\r\n                else {\r\n                    // BASE CASE #2: Find the item in the root node.\r\n                    this.getINode(tx, parent, ROOT_NODE_ID, (e, inode) => {\r\n                        if (noError(e, cb)) {\r\n                            this.getDirListing(tx, parent, inode, (e, dirList) => {\r\n                                // handle_directory_listings will handle e for us.\r\n                                handleDirectoryListings(e, inode, dirList);\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                // Get the parent directory's INode, and find the file in its directory\r\n                // listing.\r\n                this.findINodeAndDirListing(tx, parent, handleDirectoryListings);\r\n            }\r\n        }\r\n        /**\r\n         * Finds the Inode of the given path.\r\n         * @param p The path to look up.\r\n         * @param cb Passed an error or the Inode of the path p.\r\n         * @todo memoize/cache\r\n         */\r\n        findINode(tx, p, cb) {\r\n            this._findINode(tx, paths.dirname(p), paths.basename(p), (e, id) => {\r\n                if (noError(e, cb)) {\r\n                    this.getINode(tx, p, id, cb);\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Given the ID of a node, retrieves the corresponding Inode.\r\n         * @param tx The transaction to use.\r\n         * @param p The corresponding path to the file (used for error messages).\r\n         * @param id The ID to look up.\r\n         * @param cb Passed an error or the inode under the given id.\r\n         */\r\n        getINode(tx, p, id, cb) {\r\n            tx.get(id, (e, data) => {\r\n                if (noError(e, cb)) {\r\n                    if (data === undefined) {\r\n                        cb(FileError.ENOENT(p));\r\n                    }\r\n                    else {\r\n                        cb(null, Inode.fromBuffer(data));\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Given the Inode of a directory, retrieves the corresponding directory\r\n         * listing.\r\n         */\r\n        getDirListing(tx, p, inode, cb) {\r\n            if (!inode.isDirectory()) {\r\n                cb(FileError.ENOTDIR(p));\r\n            }\r\n            else {\r\n                tx.get(inode.id, (e, data) => {\r\n                    if (noError(e, cb)) {\r\n                        try {\r\n                            cb(null, JSON.parse(data.toString()));\r\n                        }\r\n                        catch (e) {\r\n                            // Occurs when data is undefined, or corresponds to something other\r\n                            // than a directory listing. The latter should never occur unless\r\n                            // the file system is corrupted.\r\n                            cb(FileError.ENOENT(p));\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        /**\r\n         * Given a path to a directory, retrieves the corresponding INode and\r\n         * directory listing.\r\n         */\r\n        findINodeAndDirListing(tx, p, cb) {\r\n            this.findINode(tx, p, (e, inode) => {\r\n                if (noError(e, cb)) {\r\n                    this.getDirListing(tx, p, inode, (e, listing) => {\r\n                        if (noError(e, cb)) {\r\n                            cb(null, inode, listing);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Adds a new node under a random ID. Retries 5 times before giving up in\r\n         * the exceedingly unlikely chance that we try to reuse a random GUID.\r\n         * @param cb Passed an error or the GUID that the data was stored under.\r\n         */\r\n        addNewNode(tx, data, cb) {\r\n            let retries = 0, currId;\r\n            const reroll = () => {\r\n                if (++retries === 5) {\r\n                    // Max retries hit. Return with an error.\r\n                    cb(new FileError(ErrorCodes.EIO, 'Unable to commit data to key-value store.'));\r\n                }\r\n                else {\r\n                    // Try again.\r\n                    currId = GenerateRandomID();\r\n                    tx.put(currId, data, false, (e, committed) => {\r\n                        if (e || !committed) {\r\n                            reroll();\r\n                        }\r\n                        else {\r\n                            // Successfully stored under 'currId'.\r\n                            cb(null, currId);\r\n                        }\r\n                    });\r\n                }\r\n            };\r\n            reroll();\r\n        }\r\n        /**\r\n         * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\r\n         * the given mode.\r\n         * Note: This will commit the transaction.\r\n         * @param p The path to the new file.\r\n         * @param type The type of the new file.\r\n         * @param mode The mode to create the new file with.\r\n         * @param data The data to store at the file's data node.\r\n         * @param cb Passed an error or the Inode for the new file.\r\n         */\r\n        commitNewFile(tx, p, type, mode, data, cb) {\r\n            const parentDir = paths.dirname(p), fname = paths.basename(p), currTime = (new Date()).getTime();\r\n            // Invariant: The root always exists.\r\n            // If we don't check this prior to taking steps below, we will create a\r\n            // file with name '' in root should p == '/'.\r\n            if (p === '/') {\r\n                return cb(FileError.EEXIST(p));\r\n            }\r\n            // Let's build a pyramid of code!\r\n            // Step 1: Get the parent directory's inode and directory listing\r\n            this.findINodeAndDirListing(tx, parentDir, (e, parentNode, dirListing) => {\r\n                if (noErrorTx(e, tx, cb)) {\r\n                    if (dirListing[fname]) {\r\n                        // File already exists.\r\n                        tx.abort(() => {\r\n                            cb(FileError.EEXIST(p));\r\n                        });\r\n                    }\r\n                    else {\r\n                        // Step 2: Commit data to store.\r\n                        this.addNewNode(tx, data, (e, dataId) => {\r\n                            if (noErrorTx(e, tx, cb)) {\r\n                                // Step 3: Commit the file's inode to the store.\r\n                                const fileInode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\r\n                                this.addNewNode(tx, fileInode.toBuffer(), (e, fileInodeId) => {\r\n                                    if (noErrorTx(e, tx, cb)) {\r\n                                        // Step 4: Update parent directory's listing.\r\n                                        dirListing[fname] = fileInodeId;\r\n                                        tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true, (e) => {\r\n                                            if (noErrorTx(e, tx, cb)) {\r\n                                                // Step 5: Commit and return the new inode.\r\n                                                tx.commit((e) => {\r\n                                                    if (noErrorTx(e, tx, cb)) {\r\n                                                        cb(null, fileInode);\r\n                                                    }\r\n                                                });\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Remove all traces of the given path from the file system.\r\n         * @param p The path to remove from the file system.\r\n         * @param isDir Does the path belong to a directory, or a file?\r\n         * @todo Update mtime.\r\n         */\r\n        removeEntry(p, isDir, cb) {\r\n            // Eagerly delete from cache (harmless even if removal fails)\r\n            if (this._cache) {\r\n                this._cache.remove(p);\r\n            }\r\n            const tx = this.store.beginTransaction('readwrite'), parent = paths.dirname(p), fileName = paths.basename(p);\r\n            // Step 1: Get parent directory's node and directory listing.\r\n            this.findINodeAndDirListing(tx, parent, (e, parentNode, parentListing) => {\r\n                if (noErrorTx(e, tx, cb)) {\r\n                    if (!parentListing[fileName]) {\r\n                        tx.abort(() => {\r\n                            cb(FileError.ENOENT(p));\r\n                        });\r\n                    }\r\n                    else {\r\n                        // Remove from directory listing of parent.\r\n                        const fileNodeId = parentListing[fileName];\r\n                        delete parentListing[fileName];\r\n                        // Step 2: Get file inode.\r\n                        this.getINode(tx, p, fileNodeId, (e, fileNode) => {\r\n                            if (noErrorTx(e, tx, cb)) {\r\n                                if (!isDir && fileNode.isDirectory()) {\r\n                                    tx.abort(() => {\r\n                                        cb(FileError.EISDIR(p));\r\n                                    });\r\n                                }\r\n                                else if (isDir && !fileNode.isDirectory()) {\r\n                                    tx.abort(() => {\r\n                                        cb(FileError.ENOTDIR(p));\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    // Step 3: Delete data.\r\n                                    tx.del(fileNode.id, (e) => {\r\n                                        if (noErrorTx(e, tx, cb)) {\r\n                                            // Step 4: Delete node.\r\n                                            tx.del(fileNodeId, (e) => {\r\n                                                if (noErrorTx(e, tx, cb)) {\r\n                                                    // Step 5: Update directory listing.\r\n                                                    tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true, (e) => {\r\n                                                        if (noErrorTx(e, tx, cb)) {\r\n                                                            tx.commit(cb);\r\n                                                        }\r\n                                                    });\r\n                                                }\r\n                                            });\r\n                                        }\r\n                                    });\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    return  files.providers.AsyncKeyValueProvider = AsyncKeyValueProvider;\r\n});"]}