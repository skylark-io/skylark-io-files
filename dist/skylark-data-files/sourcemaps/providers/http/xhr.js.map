{"version":3,"sources":["providers/http/xhr.js"],"names":["define","Buffer","ErrorCodes","FileError","utils","isIE","emptyBuffer","util","getFileSize","async","p","cb","req","XMLHttpRequest","open","onreadystatechange","e","readyState","status","EIO","parseInt","getResponseHeader","send","xhrIsAvailable","asyncDownloadFile","type","jsonSupported","responseType","EINVAL","response","from","JSON","parse","responseText","syncDownloadFile","Blob","data","err","overrideMimeType","text","alloc","length","i","charCodeAt","getFileSizeSync","rv","size","getFileSizeAsync"],"mappings":"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","file":"../../../providers/http/xhr.js","sourcesContent":["define([\n    \"skylark-langx-binary/buffer\",\n    '../../error-codes',\n    '../../file-error',\n    \"../../utils\"\n], function (Buffer,ErrorCodes,FileError,utils) {\n    'use strict';\n    /**\n     * Contains utility methods for performing a variety of tasks with\n     * XmlHttpRequest across browsers.\n     */\n    const { isIE, emptyBuffer } = util;\n\n\n    const xhrIsAvailable = (typeof (XMLHttpRequest) !== \"undefined\" && XMLHttpRequest !== null);\n    function asyncDownloadFileModern(p, type, cb) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, true);\n        let jsonSupported = true;\n        switch (type) {\n            case 'buffer':\n                req.responseType = 'arraybuffer';\n                break;\n            case 'json':\n                // Some browsers don't support the JSON response type.\n                // They either reset responseType, or throw an exception.\n                // @see https://github.com/Modernizr/Modernizr/blob/master/src/testXhrType.js\n                try {\n                    req.responseType = 'json';\n                    jsonSupported = req.responseType === 'json';\n                }\n                catch (e) {\n                    jsonSupported = false;\n                }\n                break;\n            default:\n                return cb(new FileError(ErrorCodes.EINVAL, \"Invalid download type: \" + type));\n        }\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            // XXX: WebKit-based browsers return *null* when XHRing an empty file.\n                            return cb(null, req.response ? Buffer.from(req.response) : emptyBuffer());\n                        case 'json':\n                            if (jsonSupported) {\n                                return cb(null, req.response);\n                            }\n                            else {\n                                return cb(null, JSON.parse(req.responseText));\n                            }\n                    }\n                }\n                else {\n                    return cb(new FileError(ErrorCodes.EIO, `XHR error: response returned code ${req.status}`));\n                }\n            }\n        };\n        req.send();\n    }\n    function syncDownloadFileModern(p, type) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, false);\n        // On most platforms, we cannot set the responseType of synchronous downloads.\n        // @todo Test for this; IE10 allows this, as do older versions of Chrome/FF.\n        let data = null;\n        let err = null;\n        // Classic hack to download binary data as a string.\n        req.overrideMimeType('text/plain; charset=x-user-defined');\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            // Convert the text into a buffer.\n                            const text = req.responseText;\n                            data = Buffer.alloc(text.length);\n                            // Throw away the upper bits of each character.\n                            for (let i = 0; i < text.length; i++) {\n                                // This will automatically throw away the upper bit of each\n                                // character for us.\n                                data[i] = text.charCodeAt(i);\n                            }\n                            return;\n                        case 'json':\n                            data = JSON.parse(req.responseText);\n                            return;\n                    }\n                }\n                else {\n                    err = new FileError(ErrorCodes.EIO, `XHR error: response returned code ${req.status}`);\n                    return;\n                }\n            }\n        };\n        req.send();\n        if (err) {\n            throw err;\n        }\n        return data;\n    }\n    function syncDownloadFileIE10(p, type) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, false);\n        switch (type) {\n            case 'buffer':\n                req.responseType = 'arraybuffer';\n                break;\n            case 'json':\n                // IE10 does not support the JSON type.\n                break;\n            default:\n                throw new FileError(ErrorCodes.EINVAL, \"Invalid download type: \" + type);\n        }\n        let data;\n        let err;\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            data = Buffer.from(req.response);\n                            break;\n                        case 'json':\n                            data = JSON.parse(req.response);\n                            break;\n                    }\n                }\n                else {\n                    err = new FileError(ErrorCodes.EIO, `XHR error: response returned code ${req.status}`);\n                }\n            }\n        };\n        req.send();\n        if (err) {\n            throw err;\n        }\n        return data;\n    }\n    /**\n     * @hidden\n     */\n    function getFileSize(async, p, cb) {\n        const req = new XMLHttpRequest();\n        req.open('HEAD', p, async);\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    try {\n                        return cb(null, parseInt(req.getResponseHeader('Content-Length') || '-1', 10));\n                    }\n                    catch (e) {\n                        // In the event that the header isn't present or there is an error...\n                        return cb(new FileError(ErrorCodes.EIO, \"XHR HEAD error: Could not read content-length.\"));\n                    }\n                }\n                else {\n                    return cb(new FileError(ErrorCodes.EIO, `XHR HEAD error: response returned code ${req.status}`));\n                }\n            }\n        };\n        req.send();\n    }\n    /**\n     * Asynchronously download a file as a buffer or a JSON object.\n     * Note that the third function signature with a non-specialized type is\n     * invalid, but TypeScript requires it when you specialize string arguments to\n     * constants.\n     * @hidden\n     */\n    let asyncDownloadFile = asyncDownloadFileModern;\n    /**\n     * Synchronously download a file as a buffer or a JSON object.\n     * Note that the third function signature with a non-specialized type is\n     * invalid, but TypeScript requires it when you specialize string arguments to\n     * constants.\n     * @hidden\n     */\n    let syncDownloadFile = (isIE && typeof Blob !== 'undefined') ? syncDownloadFileIE10 : syncDownloadFileModern;\n    /**\n     * Synchronously retrieves the size of the given file in bytes.\n     * @hidden\n     */\n    function getFileSizeSync(p) {\n        let rv = -1;\n        getFileSize(false, p, function (err, size) {\n            if (err) {\n                throw err;\n            }\n            rv = size;\n        });\n        return rv;\n    }\n    /**\n     * Asynchronously retrieves the size of the given file in bytes.\n     * @hidden\n     */\n    function getFileSizeAsync(p, cb) {\n        getFileSize(true, p, cb);\n    }\n\n\n\n    return {\n        xhrIsAvailable: xhrIsAvailable,\n        asyncDownloadFile: asyncDownloadFile,\n        syncDownloadFile: syncDownloadFile,\n        getFileSizeSync: getFileSizeSync,\n        getFileSizeAsync: getFileSizeAsync\n    };\n});"]}