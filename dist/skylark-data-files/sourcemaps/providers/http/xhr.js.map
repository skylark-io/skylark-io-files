{"version":3,"sources":["providers/http/xhr.js"],"names":["define","Buffer","ErrorCodes","FileError","utils","isIE","emptyBuffer","getFileSize","async","p","cb","req","XMLHttpRequest","open","onreadystatechange","e","readyState","status","EIO","parseInt","getResponseHeader","send","xhrIsAvailable","asyncDownloadFile","type","let","jsonSupported","responseType","EINVAL","response","from","JSON","parse","responseText","syncDownloadFile","Blob","data","err","overrideMimeType","text","alloc","length","i","charCodeAt","getFileSizeSync","rv","size","getFileSizeAsync"],"mappings":"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","file":"../../../providers/http/xhr.js","sourcesContent":["define([\r\n    \"skylark-langx-binary/buffer\",\r\n    '../../error-codes',\r\n    '../../file-error',\r\n    \"../../utils\"\r\n], function (Buffer,ErrorCodes,FileError,utils) {\r\n    'use strict';\r\n    /**\r\n     * Contains utility methods for performing a variety of tasks with\r\n     * XmlHttpRequest across browsers.\r\n     */\r\n    const { isIE, emptyBuffer } = utils;\r\n\r\n\r\n    const xhrIsAvailable = (typeof (XMLHttpRequest) !== \"undefined\" && XMLHttpRequest !== null);\r\n    function asyncDownloadFileModern(p, type, cb) {\r\n        const req = new XMLHttpRequest();\r\n        req.open('GET', p, true);\r\n        let jsonSupported = true;\r\n        switch (type) {\r\n            case 'buffer':\r\n                req.responseType = 'arraybuffer';\r\n                break;\r\n            case 'json':\r\n                // Some browsers don't support the JSON response type.\r\n                // They either reset responseType, or throw an exception.\r\n                // @see https://github.com/Modernizr/Modernizr/blob/master/src/testXhrType.js\r\n                try {\r\n                    req.responseType = 'json';\r\n                    jsonSupported = req.responseType === 'json';\r\n                }\r\n                catch (e) {\r\n                    jsonSupported = false;\r\n                }\r\n                break;\r\n            default:\r\n                return cb(new FileError(ErrorCodes.EINVAL, \"Invalid download type: \" + type));\r\n        }\r\n        req.onreadystatechange = function (e) {\r\n            if (req.readyState === 4) {\r\n                if (req.status === 200) {\r\n                    switch (type) {\r\n                        case 'buffer':\r\n                            // XXX: WebKit-based browsers return *null* when XHRing an empty file.\r\n                            return cb(null, req.response ? Buffer.from(req.response) : emptyBuffer());\r\n                        case 'json':\r\n                            if (jsonSupported) {\r\n                                return cb(null, req.response);\r\n                            }\r\n                            else {\r\n                                return cb(null, JSON.parse(req.responseText));\r\n                            }\r\n                    }\r\n                }\r\n                else {\r\n                    return cb(new FileError(ErrorCodes.EIO, `XHR error: response returned code ${req.status}`));\r\n                }\r\n            }\r\n        };\r\n        req.send();\r\n    }\r\n    function syncDownloadFileModern(p, type) {\r\n        const req = new XMLHttpRequest();\r\n        req.open('GET', p, false);\r\n        // On most platforms, we cannot set the responseType of synchronous downloads.\r\n        // @todo Test for this; IE10 allows this, as do older versions of Chrome/FF.\r\n        let data = null;\r\n        let err = null;\r\n        // Classic hack to download binary data as a string.\r\n        req.overrideMimeType('text/plain; charset=x-user-defined');\r\n        req.onreadystatechange = function (e) {\r\n            if (req.readyState === 4) {\r\n                if (req.status === 200) {\r\n                    switch (type) {\r\n                        case 'buffer':\r\n                            // Convert the text into a buffer.\r\n                            const text = req.responseText;\r\n                            data = Buffer.alloc(text.length);\r\n                            // Throw away the upper bits of each character.\r\n                            for (let i = 0; i < text.length; i++) {\r\n                                // This will automatically throw away the upper bit of each\r\n                                // character for us.\r\n                                data[i] = text.charCodeAt(i);\r\n                            }\r\n                            return;\r\n                        case 'json':\r\n                            data = JSON.parse(req.responseText);\r\n                            return;\r\n                    }\r\n                }\r\n                else {\r\n                    err = new FileError(ErrorCodes.EIO, `XHR error: response returned code ${req.status}`);\r\n                    return;\r\n                }\r\n            }\r\n        };\r\n        req.send();\r\n        if (err) {\r\n            throw err;\r\n        }\r\n        return data;\r\n    }\r\n    function syncDownloadFileIE10(p, type) {\r\n        const req = new XMLHttpRequest();\r\n        req.open('GET', p, false);\r\n        switch (type) {\r\n            case 'buffer':\r\n                req.responseType = 'arraybuffer';\r\n                break;\r\n            case 'json':\r\n                // IE10 does not support the JSON type.\r\n                break;\r\n            default:\r\n                throw new FileError(ErrorCodes.EINVAL, \"Invalid download type: \" + type);\r\n        }\r\n        let data;\r\n        let err;\r\n        req.onreadystatechange = function (e) {\r\n            if (req.readyState === 4) {\r\n                if (req.status === 200) {\r\n                    switch (type) {\r\n                        case 'buffer':\r\n                            data = Buffer.from(req.response);\r\n                            break;\r\n                        case 'json':\r\n                            data = JSON.parse(req.response);\r\n                            break;\r\n                    }\r\n                }\r\n                else {\r\n                    err = new FileError(ErrorCodes.EIO, `XHR error: response returned code ${req.status}`);\r\n                }\r\n            }\r\n        };\r\n        req.send();\r\n        if (err) {\r\n            throw err;\r\n        }\r\n        return data;\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function getFileSize(async, p, cb) {\r\n        const req = new XMLHttpRequest();\r\n        req.open('HEAD', p, async);\r\n        req.onreadystatechange = function (e) {\r\n            if (req.readyState === 4) {\r\n                if (req.status === 200) {\r\n                    try {\r\n                        return cb(null, parseInt(req.getResponseHeader('Content-Length') || '-1', 10));\r\n                    }\r\n                    catch (e) {\r\n                        // In the event that the header isn't present or there is an error...\r\n                        return cb(new FileError(ErrorCodes.EIO, \"XHR HEAD error: Could not read content-length.\"));\r\n                    }\r\n                }\r\n                else {\r\n                    return cb(new FileError(ErrorCodes.EIO, `XHR HEAD error: response returned code ${req.status}`));\r\n                }\r\n            }\r\n        };\r\n        req.send();\r\n    }\r\n    /**\r\n     * Asynchronously download a file as a buffer or a JSON object.\r\n     * Note that the third function signature with a non-specialized type is\r\n     * invalid, but TypeScript requires it when you specialize string arguments to\r\n     * constants.\r\n     * @hidden\r\n     */\r\n    let asyncDownloadFile = asyncDownloadFileModern;\r\n    /**\r\n     * Synchronously download a file as a buffer or a JSON object.\r\n     * Note that the third function signature with a non-specialized type is\r\n     * invalid, but TypeScript requires it when you specialize string arguments to\r\n     * constants.\r\n     * @hidden\r\n     */\r\n    let syncDownloadFile = (isIE && typeof Blob !== 'undefined') ? syncDownloadFileIE10 : syncDownloadFileModern;\r\n    /**\r\n     * Synchronously retrieves the size of the given file in bytes.\r\n     * @hidden\r\n     */\r\n    function getFileSizeSync(p) {\r\n        let rv = -1;\r\n        getFileSize(false, p, function (err, size) {\r\n            if (err) {\r\n                throw err;\r\n            }\r\n            rv = size;\r\n        });\r\n        return rv;\r\n    }\r\n    /**\r\n     * Asynchronously retrieves the size of the given file in bytes.\r\n     * @hidden\r\n     */\r\n    function getFileSizeAsync(p, cb) {\r\n        getFileSize(true, p, cb);\r\n    }\r\n\r\n\r\n\r\n    return {\r\n        xhrIsAvailable: xhrIsAvailable,\r\n        asyncDownloadFile: asyncDownloadFile,\r\n        syncDownloadFile: syncDownloadFile,\r\n        getFileSizeSync: getFileSizeSync,\r\n        getFileSizeAsync: getFileSizeAsync\r\n    };\r\n});"]}