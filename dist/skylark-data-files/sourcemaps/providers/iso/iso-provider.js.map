{"version":3,"sources":["providers/iso/iso-provider.js"],"names":["define","paths","SynchronousProvider","NoSyncFile","Stats","FileType","ActionType","FileError","ErrorCodes","utils","copyingSlice","bufferValidator","IsoProvider","constructor","data","name","super","this","_data","let","vdTerminatorFound","i","candidateVDs","Array","slice","VolumeDescriptor","type","push","PrimaryVolumeDescriptor","SupplementaryVolumeDescriptor","length","EIO","forEach","_pvd","v","_root","rootDirectoryEntry","_name","Create","opts","cb","e","isAvailable","getName","hasRockRidge","diskSpace","path","isReadOnly","supportsLinks","supportsProps","supportsSynch","statSync","p","isLstat","record","_getDirectoryRecord","ENOENT","_getStats","openSync","flags","mode","isWriteable","EPERM","isSymlink","resolve","getSymlinkPath","isDirectory","EISDIR","getFile","stats","pathExistsAction","THROW_EXCEPTION","TRUNCATE_FILE","EEXIST","NOP","EINVAL","readdirSync","getDirectory","getFileList","ENOTDIR","readFileSync","fname","encoding","flag","fd","fdBuff","getBuffer","toString","closeSync","components","split","dir","component","getRecord","newP","dirRec","len","dataLength","date","recordingDate","getTime","atime","mtime","ctime","entry","getSUEntries","PXEntry","TFEntry","access","modify","creation","DIRECTORY","FILE","Name","Options","description","validator"],"mappings":"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","file":"../../../providers/iso/iso-provider.js","sourcesContent":["define([\r\n    \"skylark-langx-paths\",\r\n    '../synchronous-provider',\r\n    \"../../no-sync-file\",\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../../action-type',\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    '../../utils'\r\n], function (paths,SynchronousProvider,NoSyncFile, Stats,FileType, ActionType,FileError, ErrorCodes, utils) {\r\n\r\n    'use strict';\r\n\r\n    const { copyingSlice, bufferValidator }  = utils;\r\n\r\n\r\n\r\n    /**\r\n     * Mounts an ISO file as a read-only file system.\r\n     *\r\n     * Supports:\r\n     * * Vanilla ISO9660 ISOs\r\n     * * Microsoft Joliet and Rock Ridge extensions to the ISO9660 standard\r\n     */\r\n    class IsoProvider extends SynchronousProvider {\r\n        /**\r\n         * **Deprecated. Please use IsoProvider.Create() method instead.**\r\n         *\r\n         * Constructs a read-only file system from the given ISO.\r\n         * @param data The ISO file in a buffer.\r\n         * @param name The name of the ISO (optional; used for debug messages / identification via getName()).\r\n         */\r\n        constructor(data, name = \"\") {\r\n            super();\r\n            this._data = data;\r\n            // Skip first 16 sectors.\r\n            let vdTerminatorFound = false;\r\n            let i = 16 * 2048;\r\n            const candidateVDs = new Array();\r\n            while (!vdTerminatorFound) {\r\n                const slice = data.slice(i);\r\n                const vd = new VolumeDescriptor(slice);\r\n                switch (vd.type()) {\r\n                    case 1 /* PrimaryVolumeDescriptor */:\r\n                        candidateVDs.push(new PrimaryVolumeDescriptor(slice));\r\n                        break;\r\n                    case 2 /* SupplementaryVolumeDescriptor */:\r\n                        candidateVDs.push(new SupplementaryVolumeDescriptor(slice));\r\n                        break;\r\n                    case 255 /* VolumeDescriptorSetTerminator */:\r\n                        vdTerminatorFound = true;\r\n                        break;\r\n                }\r\n                i += 2048;\r\n            }\r\n            if (candidateVDs.length === 0) {\r\n                throw new FileError(ErrorCodes.EIO, `Unable to find a suitable volume descriptor.`);\r\n            }\r\n            candidateVDs.forEach((v) => {\r\n                // Take an SVD over a PVD.\r\n                if (!this._pvd || this._pvd.type() !== 2 /* SupplementaryVolumeDescriptor */) {\r\n                    this._pvd = v;\r\n                }\r\n            });\r\n            this._root = this._pvd.rootDirectoryEntry(data);\r\n            this._name = name;\r\n        }\r\n        /**\r\n         * Creates an IsoProvider instance with the given options.\r\n         */\r\n        static Create(opts, cb) {\r\n            try {\r\n                cb(null, new IsoProvider(opts.data, opts.name));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        static isAvailable() {\r\n            return true;\r\n        }\r\n        getName() {\r\n            let name = `IsoProvider${this._name}${this._pvd ? `-${this._pvd.name()}` : ''}`;\r\n            if (this._root && this._root.hasRockRidge()) {\r\n                name += `-RockRidge`;\r\n            }\r\n            return name;\r\n        }\r\n        diskSpace(path, cb) {\r\n            // Read-only file system.\r\n            cb(this._data.length, 0);\r\n        }\r\n        isReadOnly() {\r\n            return true;\r\n        }\r\n        supportsLinks() {\r\n            return false;\r\n        }\r\n        supportsProps() {\r\n            return false;\r\n        }\r\n        supportsSynch() {\r\n            return true;\r\n        }\r\n        statSync(p, isLstat) {\r\n            const record = this._getDirectoryRecord(p);\r\n            if (record === null) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            return this._getStats(p, record);\r\n        }\r\n        openSync(p, flags, mode) {\r\n            // INVARIANT: Cannot write to RO file systems.\r\n            if (flags.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, p);\r\n            }\r\n            // Check if the path exists, and is a file.\r\n            const record = this._getDirectoryRecord(p);\r\n            if (!record) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            else if (record.isSymlink(this._data)) {\r\n                return this.openSync(paths.resolve(p, record.getSymlinkPath(this._data)), flags, mode);\r\n            }\r\n            else if (!record.isDirectory(this._data)) {\r\n                const data = record.getFile(this._data);\r\n                const stats = this._getStats(p, record);\r\n                switch (flags.pathExistsAction()) {\r\n                    case ActionType.THROW_EXCEPTION:\r\n                    case ActionType.TRUNCATE_FILE:\r\n                        throw FileError.EEXIST(p);\r\n                    case ActionType.NOP:\r\n                        return new NoSyncFile(this, p, flags, stats, data);\r\n                    default:\r\n                        throw new FileError(ErrorCodes.EINVAL, 'Invalid FileMode object.');\r\n                }\r\n            }\r\n            else {\r\n                throw FileError.EISDIR(p);\r\n            }\r\n        }\r\n        readdirSync(path) {\r\n            // Check if it exists.\r\n            const record = this._getDirectoryRecord(path);\r\n            if (!record) {\r\n                throw FileError.ENOENT(path);\r\n            }\r\n            else if (record.isDirectory(this._data)) {\r\n                return record.getDirectory(this._data).getFileList().slice(0);\r\n            }\r\n            else {\r\n                throw FileError.ENOTDIR(path);\r\n            }\r\n        }\r\n        /**\r\n         * Specially-optimized readfile.\r\n         */\r\n        readFileSync(fname, encoding, flag) {\r\n            // Get file.\r\n            const fd = this.openSync(fname, flag, 0x1a4);\r\n            try {\r\n                const fdCast = fd;\r\n                const fdBuff = fdCast.getBuffer();\r\n                if (encoding === null) {\r\n                    return copyingSlice(fdBuff);\r\n                }\r\n                return fdBuff.toString(encoding);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        _getDirectoryRecord(path) {\r\n            // Special case.\r\n            if (path === '/') {\r\n                return this._root;\r\n            }\r\n            const components = path.split('/').slice(1);\r\n            let dir = this._root;\r\n            for (const component of components) {\r\n                if (dir.isDirectory(this._data)) {\r\n                    dir = dir.getDirectory(this._data).getRecord(component);\r\n                    if (!dir) {\r\n                        return null;\r\n                    }\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n            return dir;\r\n        }\r\n        _getStats(p, record) {\r\n            if (record.isSymlink(this._data)) {\r\n                const newP = paths.resolve(p, record.getSymlinkPath(this._data));\r\n                const dirRec = this._getDirectoryRecord(newP);\r\n                if (!dirRec) {\r\n                    return null;\r\n                }\r\n                return this._getStats(newP, dirRec);\r\n            }\r\n            else {\r\n                const len = record.dataLength();\r\n                let mode = 0x16D;\r\n                const date = record.recordingDate().getTime();\r\n                let atime = date;\r\n                let mtime = date;\r\n                let ctime = date;\r\n                if (record.hasRockRidge()) {\r\n                    const entries = record.getSUEntries(this._data);\r\n                    for (const entry of entries) {\r\n                        if (entry instanceof PXEntry) {\r\n                            mode = entry.mode();\r\n                        }\r\n                        else if (entry instanceof TFEntry) {\r\n                            const flags = entry.flags();\r\n                            if (flags & 4 /* ACCESS */) {\r\n                                atime = entry.access().getTime();\r\n                            }\r\n                            if (flags & 2 /* MODIFY */) {\r\n                                mtime = entry.modify().getTime();\r\n                            }\r\n                            if (flags & 1 /* CREATION */) {\r\n                                ctime = entry.creation().getTime();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // Mask out writeable flags. This is a RO file system.\r\n                mode = mode & 0x16D;\r\n                return new Stats(record.isDirectory(this._data) ? FileType.DIRECTORY : FileType.FILE, len, mode, atime, mtime, ctime);\r\n            }\r\n        }\r\n    }\r\n    IsoProvider.Name = \"Iso\";\r\n    IsoProvider.Options = {\r\n        data: {\r\n            type: \"object\",\r\n            description: \"The ISO file in a buffer\",\r\n            validator: bufferValidator\r\n        }\r\n    };\r\n\r\n\r\n    return IsoProvider;\r\n});"]}