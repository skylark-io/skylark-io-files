{"version":3,"sources":["providers/iso/directory-record.js"],"names":["define","constructor","data","rockRidgeOffset","this","_suEntries","_fileOrDir","_data","_rockRidgeOffset","hasRockRidge","getRockRidgeOffset","rootCheckForRockRidge","isoData","dir","getDirectory","getDotEntry","_getRockRidgeOffset","length","extendedAttributeRecordLength","lba","readUInt32LE","dataLength","recordingDate","getShortFormDate","fileFlags","fileUnitSize","interleaveGapSize","volumeSequenceNumber","readUInt16LE","identifier","_getString","fileName","fn","_rockRidgeFilename","ident","isDirectory","versionSeparator","indexOf","slice","let","rv","getSUEntries","filter","e","CLEntry","isSymlink","SLEntry","getSymlinkPath","p","entries","getStr","_getGetString","entry","component","componentRecords","flags","content","continueFlag","getFile","Error","_constructDirectory","_constructSUEntries","nmEntries","NMEntry","str","getString","name","i","constructSystemUseEntries","suEntries","spEntry","SPEntry","checkBytesPass","RREntry","EREntry","extensionIdentifier","rockRidgeIdentifier","bytesSkipped"],"mappings":"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","file":"../../../providers/iso/directory-record.js","sourcesContent":["define([\r\n], function () {\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    class DirectoryRecord {\r\n        constructor(data, rockRidgeOffset) {\r\n            this._suEntries = null;\r\n            this._fileOrDir = null;\r\n            this._data = data;\r\n            this._rockRidgeOffset = rockRidgeOffset;\r\n        }\r\n        hasRockRidge() {\r\n            return this._rockRidgeOffset > -1;\r\n        }\r\n        getRockRidgeOffset() {\r\n            return this._rockRidgeOffset;\r\n        }\r\n        /**\r\n         * !!ONLY VALID ON ROOT NODE!!\r\n         * Checks if Rock Ridge is enabled, and sets the offset.\r\n         */\r\n        rootCheckForRockRidge(isoData) {\r\n            const dir = this.getDirectory(isoData);\r\n            this._rockRidgeOffset = dir.getDotEntry(isoData)._getRockRidgeOffset(isoData);\r\n            if (this._rockRidgeOffset > -1) {\r\n                // Wipe out directory. Start over with RR knowledge.\r\n                this._fileOrDir = null;\r\n            }\r\n        }\r\n        length() {\r\n            return this._data[0];\r\n        }\r\n        extendedAttributeRecordLength() {\r\n            return this._data[1];\r\n        }\r\n        lba() {\r\n            return this._data.readUInt32LE(2) * 2048;\r\n        }\r\n        dataLength() {\r\n            return this._data.readUInt32LE(10);\r\n        }\r\n        recordingDate() {\r\n            return getShortFormDate(this._data, 18);\r\n        }\r\n        fileFlags() {\r\n            return this._data[25];\r\n        }\r\n        fileUnitSize() {\r\n            return this._data[26];\r\n        }\r\n        interleaveGapSize() {\r\n            return this._data[27];\r\n        }\r\n        volumeSequenceNumber() {\r\n            return this._data.readUInt16LE(28);\r\n        }\r\n        identifier() {\r\n            return this._getString(33, this._data[32]);\r\n        }\r\n        fileName(isoData) {\r\n            if (this.hasRockRidge()) {\r\n                const fn = this._rockRidgeFilename(isoData);\r\n                if (fn !== null) {\r\n                    return fn;\r\n                }\r\n            }\r\n            const ident = this.identifier();\r\n            if (this.isDirectory(isoData)) {\r\n                return ident;\r\n            }\r\n            // Files:\r\n            // - MUST have 0x2E (.) separating the name from the extension\r\n            // - MUST have 0x3B (;) separating the file name and extension from the version\r\n            // Gets expanded to two-byte char in Unicode directory records.\r\n            const versionSeparator = ident.indexOf(';');\r\n            if (versionSeparator === -1) {\r\n                // Some Joliet filenames lack the version separator, despite the standard\r\n                // specifying that it should be there.\r\n                return ident;\r\n            }\r\n            else if (ident[versionSeparator - 1] === '.') {\r\n                // Empty extension. Do not include '.' in the filename.\r\n                return ident.slice(0, versionSeparator - 1);\r\n            }\r\n            else {\r\n                // Include up to version separator.\r\n                return ident.slice(0, versionSeparator);\r\n            }\r\n        }\r\n        isDirectory(isoData) {\r\n            let rv = !!(this.fileFlags() & 2 /* Directory */);\r\n            // If it lacks the Directory flag, it may still be a directory if we've exceeded the directory\r\n            // depth limit. Rock Ridge marks these as files and adds a special attribute.\r\n            if (!rv && this.hasRockRidge()) {\r\n                rv = this.getSUEntries(isoData).filter((e) => e instanceof CLEntry).length > 0;\r\n            }\r\n            return rv;\r\n        }\r\n        isSymlink(isoData) {\r\n            return this.hasRockRidge() && this.getSUEntries(isoData).filter((e) => e instanceof SLEntry).length > 0;\r\n        }\r\n        getSymlinkPath(isoData) {\r\n            let p = \"\";\r\n            const entries = this.getSUEntries(isoData);\r\n            const getStr = this._getGetString();\r\n            for (const entry of entries) {\r\n                if (entry instanceof SLEntry) {\r\n                    const components = entry.componentRecords();\r\n                    for (const component of components) {\r\n                        const flags = component.flags();\r\n                        if (flags & 2 /* CURRENT */) {\r\n                            p += \"./\";\r\n                        }\r\n                        else if (flags & 4 /* PARENT */) {\r\n                            p += \"../\";\r\n                        }\r\n                        else if (flags & 8 /* ROOT */) {\r\n                            p += \"/\";\r\n                        }\r\n                        else {\r\n                            p += component.content(getStr);\r\n                            if (!(flags & 1 /* CONTINUE */)) {\r\n                                p += '/';\r\n                            }\r\n                        }\r\n                    }\r\n                    if (!entry.continueFlag()) {\r\n                        // We are done with this link.\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (p.length > 1 && p[p.length - 1] === '/') {\r\n                // Trim trailing '/'.\r\n                return p.slice(0, p.length - 1);\r\n            }\r\n            else {\r\n                return p;\r\n            }\r\n        }\r\n        getFile(isoData) {\r\n            if (this.isDirectory(isoData)) {\r\n                throw new Error(`Tried to get a File from a directory.`);\r\n            }\r\n            if (this._fileOrDir === null) {\r\n                this._fileOrDir = isoData.slice(this.lba(), this.lba() + this.dataLength());\r\n            }\r\n            return this._fileOrDir;\r\n        }\r\n        getDirectory(isoData) {\r\n            if (!this.isDirectory(isoData)) {\r\n                throw new Error(`Tried to get a Directory from a file.`);\r\n            }\r\n            if (this._fileOrDir === null) {\r\n                this._fileOrDir = this._constructDirectory(isoData);\r\n            }\r\n            return this._fileOrDir;\r\n        }\r\n        getSUEntries(isoData) {\r\n            if (!this._suEntries) {\r\n                this._constructSUEntries(isoData);\r\n            }\r\n            return this._suEntries;\r\n        }\r\n        _rockRidgeFilename(isoData) {\r\n            const nmEntries = this.getSUEntries(isoData).filter((e) => e instanceof NMEntry);\r\n            if (nmEntries.length === 0 || nmEntries[0].flags() & (2 /* CURRENT */ | 4 /* PARENT */)) {\r\n                return null;\r\n            }\r\n            let str = '';\r\n            const getString = this._getGetString();\r\n            for (const e of nmEntries) {\r\n                str += e.name(getString);\r\n                if (!(e.flags() & 1 /* CONTINUE */)) {\r\n                    break;\r\n                }\r\n            }\r\n            return str;\r\n        }\r\n        _constructSUEntries(isoData) {\r\n            let i = 33 + this._data[32];\r\n            if (i % 2 === 1) {\r\n                // Skip padding field.\r\n                i++;\r\n            }\r\n            i += this._rockRidgeOffset;\r\n            this._suEntries = constructSystemUseEntries(this._data, i, this.length(), isoData);\r\n        }\r\n        /**\r\n         * !!ONLY VALID ON FIRST ENTRY OF ROOT DIRECTORY!!\r\n         * Returns -1 if rock ridge is not enabled. Otherwise, returns the offset\r\n         * at which system use fields begin.\r\n         */\r\n        _getRockRidgeOffset(isoData) {\r\n            // In the worst case, we get some garbage SU entries.\r\n            // Fudge offset to 0 before proceeding.\r\n            this._rockRidgeOffset = 0;\r\n            const suEntries = this.getSUEntries(isoData);\r\n            if (suEntries.length > 0) {\r\n                const spEntry = suEntries[0];\r\n                if (spEntry instanceof SPEntry && spEntry.checkBytesPass()) {\r\n                    // SUSP is in use.\r\n                    for (let i = 1; i < suEntries.length; i++) {\r\n                        const entry = suEntries[i];\r\n                        if (entry instanceof RREntry || (entry instanceof EREntry && entry.extensionIdentifier() === rockRidgeIdentifier)) {\r\n                            // Rock Ridge is in use!\r\n                            return spEntry.bytesSkipped();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Failed.\r\n            this._rockRidgeOffset = -1;\r\n            return -1;\r\n        }\r\n    }\r\n\r\n\r\n    return DirectoryRecord;\r\n});"]}