{"version":3,"sources":["providers/iso/directory.js"],"names":["define","constructor","record","isoData","this","_fileList","_fileMap","let","i","_record","lba","iLimit","dataLength","r","fname","fileFlags","cl","getSUEntries","filter","e","CLEntry","childDirectoryLba","Infinity","_constructDirectoryRecord","slice","fileName","hasRockRidge","REEntry","length","push","getRecord","name","getFileList","getDotEntry"],"mappings":";;;;;;;AAAAA,OAAO,GACJ,WACC,aA2DA,aArDIC,YAAYC,EAAQC,GAChBC,KAAKC,UAAY,GACjBD,KAAKE,SAAW,GAEhBC,IAAIC,GADJJ,KAAKK,QAAUP,GACAQ,IAAI,EACfC,EAASH,EAAIN,EAAOU,WAAW,EACnC,IAeUC,EACAC,EAVV,IAN2B,EAArBZ,EAAOa,UAAU,IAEbC,EAAKd,EAAOe,aAAad,CAAO,EAAEe,OAAO,GAAOC,aAAaC,OAAO,EAAE,GAC5EZ,EAA6B,KAAzBQ,EAAGK,kBAAkB,EACzBV,EAASW,EAAAA,GAENd,EAAIG,GAKK,IAJAR,EAAQK,GAKhBA,CAAC,IAMS,QAFRM,GADAD,EAAIT,KAAKmB,0BAA0BpB,EAAQqB,MAAMhB,CAAC,CAAC,GACzCiB,SAAStB,CAAO,IAEI,MAAVW,EAEjBD,EAAEa,aAAa,GAA4E,IAAvEb,EAAEI,aAAad,CAAO,EAAEe,OAAO,GAAOC,aAAaQ,OAAO,EAAEC,SACjFxB,KAAKE,SAASQ,GAASD,EACvBT,KAAKC,UAAUwB,KAAKf,CAAK,GAGxBH,IAAWW,EAAAA,IAEhBX,EAASH,EAAIK,EAAED,WAAW,GAE9BJ,GAAKK,EAAEe,OAAO,EAEtB,CAKAE,UAAUC,GACN,OAAO3B,KAAKE,SAASyB,EACzB,CACAC,cACI,OAAO5B,KAAKC,SAChB,CACA4B,YAAY9B,GACR,OAAOC,KAAKmB,0BAA0BpB,EAAQqB,MAAMpB,KAAKK,QAAQC,IAAI,CAAC,CAAC,CAC3E,CACJ,CAGJ,CAAC","file":"../../../providers/iso/directory.js","sourcesContent":["define([\r\n], function () {\r\n    'use strict';\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    class Directory {\r\n        constructor(record, isoData) {\r\n            this._fileList = [];\r\n            this._fileMap = {};\r\n            this._record = record;\r\n            let i = record.lba();\r\n            let iLimit = i + record.dataLength();\r\n            if (!(record.fileFlags() & 2 /* Directory */)) {\r\n                // Must have a CL entry.\r\n                const cl = record.getSUEntries(isoData).filter((e) => e instanceof CLEntry)[0];\r\n                i = cl.childDirectoryLba() * 2048;\r\n                iLimit = Infinity;\r\n            }\r\n            while (i < iLimit) {\r\n                const len = isoData[i];\r\n                // Zero-padding between sectors.\r\n                // TODO: Could optimize this to seek to nearest-sector upon\r\n                // seeing a 0.\r\n                if (len === 0) {\r\n                    i++;\r\n                    continue;\r\n                }\r\n                const r = this._constructDirectoryRecord(isoData.slice(i));\r\n                const fname = r.fileName(isoData);\r\n                // Skip '.' and '..' entries.\r\n                if (fname !== '\\u0000' && fname !== '\\u0001') {\r\n                    // Skip relocated entries.\r\n                    if (!r.hasRockRidge() || r.getSUEntries(isoData).filter((e) => e instanceof REEntry).length === 0) {\r\n                        this._fileMap[fname] = r;\r\n                        this._fileList.push(fname);\r\n                    }\r\n                }\r\n                else if (iLimit === Infinity) {\r\n                    // First entry contains needed data.\r\n                    iLimit = i + r.dataLength();\r\n                }\r\n                i += r.length();\r\n            }\r\n        }\r\n        /**\r\n         * Get the record with the given name.\r\n         * Returns undefined if not present.\r\n         */\r\n        getRecord(name) {\r\n            return this._fileMap[name];\r\n        }\r\n        getFileList() {\r\n            return this._fileList;\r\n        }\r\n        getDotEntry(isoData) {\r\n            return this._constructDirectoryRecord(isoData.slice(this._record.lba()));\r\n        }\r\n    }\r\n\r\n    return Directory;\r\n});"]}