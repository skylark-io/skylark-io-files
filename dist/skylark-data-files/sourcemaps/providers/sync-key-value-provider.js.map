{"version":3,"sources":["providers/sync-key-value-provider.js"],"names":["define","GenerateRandomID","Buffer","paths","files","ErrorCodes","FileError","BaseProvider","SynchronousProvider","utils","emptyBuffer","SyncKeyValueProvider","isAvailable","constructor","options","super","this","store","makeRootDirectory","getName","name","isReadOnly","supportsSymlinks","supportsProps","supportsSynch","empty","clear","renameSync","oldPath","newPath","tx","beginTransaction","oldParent","dirname","oldName","basename","newParent","newName","oldDirNode","findINode","oldDirList","getDirListing","ENOENT","nodeId","indexOf","EBUSY","let","newDirNode","newDirList","newNameNode","getINode","isFile","EPERM","del","id","e","abort","put","from","JSON","stringify","commit","statSync","p","isLstat","toStats","createFileSync","flag","mode","data","newFile","commitNewFile","FileType","FILE","SyncKeyValueFile","openFileSync","node","get","undefined","unlinkSync","removeEntry","rmdirSync","readdirSync","length","ENOTEMPTY","mkdirSync","DIRECTORY","Object","keys","_syncSync","stats","fileInodeId","_findINode","fileInode","inodeChanged","update","toBuffer","dirInode","ROOT_NODE_ID","currTime","Date","getTime","Inode","getEmptyDirNode","parent","filename","readDirectory","dirList","inode","resolve","sep","fromBuffer","isDirectory","ENOTDIR","parse","toString","addNewNode","currId","EIO","type","parentDir","fname","parentNode","dirListing","EEXIST","fileNode","dataId","fileNodeId","isDir","parentListing","fileName","EISDIR","providers"],"mappings":"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","file":"../../providers/sync-key-value-provider.js","sourcesContent":["define([\r\n    \"skylark-langx-strings/generate-uuid\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error',\r\n    \"./base-provider\",\r\n    \"./synchronous-provider\",\r\n    '../utils'\r\n], function (GenerateRandomID, Buffer,paths,files,ErrorCodes, FileError,BaseProvider, SynchronousProvider,  utils) {\r\n    'use strict';\r\n\r\n    const { emptyBuffer } = utils;\r\n\r\n\r\n    /**\r\n     * A \"Synchronous key-value file system\". Stores data to/retrieves data from an\r\n     * underlying key-value store.\r\n     *\r\n     * We use a unique ID for each node in the file system. The root node has a\r\n     * fixed ID.\r\n     * @todo Introduce Node ID caching.\r\n     * @todo Check modes.\r\n     */\r\n    class SyncKeyValueProvider extends SynchronousProvider {\r\n        static isAvailable() { return true; }\r\n        constructor(options) {\r\n            super();\r\n            this.store = options.store;\r\n            // INVARIANT: Ensure that the root exists.\r\n            this.makeRootDirectory();\r\n        }\r\n        getName() { return this.store.name(); }\r\n        isReadOnly() { return false; }\r\n        supportsSymlinks() { return false; }\r\n        supportsProps() { return false; }\r\n        supportsSynch() { return true; }\r\n        /**\r\n         * Delete all contents stored in the file system.\r\n         */\r\n        empty() {\r\n            this.store.clear();\r\n            // INVARIANT: Root always exists.\r\n            this.makeRootDirectory();\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            const tx = this.store.beginTransaction('readwrite'), oldParent = paths.dirname(oldPath), oldName = paths.basename(oldPath), newParent = paths.dirname(newPath), newName = paths.basename(newPath), \r\n            // Remove oldPath from parent's directory listing.\r\n            oldDirNode = this.findINode(tx, oldParent), oldDirList = this.getDirListing(tx, oldParent, oldDirNode);\r\n            if (!oldDirList[oldName]) {\r\n                throw FileError.ENOENT(oldPath);\r\n            }\r\n            const nodeId = oldDirList[oldName];\r\n            delete oldDirList[oldName];\r\n            // Invariant: Can't move a folder inside itself.\r\n            // This funny little hack ensures that the check passes only if oldPath\r\n            // is a subpath of newParent. We append '/' to avoid matching folders that\r\n            // are a substring of the bottom-most folder in the path.\r\n            if ((newParent + '/').indexOf(oldPath + '/') === 0) {\r\n                throw new FileError(ErrorCodes.EBUSY, oldParent);\r\n            }\r\n            // Add newPath to parent's directory listing.\r\n            let newDirNode, newDirList;\r\n            if (newParent === oldParent) {\r\n                // Prevent us from re-grabbing the same directory listing, which still\r\n                // contains oldName.\r\n                newDirNode = oldDirNode;\r\n                newDirList = oldDirList;\r\n            }\r\n            else {\r\n                newDirNode = this.findINode(tx, newParent);\r\n                newDirList = this.getDirListing(tx, newParent, newDirNode);\r\n            }\r\n            if (newDirList[newName]) {\r\n                // If it's a file, delete it.\r\n                const newNameNode = this.getINode(tx, newPath, newDirList[newName]);\r\n                if (newNameNode.isFile()) {\r\n                    try {\r\n                        tx.del(newNameNode.id);\r\n                        tx.del(newDirList[newName]);\r\n                    }\r\n                    catch (e) {\r\n                        tx.abort();\r\n                        throw e;\r\n                    }\r\n                }\r\n                else {\r\n                    // If it's a directory, throw a permissions error.\r\n                    throw FileError.EPERM(newPath);\r\n                }\r\n            }\r\n            newDirList[newName] = nodeId;\r\n            // Commit the two changed directory listings.\r\n            try {\r\n                tx.put(oldDirNode.id, Buffer.from(JSON.stringify(oldDirList)), true);\r\n                tx.put(newDirNode.id, Buffer.from(JSON.stringify(newDirList)), true);\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            tx.commit();\r\n        }\r\n        statSync(p, isLstat) {\r\n            // Get the inode to the item, convert it into a Stats object.\r\n            return this.findINode(this.store.beginTransaction('readonly'), p).toStats();\r\n        }\r\n        createFileSync(p, flag, mode) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = emptyBuffer(), newFile = this.commitNewFile(tx, p, FileType.FILE, mode, data);\r\n            // Open the file.\r\n            return new SyncKeyValueFile(this, p, flag, newFile.toStats(), data);\r\n        }\r\n        openFileSync(p, flag) {\r\n            const tx = this.store.beginTransaction('readonly'), node = this.findINode(tx, p), data = tx.get(node.id);\r\n            if (data === undefined) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            return new SyncKeyValueFile(this, p, flag, node.toStats(), data);\r\n        }\r\n        unlinkSync(p) {\r\n            this.removeEntry(p, false);\r\n        }\r\n        rmdirSync(p) {\r\n            // Check first if directory is empty.\r\n            if (this.readdirSync(p).length > 0) {\r\n                throw FileError.ENOTEMPTY(p);\r\n            }\r\n            else {\r\n                this.removeEntry(p, true);\r\n            }\r\n        }\r\n        mkdirSync(p, mode) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');\r\n            this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data);\r\n        }\r\n        readdirSync(p) {\r\n            const tx = this.store.beginTransaction('readonly');\r\n            return Object.keys(this.getDirListing(tx, p, this.findINode(tx, p)));\r\n        }\r\n        _syncSync(p, data, stats) {\r\n            // @todo Ensure mtime updates properly, and use that to determine if a data\r\n            //       update is required.\r\n            const tx = this.store.beginTransaction('readwrite'), \r\n            // We use the _findInode helper because we actually need the INode id.\r\n            fileInodeId = this._findINode(tx, paths.dirname(p), paths.basename(p)), fileInode = this.getINode(tx, p, fileInodeId), inodeChanged = fileInode.update(stats);\r\n            try {\r\n                // Sync data.\r\n                tx.put(fileInode.id, data, true);\r\n                // Sync metadata.\r\n                if (inodeChanged) {\r\n                    tx.put(fileInodeId, fileInode.toBuffer(), true);\r\n                }\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            tx.commit();\r\n        }\r\n        /**\r\n         * Checks if the root directory exists. Creates it if it doesn't.\r\n         */\r\n        makeRootDirectory() {\r\n            const tx = this.store.beginTransaction('readwrite');\r\n            if (tx.get(ROOT_NODE_ID) === undefined) {\r\n                // Create new inode.\r\n                const currTime = (new Date()).getTime(), \r\n                // Mode 0666\r\n                dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);\r\n                // If the root doesn't exist, the first random ID shouldn't exist,\r\n                // either.\r\n                tx.put(dirInode.id, getEmptyDirNode(), false);\r\n                tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false);\r\n                tx.commit();\r\n            }\r\n        }\r\n        /**\r\n         * Helper function for findINode.\r\n         * @param parent The parent directory of the file we are attempting to find.\r\n         * @param filename The filename of the inode we are attempting to find, minus\r\n         *   the parent.\r\n         * @return string The ID of the file's inode in the file system.\r\n         */\r\n        _findINode(tx, parent, filename) {\r\n            const readDirectory = (inode) => {\r\n                // Get the root's directory listing.\r\n                const dirList = this.getDirListing(tx, parent, inode);\r\n                // Get the file's ID.\r\n                if (dirList[filename]) {\r\n                    return dirList[filename];\r\n                }\r\n                else {\r\n                    throw FileError.ENOENT(paths.resolve(parent, filename));\r\n                }\r\n            };\r\n            if (parent === '/') {\r\n                if (filename === '') {\r\n                    // BASE CASE #1: Return the root's ID.\r\n                    return ROOT_NODE_ID;\r\n                }\r\n                else {\r\n                    // BASE CASE #2: Find the item in the root ndoe.\r\n                    return readDirectory(this.getINode(tx, parent, ROOT_NODE_ID));\r\n                }\r\n            }\r\n            else {\r\n                return readDirectory(this.getINode(tx, parent + paths.sep + filename, this._findINode(tx, paths.dirname(parent), paths.basename(parent))));\r\n            }\r\n        }\r\n        /**\r\n         * Finds the Inode of the given path.\r\n         * @param p The path to look up.\r\n         * @return The Inode of the path p.\r\n         * @todo memoize/cache\r\n         */\r\n        findINode(tx, p) {\r\n            return this.getINode(tx, p, this._findINode(tx, paths.dirname(p), paths.basename(p)));\r\n        }\r\n        /**\r\n         * Given the ID of a node, retrieves the corresponding Inode.\r\n         * @param tx The transaction to use.\r\n         * @param p The corresponding path to the file (used for error messages).\r\n         * @param id The ID to look up.\r\n         */\r\n        getINode(tx, p, id) {\r\n            const inode = tx.get(id);\r\n            if (inode === undefined) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            return Inode.fromBuffer(inode);\r\n        }\r\n        /**\r\n         * Given the Inode of a directory, retrieves the corresponding directory\r\n         * listing.\r\n         */\r\n        getDirListing(tx, p, inode) {\r\n            if (!inode.isDirectory()) {\r\n                throw FileError.ENOTDIR(p);\r\n            }\r\n            const data = tx.get(inode.id);\r\n            if (data === undefined) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            return JSON.parse(data.toString());\r\n        }\r\n        /**\r\n         * Creates a new node under a random ID. Retries 5 times before giving up in\r\n         * the exceedingly unlikely chance that we try to reuse a random GUID.\r\n         * @return The GUID that the data was stored under.\r\n         */\r\n        addNewNode(tx, data) {\r\n            const retries = 0;\r\n            let currId;\r\n            while (retries < 5) {\r\n                try {\r\n                    currId = GenerateRandomID();\r\n                    tx.put(currId, data, false);\r\n                    return currId;\r\n                }\r\n                catch (e) {\r\n                    // Ignore and reroll.\r\n                }\r\n            }\r\n            throw new FileError(ErrorCodes.EIO, 'Unable to commit data to key-value store.');\r\n        }\r\n        /**\r\n         * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\r\n         * the given mode.\r\n         * Note: This will commit the transaction.\r\n         * @param p The path to the new file.\r\n         * @param type The type of the new file.\r\n         * @param mode The mode to create the new file with.\r\n         * @param data The data to store at the file's data node.\r\n         * @return The Inode for the new file.\r\n         */\r\n        commitNewFile(tx, p, type, mode, data) {\r\n            const parentDir = paths.dirname(p), fname = paths.basename(p), parentNode = this.findINode(tx, parentDir), dirListing = this.getDirListing(tx, parentDir, parentNode), currTime = (new Date()).getTime();\r\n            // Invariant: The root always exists.\r\n            // If we don't check this prior to taking steps below, we will create a\r\n            // file with name '' in root should p == '/'.\r\n            if (p === '/') {\r\n                throw FileError.EEXIST(p);\r\n            }\r\n            // Check if file already exists.\r\n            if (dirListing[fname]) {\r\n                throw FileError.EEXIST(p);\r\n            }\r\n            let fileNode;\r\n            try {\r\n                // Commit data.\r\n                const dataId = this.addNewNode(tx, data);\r\n                fileNode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\r\n                // Commit file node.\r\n                const fileNodeId = this.addNewNode(tx, fileNode.toBuffer());\r\n                // Update and commit parent directory listing.\r\n                dirListing[fname] = fileNodeId;\r\n                tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true);\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            tx.commit();\r\n            return fileNode;\r\n        }\r\n        /**\r\n         * Remove all traces of the given path from the file system.\r\n         * @param p The path to remove from the file system.\r\n         * @param isDir Does the path belong to a directory, or a file?\r\n         * @todo Update mtime.\r\n         */\r\n        removeEntry(p, isDir) {\r\n            const tx = this.store.beginTransaction('readwrite'), parent = paths.dirname(p), parentNode = this.findINode(tx, parent), parentListing = this.getDirListing(tx, parent, parentNode), fileName = paths.basename(p);\r\n            if (!parentListing[fileName]) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            // Remove from directory listing of parent.\r\n            const fileNodeId = parentListing[fileName];\r\n            delete parentListing[fileName];\r\n            // Get file inode.\r\n            const fileNode = this.getINode(tx, p, fileNodeId);\r\n            if (!isDir && fileNode.isDirectory()) {\r\n                throw FileError.EISDIR(p);\r\n            }\r\n            else if (isDir && !fileNode.isDirectory()) {\r\n                throw FileError.ENOTDIR(p);\r\n            }\r\n            try {\r\n                // Delete data.\r\n                tx.del(fileNode.id);\r\n                // Delete node.\r\n                tx.del(fileNodeId);\r\n                // Update directory listing.\r\n                tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true);\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            // Success.\r\n            tx.commit();\r\n        }\r\n    }\r\n\r\n\r\n    return files.providers.SyncKeyValueProvider = SyncKeyValueProvider;\r\n});"]}