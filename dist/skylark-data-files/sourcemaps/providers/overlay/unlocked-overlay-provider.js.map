{"version":3,"sources":["providers/overlay/unlocked-overlay-provider.js"],"names":["define","paths","BaseProvider","Stats","FileType","FileError","ErrorCodes","FileFlag","ActionType","OverlayFile","deletionLogPath","makeModeWritable","mode","getFlag","f","getFileFlag","UnlockedOverlayProvider","constructor","writable","readable","super","this","_isInitialized","_initializeCallbacks","_deletedFiles","_deleteLog","_deleteLogUpdatePending","_deleteLogUpdateNeeded","_deleteLogError","_writable","_readable","isReadOnly","EINVAL","isAvailable","getOverlayedProviders","_syncAsync","file","cb","createParentDirectoriesAsync","getPath","err","writeFile","getBuffer","getStats","_syncSync","createParentDirectories","writeFileSync","getName","OverlayFS","Name","_initialize","callbackArray","end","e","forEach","push","length","readFile","data","errno","ENOENT","_reparseDeletionLog","supportsSynch","supportsLinks","supportsProps","getDeletionLog","restoreDeletionLog","log","updateLog","rename","oldPath","newPath","checkInitAsync","checkPathAsync","EPERM","stat","oldErr","oldStats","newErr","newStats","self","copyDirContents","files","shift","oldFile","resolve","newFile","let","isDirectory","exists","mkdir","mkdirErr","readdir","ENOTDIR","readdirErr","ENOTEMPTY","EISDIR","unlink","renameSync","checkInitialized","checkPath","statSync","existsSync","stats","readdirSync","mkdirSync","name","readFileSync","unlinkSync","p","isLstat","clone","oldStat","open","flag","pathNotExistsAction","CREATE_FILE","pathExistsAction","TRUNCATE_FILE","NOP","readFileErr","size","EEXIST","openSync","buf","writableExists","readableExists","deletePath","rmdir","rmdirLower","rmdirSync","dirStats","wFiles","code","rFiles","seenMap","filtered","concat","filter","fPath","result","contents","fileP","existsWritable","existsReadable","chmod","isLchmod","operateOnWritableAsync","chmodSync","operateOnWritable","chown","uid","gid","chownSync","isLchown","utimes","atime","mtime","utimesSync","addition","split","path","slice","parent","dirname","toCreate","createParents","dir","pop","statDone","EBUSY","reverse","copyToWritable","copyToWritableAsync","pStats"],"mappings":"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","file":"../../../providers/overlay/unlocked-overlay-provider.js","sourcesContent":["define([\r\n    \"skylark-langx-paths\",\r\n    \"../base-provider\",\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    \"../../file-flag\",\r\n    \"../../action-type\",\r\n    \"./overlay-file\"\r\n], function (paths, BaseProvider, Stats,FileType,FileError, ErrorCodes, FileFlag,ActionType,OverlayFile) {\r\n    /**\r\n     * @hidden\r\n     */\r\n    const deletionLogPath = '/.deletedFiles.log';\r\n\r\n    /**\r\n     * Given a read-only mode, makes it writable.\r\n     * @hidden\r\n     */\r\n    function makeModeWritable(mode) {\r\n        return 0o222 | mode;\r\n    }\r\n\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    function getFlag(f) {\r\n        return FileFlag.getFileFlag(f);\r\n    }    \r\n     /**\r\n     * *INTERNAL, DO NOT USE DIRECTLY!*\r\n     *\r\n     * Core OverlayProviderclass that contains no locking whatsoever. We wrap these objects\r\n     * in a LockedFS to prevent races.\r\n     */\r\n    class UnlockedOverlayProvider extends BaseProvider {\r\n        constructor(writable, readable) {\r\n            super();\r\n            this._isInitialized = false;\r\n            this._initializeCallbacks = [];\r\n            this._deletedFiles = {};\r\n            this._deleteLog = '';\r\n            // If 'true', we have scheduled a delete log update.\r\n            this._deleteLogUpdatePending = false;\r\n            // If 'true', a delete log update is needed after the scheduled delete log\r\n            // update finishes.\r\n            this._deleteLogUpdateNeeded = false;\r\n            // If there was an error updating the delete log...\r\n            this._deleteLogError = null;\r\n            this._writable = writable;\r\n            this._readable = readable;\r\n            if (this._writable.isReadOnly()) {\r\n                throw new FileError(ErrorCodes.EINVAL, \"Writable file system must be writable.\");\r\n            }\r\n        }\r\n        static isAvailable() {\r\n            return true;\r\n        }\r\n        getOverlayedProviders() {\r\n            return {\r\n                readable: this._readable,\r\n                writable: this._writable\r\n            };\r\n        }\r\n        _syncAsync(file, cb) {\r\n            this.createParentDirectoriesAsync(file.getPath(), (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                this._writable.writeFile(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode, cb);\r\n            });\r\n        }\r\n        _syncSync(file) {\r\n            this.createParentDirectories(file.getPath());\r\n            this._writable.writeFileSync(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode);\r\n        }\r\n        getName() {\r\n            return OverlayFS.Name;\r\n        }\r\n        /**\r\n         * **INTERNAL METHOD**\r\n         *\r\n         * Called once to load up metadata stored on the writable file system.\r\n         */\r\n        _initialize(cb) {\r\n            const callbackArray = this._initializeCallbacks;\r\n            const end = (e) => {\r\n                this._isInitialized = !e;\r\n                this._initializeCallbacks = [];\r\n                callbackArray.forEach(((cb) => cb(e)));\r\n            };\r\n            // if we're already initialized, immediately invoke the callback\r\n            if (this._isInitialized) {\r\n                return cb();\r\n            }\r\n            callbackArray.push(cb);\r\n            // The first call to initialize initializes, the rest wait for it to complete.\r\n            if (callbackArray.length !== 1) {\r\n                return;\r\n            }\r\n            // Read deletion log, process into metadata.\r\n            this._writable.readFile(deletionLogPath, 'utf8', getFlag('r'), (err, data) => {\r\n                if (err) {\r\n                    // ENOENT === Newly-instantiated file system, and thus empty log.\r\n                    if (err.errno !== ErrorCodes.ENOENT) {\r\n                        return end(err);\r\n                    }\r\n                }\r\n                else {\r\n                    this._deleteLog = data;\r\n                }\r\n                this._reparseDeletionLog();\r\n                end();\r\n            });\r\n        }\r\n        isReadOnly() { return false; }\r\n        supportsSynch() { return this._readable.supportsSynch() && this._writable.supportsSynch(); }\r\n        supportsLinks() { return false; }\r\n        supportsProps() { return this._readable.supportsProps() && this._writable.supportsProps(); }\r\n        getDeletionLog() {\r\n            return this._deleteLog;\r\n        }\r\n        restoreDeletionLog(log) {\r\n            this._deleteLog = log;\r\n            this._reparseDeletionLog();\r\n            this.updateLog('');\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(oldPath, cb) || this.checkPathAsync(newPath, cb)) {\r\n                return;\r\n            }\r\n            if (oldPath === deletionLogPath || newPath === deletionLogPath) {\r\n                return cb(FileError.EPERM('Cannot rename deletion log.'));\r\n            }\r\n            // nothing to do if paths match\r\n            if (oldPath === newPath) {\r\n                return cb();\r\n            }\r\n            this.stat(oldPath, false, (oldErr, oldStats) => {\r\n                if (oldErr) {\r\n                    return cb(oldErr);\r\n                }\r\n                return this.stat(newPath, false, (newErr, newStats) => {\r\n                    const self = this;\r\n                    // precondition: both oldPath and newPath exist and are dirs.\r\n                    // decreases: |files|\r\n                    // Need to move *every file/folder* currently stored on\r\n                    // readable to its new location on writable.\r\n                    function copyDirContents(files) {\r\n                        const file = files.shift();\r\n                        if (!file) {\r\n                            return cb();\r\n                        }\r\n                        const oldFile = paths.resolve(oldPath, file);\r\n                        const newFile = paths.resolve(newPath, file);\r\n                        // Recursion! Should work for any nested files / folders.\r\n                        self.rename(oldFile, newFile, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            copyDirContents(files);\r\n                        });\r\n                    }\r\n                    let mode = 0o777;\r\n                    // from linux's rename(2) manpage: oldpath can specify a\r\n                    // directory.  In this case, newpath must either not exist, or\r\n                    // it must specify an empty directory.\r\n                    if (oldStats.isDirectory()) {\r\n                        if (newErr) {\r\n                            if (newErr.errno !== ErrorCodes.ENOENT) {\r\n                                return cb(newErr);\r\n                            }\r\n                            return this._writable.exists(oldPath, (exists) => {\r\n                                // simple case - both old and new are on the writable layer\r\n                                if (exists) {\r\n                                    return this._writable.rename(oldPath, newPath, cb);\r\n                                }\r\n                                this._writable.mkdir(newPath, mode, (mkdirErr) => {\r\n                                    if (mkdirErr) {\r\n                                        return cb(mkdirErr);\r\n                                    }\r\n                                    this._readable.readdir(oldPath, (err, files) => {\r\n                                        if (err) {\r\n                                            return cb();\r\n                                        }\r\n                                        copyDirContents(files);\r\n                                    });\r\n                                });\r\n                            });\r\n                        }\r\n                        mode = newStats.mode;\r\n                        if (!newStats.isDirectory()) {\r\n                            return cb(FileError.ENOTDIR(newPath));\r\n                        }\r\n                        this.readdir(newPath, (readdirErr, files) => {\r\n                            if (files && files.length) {\r\n                                return cb(FileError.ENOTEMPTY(newPath));\r\n                            }\r\n                            this._readable.readdir(oldPath, (err, files) => {\r\n                                if (err) {\r\n                                    return cb();\r\n                                }\r\n                                copyDirContents(files);\r\n                            });\r\n                        });\r\n                    }\r\n                    if (newStats && newStats.isDirectory()) {\r\n                        return cb(FileError.EISDIR(newPath));\r\n                    }\r\n                    this.readFile(oldPath, null, getFlag('r'), (err, data) => {\r\n                        if (err) {\r\n                            return cb(err);\r\n                        }\r\n                        return this.writeFile(newPath, data, null, getFlag('w'), oldStats.mode, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            return this.unlink(oldPath, cb);\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            this.checkInitialized();\r\n            this.checkPath(oldPath);\r\n            this.checkPath(newPath);\r\n            if (oldPath === deletionLogPath || newPath === deletionLogPath) {\r\n                throw FileError.EPERM('Cannot rename deletion log.');\r\n            }\r\n            // Write newPath using oldPath's contents, delete oldPath.\r\n            const oldStats = this.statSync(oldPath, false);\r\n            if (oldStats.isDirectory()) {\r\n                // Optimization: Don't bother moving if old === new.\r\n                if (oldPath === newPath) {\r\n                    return;\r\n                }\r\n                let mode = 0o777;\r\n                if (this.existsSync(newPath)) {\r\n                    const stats = this.statSync(newPath, false);\r\n                    mode = stats.mode;\r\n                    if (stats.isDirectory()) {\r\n                        if (this.readdirSync(newPath).length > 0) {\r\n                            throw FileError.ENOTEMPTY(newPath);\r\n                        }\r\n                    }\r\n                    else {\r\n                        throw FileError.ENOTDIR(newPath);\r\n                    }\r\n                }\r\n                // Take care of writable first. Move any files there, or create an empty directory\r\n                // if it doesn't exist.\r\n                if (this._writable.existsSync(oldPath)) {\r\n                    this._writable.renameSync(oldPath, newPath);\r\n                }\r\n                else if (!this._writable.existsSync(newPath)) {\r\n                    this._writable.mkdirSync(newPath, mode);\r\n                }\r\n                // Need to move *every file/folder* currently stored on readable to its new location\r\n                // on writable.\r\n                if (this._readable.existsSync(oldPath)) {\r\n                    this._readable.readdirSync(oldPath).forEach((name) => {\r\n                        // Recursion! Should work for any nested files / folders.\r\n                        this.renameSync(paths.resolve(oldPath, name), paths.resolve(newPath, name));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                if (this.existsSync(newPath) && this.statSync(newPath, false).isDirectory()) {\r\n                    throw FileError.EISDIR(newPath);\r\n                }\r\n                this.writeFileSync(newPath, this.readFileSync(oldPath, null, getFlag('r')), null, getFlag('w'), oldStats.mode);\r\n            }\r\n            if (oldPath !== newPath && this.existsSync(oldPath)) {\r\n                this.unlinkSync(oldPath);\r\n            }\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this._writable.stat(p, isLstat, (err, stat) => {\r\n                if (err && err.errno === ErrorCodes.ENOENT) {\r\n                    if (this._deletedFiles[p]) {\r\n                        cb(FileError.ENOENT(p));\r\n                    }\r\n                    this._readable.stat(p, isLstat, (err, stat) => {\r\n                        if (stat) {\r\n                            // Make the oldStat's mode writable. Preserve the topmost\r\n                            // part of the mode, which specifies if it is a file or a\r\n                            // directory.\r\n                            stat = Stats.clone(stat);\r\n                            stat.mode = makeModeWritable(stat.mode);\r\n                        }\r\n                        cb(err, stat);\r\n                    });\r\n                }\r\n                else {\r\n                    cb(err, stat);\r\n                }\r\n            });\r\n        }\r\n        statSync(p, isLstat) {\r\n            this.checkInitialized();\r\n            try {\r\n                return this._writable.statSync(p, isLstat);\r\n            }\r\n            catch (e) {\r\n                if (this._deletedFiles[p]) {\r\n                    throw FileError.ENOENT(p);\r\n                }\r\n                const oldStat = Stats.clone(this._readable.statSync(p, isLstat));\r\n                // Make the oldStat's mode writable. Preserve the topmost part of the\r\n                // mode, which specifies if it is a file or a directory.\r\n                oldStat.mode = makeModeWritable(oldStat.mode);\r\n                return oldStat;\r\n            }\r\n        }\r\n        open(p, flag, mode, cb) {\r\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\r\n                return;\r\n            }\r\n            this.stat(p, false, (err, stats) => {\r\n                if (stats) {\r\n                    switch (flag.pathExistsAction()) {\r\n                        case ActionType.TRUNCATE_FILE:\r\n                            return this.createParentDirectoriesAsync(p, (err) => {\r\n                                if (err) {\r\n                                    return cb(err);\r\n                                }\r\n                                this._writable.open(p, flag, mode, cb);\r\n                            });\r\n                        case ActionType.NOP:\r\n                            return this._writable.exists(p, (exists) => {\r\n                                if (exists) {\r\n                                    this._writable.open(p, flag, mode, cb);\r\n                                }\r\n                                else {\r\n                                    // at this point we know the stats object we got is from\r\n                                    // the readable FS.\r\n                                    stats = Stats.clone(stats);\r\n                                    stats.mode = mode;\r\n                                    this._readable.readFile(p, null, getFlag('r'), (readFileErr, data) => {\r\n                                        if (readFileErr) {\r\n                                            return cb(readFileErr);\r\n                                        }\r\n                                        if (stats.size === -1) {\r\n                                            stats.size = data.length;\r\n                                        }\r\n                                        const f = new OverlayFile(this, p, flag, stats, data);\r\n                                        cb(null, f);\r\n                                    });\r\n                                }\r\n                            });\r\n                        default:\r\n                            return cb(FileError.EEXIST(p));\r\n                    }\r\n                }\r\n                else {\r\n                    switch (flag.pathNotExistsAction()) {\r\n                        case ActionType.CREATE_FILE:\r\n                            return this.createParentDirectoriesAsync(p, (err) => {\r\n                                if (err) {\r\n                                    return cb(err);\r\n                                }\r\n                                return this._writable.open(p, flag, mode, cb);\r\n                            });\r\n                        default:\r\n                            return cb(FileError.ENOENT(p));\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        openSync(p, flag, mode) {\r\n            this.checkInitialized();\r\n            this.checkPath(p);\r\n            if (p === deletionLogPath) {\r\n                throw FileError.EPERM('Cannot open deletion log.');\r\n            }\r\n            if (this.existsSync(p)) {\r\n                switch (flag.pathExistsAction()) {\r\n                    case ActionType.TRUNCATE_FILE:\r\n                        this.createParentDirectories(p);\r\n                        return this._writable.openSync(p, flag, mode);\r\n                    case ActionType.NOP:\r\n                        if (this._writable.existsSync(p)) {\r\n                            return this._writable.openSync(p, flag, mode);\r\n                        }\r\n                        else {\r\n                            // Create an OverlayFile.\r\n                            const buf = this._readable.readFileSync(p, null, getFlag('r'));\r\n                            const stats = Stats.clone(this._readable.statSync(p, false));\r\n                            stats.mode = mode;\r\n                            return new OverlayFile(this, p, flag, stats, buf);\r\n                        }\r\n                    default:\r\n                        throw FileError.EEXIST(p);\r\n                }\r\n            }\r\n            else {\r\n                switch (flag.pathNotExistsAction()) {\r\n                    case ActionType.CREATE_FILE:\r\n                        this.createParentDirectories(p);\r\n                        return this._writable.openSync(p, flag, mode);\r\n                    default:\r\n                        throw FileError.ENOENT(p);\r\n                }\r\n            }\r\n        }\r\n        unlink(p, cb) {\r\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\r\n                return;\r\n            }\r\n            this.exists(p, (exists) => {\r\n                if (!exists) {\r\n                    return cb(FileError.ENOENT(p));\r\n                }\r\n                this._writable.exists(p, (writableExists) => {\r\n                    if (writableExists) {\r\n                        return this._writable.unlink(p, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            this.exists(p, (readableExists) => {\r\n                                if (readableExists) {\r\n                                    this.deletePath(p);\r\n                                }\r\n                                cb(null);\r\n                            });\r\n                        });\r\n                    }\r\n                    else {\r\n                        // if this only exists on the readable FS, add it to the\r\n                        // delete map.\r\n                        this.deletePath(p);\r\n                        cb(null);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        unlinkSync(p) {\r\n            this.checkInitialized();\r\n            this.checkPath(p);\r\n            if (this.existsSync(p)) {\r\n                if (this._writable.existsSync(p)) {\r\n                    this._writable.unlinkSync(p);\r\n                }\r\n                // if it still exists add to the delete log\r\n                if (this.existsSync(p)) {\r\n                    this.deletePath(p);\r\n                }\r\n            }\r\n            else {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n        }\r\n        rmdir(p, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            const rmdirLower = () => {\r\n                this.readdir(p, (err, files) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    if (files.length) {\r\n                        return cb(FileError.ENOTEMPTY(p));\r\n                    }\r\n                    this.deletePath(p);\r\n                    cb(null);\r\n                });\r\n            };\r\n            this.exists(p, (exists) => {\r\n                if (!exists) {\r\n                    return cb(FileError.ENOENT(p));\r\n                }\r\n                this._writable.exists(p, (writableExists) => {\r\n                    if (writableExists) {\r\n                        this._writable.rmdir(p, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            this._readable.exists(p, (readableExists) => {\r\n                                if (readableExists) {\r\n                                    rmdirLower();\r\n                                }\r\n                                else {\r\n                                    cb();\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                    else {\r\n                        rmdirLower();\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        rmdirSync(p) {\r\n            this.checkInitialized();\r\n            if (this.existsSync(p)) {\r\n                if (this._writable.existsSync(p)) {\r\n                    this._writable.rmdirSync(p);\r\n                }\r\n                if (this.existsSync(p)) {\r\n                    // Check if directory is empty.\r\n                    if (this.readdirSync(p).length > 0) {\r\n                        throw FileError.ENOTEMPTY(p);\r\n                    }\r\n                    else {\r\n                        this.deletePath(p);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.exists(p, (exists) => {\r\n                if (exists) {\r\n                    return cb(FileError.EEXIST(p));\r\n                }\r\n                // The below will throw should any of the parent directories\r\n                // fail to exist on _writable.\r\n                this.createParentDirectoriesAsync(p, (err) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    this._writable.mkdir(p, mode, cb);\r\n                });\r\n            });\r\n        }\r\n        mkdirSync(p, mode) {\r\n            this.checkInitialized();\r\n            if (this.existsSync(p)) {\r\n                throw FileError.EEXIST(p);\r\n            }\r\n            else {\r\n                // The below will throw should any of the parent directories fail to exist\r\n                // on _writable.\r\n                this.createParentDirectories(p);\r\n                this._writable.mkdirSync(p, mode);\r\n            }\r\n        }\r\n        readdir(p, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.stat(p, false, (err, dirStats) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                if (!dirStats.isDirectory()) {\r\n                    return cb(FileError.ENOTDIR(p));\r\n                }\r\n                this._writable.readdir(p, (err, wFiles) => {\r\n                    if (err && err.code !== 'ENOENT') {\r\n                        return cb(err);\r\n                    }\r\n                    else if (err || !wFiles) {\r\n                        wFiles = [];\r\n                    }\r\n                    this._readable.readdir(p, (err, rFiles) => {\r\n                        // if the directory doesn't exist on the lower FS set rFiles\r\n                        // here to simplify the following code.\r\n                        if (err || !rFiles) {\r\n                            rFiles = [];\r\n                        }\r\n                        // Readdir in both, check delete log on read-only file system's files, merge, return.\r\n                        const seenMap = {};\r\n                        const filtered = wFiles.concat(rFiles.filter((fPath) => !this._deletedFiles[`${p}/${fPath}`])).filter((fPath) => {\r\n                            // Remove duplicates.\r\n                            const result = !seenMap[fPath];\r\n                            seenMap[fPath] = true;\r\n                            return result;\r\n                        });\r\n                        cb(null, filtered);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        readdirSync(p) {\r\n            this.checkInitialized();\r\n            const dirStats = this.statSync(p, false);\r\n            if (!dirStats.isDirectory()) {\r\n                throw FileError.ENOTDIR(p);\r\n            }\r\n            // Readdir in both, check delete log on RO file system's listing, merge, return.\r\n            let contents = [];\r\n            try {\r\n                contents = contents.concat(this._writable.readdirSync(p));\r\n            }\r\n            catch (e) {\r\n                // NOP.\r\n            }\r\n            try {\r\n                contents = contents.concat(this._readable.readdirSync(p).filter((fPath) => !this._deletedFiles[`${p}/${fPath}`]));\r\n            }\r\n            catch (e) {\r\n                // NOP.\r\n            }\r\n            const seenMap = {};\r\n            return contents.filter((fileP) => {\r\n                const result = !seenMap[fileP];\r\n                seenMap[fileP] = true;\r\n                return result;\r\n            });\r\n        }\r\n        exists(p, cb) {\r\n            // Cannot pass an error back to callback, so throw an exception instead\r\n            // if not initialized.\r\n            this.checkInitialized();\r\n            this._writable.exists(p, (existsWritable) => {\r\n                if (existsWritable) {\r\n                    return cb(true);\r\n                }\r\n                this._readable.exists(p, (existsReadable) => {\r\n                    cb(existsReadable && this._deletedFiles[p] !== true);\r\n                });\r\n            });\r\n        }\r\n        existsSync(p) {\r\n            this.checkInitialized();\r\n            return this._writable.existsSync(p) || (this._readable.existsSync(p) && this._deletedFiles[p] !== true);\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.operateOnWritableAsync(p, (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                else {\r\n                    this._writable.chmod(p, isLchmod, mode, cb);\r\n                }\r\n            });\r\n        }\r\n        chmodSync(p, isLchmod, mode) {\r\n            this.checkInitialized();\r\n            this.operateOnWritable(p, () => {\r\n                this._writable.chmodSync(p, isLchmod, mode);\r\n            });\r\n        }\r\n        chown(p, isLchmod, uid, gid, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.operateOnWritableAsync(p, (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                else {\r\n                    this._writable.chown(p, isLchmod, uid, gid, cb);\r\n                }\r\n            });\r\n        }\r\n        chownSync(p, isLchown, uid, gid) {\r\n            this.checkInitialized();\r\n            this.operateOnWritable(p, () => {\r\n                this._writable.chownSync(p, isLchown, uid, gid);\r\n            });\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.operateOnWritableAsync(p, (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                else {\r\n                    this._writable.utimes(p, atime, mtime, cb);\r\n                }\r\n            });\r\n        }\r\n        utimesSync(p, atime, mtime) {\r\n            this.checkInitialized();\r\n            this.operateOnWritable(p, () => {\r\n                this._writable.utimesSync(p, atime, mtime);\r\n            });\r\n        }\r\n        deletePath(p) {\r\n            this._deletedFiles[p] = true;\r\n            this.updateLog(`d${p}\\n`);\r\n        }\r\n        updateLog(addition) {\r\n            this._deleteLog += addition;\r\n            if (this._deleteLogUpdatePending) {\r\n                this._deleteLogUpdateNeeded = true;\r\n            }\r\n            else {\r\n                this._deleteLogUpdatePending = true;\r\n                this._writable.writeFile(deletionLogPath, this._deleteLog, 'utf8', FileFlag.getFileFlag('w'), 0o644, (e) => {\r\n                    this._deleteLogUpdatePending = false;\r\n                    if (e) {\r\n                        this._deleteLogError = e;\r\n                    }\r\n                    else if (this._deleteLogUpdateNeeded) {\r\n                        this._deleteLogUpdateNeeded = false;\r\n                        this.updateLog('');\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        _reparseDeletionLog() {\r\n            this._deletedFiles = {};\r\n            this._deleteLog.split('\\n').forEach((path) => {\r\n                // If the log entry begins w/ 'd', it's a deletion.\r\n                this._deletedFiles[path.slice(1)] = path.slice(0, 1) === 'd';\r\n            });\r\n        }\r\n        checkInitialized() {\r\n            if (!this._isInitialized) {\r\n                throw new FileError(ErrorCodes.EPERM, \"OverlayProvideris not initialized. Please initialize OverlayProviderusing its initialize() method before using it.\");\r\n            }\r\n            else if (this._deleteLogError !== null) {\r\n                const e = this._deleteLogError;\r\n                this._deleteLogError = null;\r\n                throw e;\r\n            }\r\n        }\r\n        checkInitAsync(cb) {\r\n            if (!this._isInitialized) {\r\n                cb(new FileError(ErrorCodes.EPERM, \"OverlayProvideris not initialized. Please initialize OverlayProviderusing its initialize() method before using it.\"));\r\n                return false;\r\n            }\r\n            else if (this._deleteLogError !== null) {\r\n                const e = this._deleteLogError;\r\n                this._deleteLogError = null;\r\n                cb(e);\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        checkPath(p) {\r\n            if (p === deletionLogPath) {\r\n                throw FileError.EPERM(p);\r\n            }\r\n        }\r\n        checkPathAsync(p, cb) {\r\n            if (p === deletionLogPath) {\r\n                cb(FileError.EPERM(p));\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        createParentDirectoriesAsync(p, cb) {\r\n            let parent = paths.dirname(p);\r\n            const toCreate = [];\r\n            const self = this;\r\n            this._writable.stat(parent, false, statDone);\r\n            function statDone(err, stat) {\r\n                if (err) {\r\n                    if (parent === \"/\") {\r\n                        cb(new FileError(ErrorCodes.EBUSY, \"Invariant failed: root does not exist!\"));\r\n                    }\r\n                    else {\r\n                        toCreate.push(parent);\r\n                        parent = paths.dirname(parent);\r\n                        self._writable.stat(parent, false, statDone);\r\n                    }\r\n                }\r\n                else {\r\n                    createParents();\r\n                }\r\n            }\r\n            function createParents() {\r\n                if (!toCreate.length) {\r\n                    return cb();\r\n                }\r\n                const dir = toCreate.pop();\r\n                self._readable.stat(dir, false, (err, stats) => {\r\n                    // stop if we couldn't read the dir\r\n                    if (!stats) {\r\n                        return cb();\r\n                    }\r\n                    self._writable.mkdir(dir, stats.mode, (err) => {\r\n                        if (err) {\r\n                            return cb(err);\r\n                        }\r\n                        createParents();\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        /**\r\n         * With the given path, create the needed parent directories on the writable storage\r\n         * should they not exist. Use modes from the read-only storage.\r\n         */\r\n        createParentDirectories(p) {\r\n            let parent = paths.dirname(p), toCreate = [];\r\n            while (!this._writable.existsSync(parent)) {\r\n                toCreate.push(parent);\r\n                parent = paths.dirname(parent);\r\n            }\r\n            toCreate = toCreate.reverse();\r\n            toCreate.forEach((p) => {\r\n                this._writable.mkdirSync(p, this.statSync(p, false).mode);\r\n            });\r\n        }\r\n        /**\r\n         * Helper function:\r\n         * - Ensures p is on writable before proceeding. Throws an error if it doesn't exist.\r\n         * - Calls f to perform operation on writable.\r\n         */\r\n        operateOnWritable(p, f) {\r\n            if (this.existsSync(p)) {\r\n                if (!this._writable.existsSync(p)) {\r\n                    // File is on readable storage. Copy to writable storage before\r\n                    // changing its mode.\r\n                    this.copyToWritable(p);\r\n                }\r\n                f();\r\n            }\r\n            else {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n        }\r\n        operateOnWritableAsync(p, cb) {\r\n            this.exists(p, (exists) => {\r\n                if (!exists) {\r\n                    return cb(FileError.ENOENT(p));\r\n                }\r\n                this._writable.exists(p, (existsWritable) => {\r\n                    if (existsWritable) {\r\n                        cb();\r\n                    }\r\n                    else {\r\n                        return this.copyToWritableAsync(p, cb);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        /**\r\n         * Copy from readable to writable storage.\r\n         * PRECONDITION: File does not exist on writable storage.\r\n         */\r\n        copyToWritable(p) {\r\n            const pStats = this.statSync(p, false);\r\n            if (pStats.isDirectory()) {\r\n                this._writable.mkdirSync(p, pStats.mode);\r\n            }\r\n            else {\r\n                this.writeFileSync(p, this._readable.readFileSync(p, null, getFlag('r')), null, getFlag('w'), this.statSync(p, false).mode);\r\n            }\r\n        }\r\n        copyToWritableAsync(p, cb) {\r\n            this.stat(p, false, (err, pStats) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                if (pStats.isDirectory()) {\r\n                    return this._writable.mkdir(p, pStats.mode, cb);\r\n                }\r\n                // need to copy file.\r\n                this._readable.readFile(p, null, getFlag('r'), (err, data) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    this.writeFile(p, data, null, getFlag('w'), pStats.mode, cb);\r\n                });\r\n            });\r\n        }\r\n    }\r\n \r\n\r\n    return UnlockedOverlayProvider;\r\n});"]}