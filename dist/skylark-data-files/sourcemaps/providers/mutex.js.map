{"version":3,"sources":["providers/mutex.js"],"names":["define","defer","constructor","this","_locked","_waiters","lock","cb","push","unlock","Error","next","shift","tryLock","isLocked"],"mappings":";;;;;;;AAAAA,OAAO,CACH,6BACD,SAAUC,GACT,aA+CA,aAzCIC,cACIC,KAAKC,QAAU,CAAA,EACfD,KAAKE,SAAW,EACpB,CACAC,KAAKC,GACGJ,KAAKC,QACLD,KAAKE,SAASG,KAAKD,CAAE,GAGzBJ,KAAKC,QAAU,CAAA,EACfG,EAAG,EACP,CACAE,SACI,GAAI,CAACN,KAAKC,QACN,MAAM,IAAIM,MAAM,8BAA8B,EAElD,IAAMC,EAAOR,KAAKE,SAASO,MAAM,EAO7BD,EACAV,EAAMU,CAAI,EAGdR,KAAKC,QAAU,CAAA,CACnB,CACAS,UACI,MAAIV,CAAAA,KAAKC,UAGTD,KAAKC,QAAU,CAAA,EAEnB,CACAU,WACI,OAAOX,KAAKC,OAChB,CACJ,CAGJ,CAAC","file":"../../providers/mutex.js","sourcesContent":["define([\r\n    \"skylark-langx-funcs/defer\"\r\n], function (defer) {\r\n    'use strict';\r\n    /**\r\n     * Non-recursive mutex\r\n     * @hidden\r\n     */\r\n    class Mutex {\r\n        constructor() {\r\n            this._locked = false;\r\n            this._waiters = [];\r\n        }\r\n        lock(cb) {\r\n            if (this._locked) {\r\n                this._waiters.push(cb);\r\n                return;\r\n            }\r\n            this._locked = true;\r\n            cb();\r\n        }\r\n        unlock() {\r\n            if (!this._locked) {\r\n                throw new Error('unlock of a non-locked mutex');\r\n            }\r\n            const next = this._waiters.shift();\r\n            // don't unlock - we want to queue up next for the\r\n            // _end_ of the current task execution, but we don't\r\n            // want it to be called inline with whatever the\r\n            // current stack is.  This way we still get the nice\r\n            // behavior that an unlock immediately followed by a\r\n            // lock won't cause starvation.\r\n            if (next) {\r\n                defer(next);\r\n                return;\r\n            }\r\n            this._locked = false;\r\n        }\r\n        tryLock() {\r\n            if (this._locked) {\r\n                return false;\r\n            }\r\n            this._locked = true;\r\n            return true;\r\n        }\r\n        isLocked() {\r\n            return this._locked;\r\n        }\r\n    }\r\n\r\n    return Mutex;\r\n});"]}